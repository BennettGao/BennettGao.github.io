<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bennett の BLOG</title>
  
  <subtitle>鱼乘于水，鸟乘于风，草木乘于时</subtitle>
  <link href="https://bennettgao.github.io/atom.xml" rel="self"/>
  
  <link href="https://bennettgao.github.io/"/>
  <updated>2024-08-06T09:49:01.881Z</updated>
  <id>https://bennettgao.github.io/</id>
  
  <author>
    <name>Bennett Gao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存数据库Redis7</title>
    <link href="https://bennettgao.github.io/2024/08/03/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <id>https://bennettgao.github.io/2024/08/03/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</id>
    <published>2024-08-03T12:20:40.259Z</published>
    <updated>2024-08-06T09:49:01.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存数据库Redis7"><a href="#内存数据库Redis7" class="headerlink" title="内存数据库Redis7"></a>内存数据库Redis7</h1><h2 id="1-Redis概述"><a href="#1-Redis概述" class="headerlink" title="1.Redis概述"></a>1.Redis概述</h2><h3 id="1-1Redis-简介"><a href="#1-1Redis-简介" class="headerlink" title="1.1Redis 简介"></a>1.1Redis 简介</h3><p>Redis，Remote Dictionary Server，<strong>远程字典服务</strong>，由意大利人 Salvatore Sanfilippo（又名 Antirez）开发，是一个使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、NoSQL 开源内存数据库，其提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。2008 年时 Salvatore Sanfilippo 自己开发一个叫 LLOOGG 的网站。Redis 之所以称之为字典服务，是因为 Redis 是一个 key-value 存储系统。支持存储的 value类型很多，包括 String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等。</p><p>Redis 的国际知名用户有，Twitter、GitHub、Facebook 等，国内知名用户有，阿里巴巴、</p><p>腾讯、百度、搜狐、优酷、美团、小米等。熟练使用和运维 Redis 已经成为开发运维人员的</p><p>一个必备技能。</p><h4 id="1-1-1-NoSQL"><a href="#1-1-1-NoSQL" class="headerlink" title="1.1.1 NoSQL"></a>1.1.1 NoSQL</h4><p>NoSQL（“non-relational”， “Not Only SQL”），泛指非关系型的数据库。随着互联网 web2.0网站的兴起，传统的关系数据库在处理 web2.0 网站，特别是超大规模和高并发的 SNS 类型的 web2.0 纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。</p><p><strong>（1） 键值存储数据库</strong></p><p>就像 Map 一样的 key-value 对。典型代表就是 Redis。</p><p><strong>（2）列存储数据库</strong></p><p>关系型数据库是典型的行存储数据库。其存在的问题是，按行存储的数据在物理层面占用的是连续存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储。典型代表是 HBase</p><p><strong>（3）文档型数据库</strong></p><p>其是 NoSQL 与关系型数据的结合，最像关系型数据库的 NoSQL。典型代表是 MongoDB。</p><p>（4）<strong>图形(Graph)数据库</strong></p><p>用于存放一个节点关系的数据库，例如描述不同人间的关系。典型代表是 Neo4J。</p><h3 id="1-2Redis-的用途"><a href="#1-2Redis-的用途" class="headerlink" title="1.2Redis 的用途"></a><strong>1.2Redis</strong> 的用途</h3><p>Redis 在生产中使用最多的场景就是做<strong>数据缓存</strong>。即客户端从 DBMS 中查询出的数据首先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不仅减小了 RT，而且降低了 DBMS 的压力</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042013069.png" alt="image-20240804201321951"></p><p>根据 Redis 缓存的数据与 DBMS 中数据的同步性划分，缓存一般可划分为两类：<strong>实时同步缓存</strong>，与<strong>阶段性同步缓存</strong>。</p><p>实时同步缓存是指，DBMS 中数据更新后，<strong>Redis 缓存中的存放的相关数据会被立即清除</strong>，以促使再有对该数据的访问请求到来时，必须先从 DBMS 中查询获取到最新数据，然后再写入到 Redis。阶段性同步缓存是指，Redis 缓存中的数据允许在一段时间内与 DBMS 中的数据<strong>不完全一致</strong>(允许数据短暂不一致)。而这个时间段就是这个缓存数据的过期时间。</p><h3 id="1-3-Redis-特性"><a href="#1-3-Redis-特性" class="headerlink" title="1.3 Redis 特性"></a>1.3 Redis 特性</h3><p>能够做缓存的技术、中间件很多，例如，<strong>MyBatis 自带的二级缓存</strong>、 <strong>Memched</strong> 等。只所以在生产中做缓存的产品几乎无一例外的会选择 Redis ，是因 为它有很多其它产品所不具备的特性。</p><p>1.<strong>性能极高</strong>: Redis 读的速度可以达到 11w 次 &#x2F;s ，写的速度可以达到 8w 次 &#x2F;s 。只所以具有这么高的性能，因为以下几点原因：（ 1 Redis 的所有操作都是在内存中发生的。（ 2Redis 是用 C 语言开发的。（ 3 Redis 源码非常精细（集性能与优雅于一身）。</p><p>2.<strong>简单稳定</strong> :Redis 源码很少。早期版本只有 2w 行左右。从 3.0 版本开始，增加了集群功<br>能，代码变为了 5w 行左右。<br> 3**.持久化**: Redis 内存中的数据可以进行持久化，其有两种方式： RDB 与 AOF 。<br> 4.<strong>高可用集群</strong>: Redis 提供了高可用的主从集群功能，可以确保系统的安全性。<br> 5.<strong>丰富的数据类型</strong> :Redis 是一个 key value 存储系统 。支持存储的 value 类型很多，包括String( 字符串 、 L ist( 链表 、 Set( 集合 、 Z set(sorted set 有序集合 和 H ash （哈希类型等，还有 BitMap 、 HyperLogLog 、 Geo spatial 类型。<br>     BitMap ：一般用于大数据量的二值性统计。<br>     HyperLogLog ：其是 Hyperlog Log ，用于对数据量超级庞大的日志做去重统计。<br>     Geospatial ：地理 空间，其主要用于地理位置相关的计算。<br> 6.<strong>强大的功能</strong> :Redis 提供了数据过期功能、发布 订阅功能、简单事务功能，还支持 Lua<br>脚本扩展功能。<br> 7.<strong>客户端语言广泛</strong>: Redis 提供了简单的 TCP 通信协议，编程语言可以方便地的接入 Redis 。所以，有很多的开源社区、大公司等开发出了很多语言的 Redis 客户端。</p><p>8.<strong>支持 ACL 权限控制</strong> :之前的权限控制非常笨拙。从 Redis6 开始引入了 ACL 模块，可以<br>为不同用户定制不同的用户权限。</p><blockquote><p>ACL,Access Control List ，访问控制列表，是一种 细粒度 的权限管理策略，可以针对 任意用户与组 进行权限控制。 目前大多数 Unix 系统与 Linux 2.6 版本已经支持 ACL 了。Zookeeper 早已支持 ACL 了。<br>Unix与 Linux 系统默认使用是 UGO User 、 Group 、 Other 权限控制策略 ，其是一种 粗粒度 的权限管理策略</p></blockquote><p>9.<strong>支持多线程 IO 模型</strong>: Redis 之前版本采用的是<strong>单线程模型</strong>，从 6.0 版本开始支持了<strong>多线</strong><br><strong>程模型。</strong></p><h3 id="1-4Redis-的-IO-模型"><a href="#1-4Redis-的-IO-模型" class="headerlink" title="1.4Redis 的 IO 模型"></a>1.4Redis 的 IO 模型</h3><p>Redis 客户端提交的各种请求是如何最终被 Redis 处理的？ Redis 处理客户端请求所采用的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的。</p><h4 id="1-4-1-单线程模型"><a href="#1-4-1-单线程模型" class="headerlink" title="1.4.1 单线程模型"></a>1.4.1 单线程模型</h4><p>对于 Redis 3.0 及其以前版本， Redis 的 IO 模型采用的是 纯粹的<strong>单线程模型</strong> 。即<strong>所有客户端的请求全部由一个线程处理</strong>。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042024788.png" alt="image-20240804202425690"></p><p>​Redis 的单线程模型采用了 <strong>多路复用技术</strong> 。</p><blockquote><p>对于多路复用器的多路选择算法 常见的有三种： select 模型、 poll 模型、 epoll 模型。<br> poll 模型的选择算法：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的。<br> epoll 模型的选择算法：采用的是回调方式。 根据就绪事件发生后的处理方式的不同，<br>又可分为 LT 模型与 ET 模型。</p></blockquote><p>每个客户端 若 要向 Redis 提交请求，都 需要 与 Redis 建立一个 socket 连接，并向事件分发器 注册一个事件。一旦该事件发生就表明该连接已经就绪。而一旦连接就绪，事件分发器就会感知到，然后获取客户端通过该连接发送的请求，并将 由该事件分发器所绑定的这个唯一的线程来处理。如果该线程还在处理多 个任务，则将该任务写入到任务队列等待线程处理。</p><p>只所以称为事件分发器，是因为它会根据不同的就绪事件，将任务交由不同的事件处理器去处理。</p><h4 id="1-4-2-混合线程模型"><a href="#1-4-2-混合线程模型" class="headerlink" title="1.4.2 混合线程模型"></a>1.4.2 混合线程模型</h4><p>从Redis 4.0 版本开始， Redis 中就开始加入了多线程元素 。处理客户端请求的仍是单线程模型，但对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理。<br>例如，持久化、 对 AOF 的 rewrite 、对失效连接的清理等。</p><h4 id="1-4-3-多线程模型"><a href="#1-4-3-多线程模型" class="headerlink" title="1.4.3 多线程模型"></a>1.4.3 多线程模型</h4><p>Redis 6.0版本，才是真正意义上的多线程模型。因为其对于客户端请求的处理采用的是多线程模型。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042026417.png" alt="image-20240804202653310"></p><p>多线程IO 模型中的“多线程”仅用于接受、解析客户端的请求，然后将解析出的请求写入到任务队列。而对具体任务（命令）的处理，仍是由<strong>主线程</strong>处理。这样做 使得用户无需考虑线程安全问题，无需考虑事务控制 无需考虑像 LPUSH&#x2F;LPOP 等 命令的执行 顺序问题 。</p><h4 id="1-4-4-优缺点总结"><a href="#1-4-4-优缺点总结" class="headerlink" title="1.4.4 优缺点总结"></a>1.4.4 优缺点总结</h4><p>（1） <strong>单线程模型</strong><br>    优点：可维护性高，性能高。不存在并发读写情况，所以也就不存在执行顺序的不确定<br>性，不存在线程切换开销，不存在死锁问题，不存在为了数据安全而进行的加锁 解锁<br>开销。<br>    缺点：性能会受到影响，且由于单线程只能使用一个处理器，所以会形成处理器浪费。<br>（2） <strong>多线程模型</strong><br>    优点：其结合了多线程与单线程的优点，避开了它们的所有不足<br>    缺点：该模型没有显示不足。如果非要找其不足的话就是，其并非是一个真正意义上的<br>多线程 ””，因为真正处理 任务 的线程仍是单线程。所以，其对性能也是有些影响的。</p><h2 id="2-Redis的安装与配置"><a href="#2-Redis的安装与配置" class="headerlink" title="2.Redis的安装与配置"></a>2.Redis的安装与配置</h2><h3 id="2-1-Redis-的安装"><a href="#2-1-Redis-的安装" class="headerlink" title="2.1 Redis 的安装"></a>2.1 Redis 的安装</h3><h4 id="2-1-1-克隆并配置主机"><a href="#2-1-1-克隆并配置主机" class="headerlink" title="2.1.1 克隆并配置主机"></a>2.1.1 克隆并配置主机</h4><ul><li>修改 主机名 ：&#x2F; ho stname</li><li>修改网络配置 ：&#x2F; sysconfig&#x2F;network scripts&#x2F;ifcfg e ns33</li></ul><h4 id="2-1-2-安装前的准备工作"><a href="#2-1-2-安装前的准备工作" class="headerlink" title="2.1.2 安装前的准备工作"></a>2.1.2 安装前的准备工作</h4><p><strong>（1） 安装 gcc</strong><br>由于Redis 是由 C&#x2F;C++ 语言编写的， 而从官网下载的 Redis 安装包是需要编译后才可安装的， 所以对其进行编译就必须要使用相关编译器。对于 C&#x2F;C++ 语言的编译器，使用最多的是gcc 与 gcc-c++，而这两款编译器在 CentOS 7 中是没有安装的，所以首先要安装这两款编译器。<br>GCC,GNU Compiler Collection GNU 编译器集合。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042032171.png" alt="image-20240804203245116"></p><h4 id="2-1-3-安装-Redis"><a href="#2-1-3-安装-Redis" class="headerlink" title="2.1.3 安装 Redis"></a>2.1.3 安装 Redis</h4><p><strong>（1） 下载 Redis</strong></p><p>redis的官网为： <a href="http://redis.io/">http://redis.io</a> 。点击下面的链接可以直接进行下载。</p><p>linux可以通过wget命令来下载：</p><p>下载源码并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-7.0.6.tar.gz &amp;&amp; tar -zxvf redis-7.0.6.tar.gz</span><br></pre></td></tr></table></figure><p>编译安装</p><p>编译过程是根据Makefile 文件进行的，而 Redis 解压包中已经存在该文件了。所以可以直接进行编译 了 。</p><p>1、进入redis解压目录下执行make</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-7.0.6 &amp;&amp; make</span><br></pre></td></tr></table></figure><p>2、安装到指定目录（不指定去掉PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install PREFIX=/usr/local/redis</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042041508.png" alt="image-20240804204129423"></p><p>可以看到，共安装了三个组件： redis 服务器、客户端与一个 性能 测试工具 benchmark</p><p><strong>（2） 查看 bin 目录</strong></p><p>安装完成后，打开&#x2F;usr&#x2F;local&#x2F;bin 目录，可以看到出现了很多的文件。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042042447.png" alt="image-20240804204219384"></p><p>通过<strong>echo $PATH</strong> 可以看到， ，&#x2F;usr&#x2F;local&#x2F;bin 目录是存在于该系统变量中的， 这样这些命令就可以在任意目录中执行了。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042042587.png" alt="image-20240804204245536"></p><h4 id="2-1-4-Redis-启动-与停止"><a href="#2-1-4-Redis-启动-与停止" class="headerlink" title="2.1.4 Redis 启动 与停止"></a>2.1.4 Redis 启动 与停止</h4><p><strong>（1） 前台 启动</strong><br>在任意目录执行<strong>redis-server</strong> 命令即可启动 Redis 。 这种启动方式会占用当前命令行窗口。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042044719.png" alt="image-20240804204444632"></p><p>再开启 一个会话窗口，可以查看到当前的 Redis 进程，默认端口号为 6379</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042044156.png" alt="image-20240804204457097"></p><p>通过Ctrl + C 命令可以停止 Redis 。</p><p><strong>（2） 命令式 后台 启动</strong></p><p>使用nohub 命令，最后再添加一个&amp; 符，可以使要启动的程序在后 台以守护进程方式运行。这样的好处是，进程启动后不会占用一个会话窗口，且 其还会 在 当前目录，即运行启动命令的当前目录中创建一个 nohup.out 文件用于记录 Redis 的操作日志。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042045222.png" alt="image-20240804204530168"></p><p><strong>（3） Redis 的停止</strong></p><p>通过<strong>redis-cli shutdown</strong> 命令可以停止 Redis 。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042045523.png" alt="image-20240804204557475"></p><p><strong>（4） 配置式后台启动</strong></p><p>使用nohup 命令可以使 Redis 后台启动，但每次都要键入 nohup 与 &amp;符，比较麻烦。 可以通过修改 Linux 中 Redis 的核心配置文件 redis.conf 达到后台 启动的目的。 redis.conf 文件在Redis 的安装目录根下。</p><p>将 daemonize 属性值由 no 改为 yes ，使 Redis 进程以守护进程方式运行。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042046334.png" alt="image-20240804204655282"></p><p>修改后再启动 Redis ，就无需再键入 nohup 与 符了，但必须要指定启动所使用的 Redis配置文件。 这是为什么呢？<br>使用nohup redis server &amp; 命令启动 Redis 时，启动项中已经设置好了 Redis 各个参数的默认值， Redis 会按照这些设置的参数进行启动。但这些参数是可以在配置文件中进行修改的，修改后，需要在启动命令中指定要加载的配置文件，这样，配置文件中的参数值将覆盖原默认值。</p><p>​Redis已经给我们 提供好了配置文件模板，是 Redis 安装目录的根目录下的 redis.conf 文件。由于刚刚对 redis.conf 配置文件做了修改，所以在开启 Redis 时需要显示指出要加载的配置文件。配置文件应紧跟在 redis-server 的后面。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042047477.png" alt="image-20240804204750425"></p><h3 id="2-2-连接前的配置"><a href="#2-2-连接前的配置" class="headerlink" title="2.2 连接前的配置"></a>2.2 连接前的配置</h3><p>Redis是一个内存数据库服务器，就像 MySQL 一样，对其操作也需要通过客户端进行。若要使远程主机上的客户端能够 连接并访问到 服务端的 Redis ，则服务端首先要做如下配置。</p><h4 id="2-2-1-绑定客户端-IP"><a href="#2-2-1-绑定客户端-IP" class="headerlink" title="2.2.1 绑定客户端 IP"></a>2.2.1 绑定客户端 IP</h4><p>Redis可以通过修改配置文件来限定可以访问自己的客户端 IP 。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042048623.png" alt="image-20240804204833571"></p><p>以上设置后，只允许 当前 主机访问当前的 Redis ，其它主机均不可访问。 所以，如果不想限定访问的客户端，只需要将该行注释掉即可。</p><h4 id="2-2-2-关闭保护模式"><a href="#2-2-2-关闭保护模式" class="headerlink" title="2.2.2 关闭保护模式"></a>2.2.2 关闭保护模式</h4><p>默认保护模式是开启的。 其只允许 本机的客户端访问， 即只允许自己访问自己。但生产中 应该关闭， 以确保其它客户端可以连接 Redis 。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042049649.png" alt="image-20240804204907603"></p><h4 id="2-2-3-设置访问密码"><a href="#2-2-3-设置访问密码" class="headerlink" title="2.2.3 设置访问密码"></a>2.2.3 设置访问密码</h4><p>为Redis 设置访问密码，可以对要读 写 Redis 的用户进行身份验证。没有密码的用户可以登录 Redis ，但无法访问。</p><p><strong>（1） 密码设置</strong></p><p>访问密码的设置位置在redis.conf 配置文件中。默认是被注释掉的，没有密码。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042050017.png" alt="image-20240804205017964"></p><p>没有通 过密码登录的用户，无法读 写 Redis</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042050838.png" alt="image-20240804205029786"></p><p><strong>（2） 使用密码</strong></p><p>对于密码的使用，有两种方式：登录时未使用密码，则访问时先输入密码；登录时直接使用密码登录，访问时无需再输入密码。</p><p>A、 登录时未使用密码</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042052317.png" alt="image-20240804205208260"></p><p>B、 登录时使用密码</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042052707.png" alt="image-20240804205218650"></p><p>C、 退出时使用密码</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042052123.png" alt="image-20240804205231073"></p><h4 id="2-2-4-禁止-重命名命令"><a href="#2-2-4-禁止-重命名命令" class="headerlink" title="2.2.4 禁止 重命名命令"></a>2.2.4 禁止 重命名命令</h4><p>后面要学习两个非常危险的命令：flushal 与 flushdb 。它们都是用于直接删除整个 Redis数据库的。若让用户可以随便使用它们，可能会危及数据安全。 Redis 可以通过修改配置文件来禁止使用这些命令，或重命名这些命令。 以下配置 ，禁用了 flushall 与 flushdb 命令。<br>当然，在学习过程中暂时不禁用它们。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042053076.png" alt="image-20240804205314020"></p><h4 id="2-2-5-启-动-Redis"><a href="#2-2-5-启-动-Redis" class="headerlink" title="2.2.5 启 动 Redis"></a>2.2.5 启 动 Redis</h4><p>当然，若要使客户端能够连接Redis ，则必须开启服务端的 Redis 。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042053989.png" alt="image-20240804205337942"></p><h3 id="2-3-Redis-客户端分类"><a href="#2-3-Redis-客户端分类" class="headerlink" title="2.3 Redis 客户端分类"></a>2.3 Redis 客户端分类</h3><p>Redis客户端也像 MySQL 客户端一样有多种类型：命令行客户端、图形界面客户端、 Java代码客户端。</p><h4 id="2-3-1-命令行客户端"><a href="#2-3-1-命令行客户端" class="headerlink" title="2.3.1 命令行客户端"></a>2.3.1 命令行客户端</h4><p>Redis提供了基本的命令行客户端。打开命令行客户端的命令为 redis cli 。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042054372.png" alt="image-20240804205434318"></p><p>-h ：指定要连接的 Redis 服务器的 IP 。<br>-p ：指定要连接的 Redis 的端口号。</p><p>若连接的是本机Redis ，且端口号没有改变，保持默认的 6379 ，则 h 与 p 选项可以省略不写。</p><h4 id="2-3-2-图形界面客户端"><a href="#2-3-2-图形界面客户端" class="headerlink" title="2.3.2 图形界面客户端"></a>2.3.2 图形界面客户端</h4><p>（1） Redis Desktop Manager</p><p>​该软件原来是免费软件， 从 0.8.8 版本 后变为了商业化收费软件。<br>官网为：<a href="https://resp.app/">https://resp.app/</a> app&#x2F;（原来是 <a href="http://redisdesktop.com/">http://redisdesktop.com</a> ）。<br>（2） RedisPlus</p><p>​RedisPlus是为 Redis 可视化管理开发的一款开源免费的桌面客户端软件，支持 Windows 、Linux 、 Mac 三大系统平台， RedisPlus 提供更加高效、方便、快捷的使用体验，有着更加现代化的用户界面风格。<br>RedisPlus的官网地址为 https:<a href="https://gitee.com/MaxBill/RedisPlus">https://gitee.com/MaxBill/RedisPlus</a> 。</p><h4 id="2-3-3-Java-代码客户端"><a href="#2-3-3-Java-代码客户端" class="headerlink" title="2.3.3 Java 代码客户端"></a>2.3.3 Java 代码客户端</h4><p>所谓Java 代码客户端就是一套操作 Redis 的 API ，其作用就像 JDBC 一样，所以 Java 代码客户端其实就是一个或多个 Jar 包，提供了对 Redis 的操作接口。<br>对 Redis 操作的 API 很多 ，例如 jdbc redis 、 jredis 等 ，但最常用也是最有名的是 <strong>Jedis</strong> 。</p><h3 id="2-4-Redis-配置文件详解"><a href="#2-4-Redis-配置文件详解" class="headerlink" title="2.4 Redis 配置文件详解"></a>2.4 Redis 配置文件详解</h3><p>Redis的核心配置文件 redis.conf 在安装根目录下，默认包含 2000 多行。 这些内容根据功能被划分为了很多部分。下面将一些重要部分 进行介绍。</p><h4 id="2-4-1-基础说明"><a href="#2-4-1-基础说明" class="headerlink" title="2.4.1 基础说明"></a>2.4.1 基础说明</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042056390.png" alt="image-20240804205653327"></p><p>这部分主要是给出一些说明，包含三部分意思：</p><ul><li>第 1- 6 行用于说明，如果要启动 Redis ，需要指出配置文件的路径。</li><li>第 8 -16 行用于说明当前配置文件中可以使用的的容量单位及意义。</li><li>第 18 行用于说明这些容量单位没有大小写之分。</li></ul><h4 id="2-4-2-includes"><a href="#2-4-2-includes" class="headerlink" title="2.4.2 includes"></a>2.4.2 includes</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042058267.png" alt="image-20240804205800200"></p><p>指定要在当前配置文件中包含的配置文件。 这样做的目的主要是便于配置信息管理：可以将不同场景的配置都进行单独定义，然后在当前核心配置文件中根据不同场景选择包含进不同的配置文件。</p><h4 id="2-4-3-modules"><a href="#2-4-3-modules" class="headerlink" title="2.4.3 modules"></a>2.4.3 modules</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042058694.png"></p><p>Redis 配置文件中可以通过加载不同的第三方模块，来增强、扩展 Redis 的功能。</p><h4 id="2-4-4-network"><a href="#2-4-4-network" class="headerlink" title="2.4.4 network"></a>2.4.4 network</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042059438.png" alt="image-20240804205905389"></p><p>Network配置模块是比较重要的部分，主要进行网络相关的配置。其中较重要的有：</p><p><strong>（1） bind</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042100561.png" alt="image-20240804210024508"></p><p>指定可以访问当前 Redis 服务的客户端 IP ，默认只允许本地访问，即当前 Redis 自己访问自己。为了使所有其它客户端都可访问，一般要将其注释掉。</p><p><strong>（2） protected mode</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042100157.png"></p><p>默认保护模式是开启的。 其只允许本机的客户端访问，即只允许自己访问自己。但生产中应该关闭，以确保其它客户端可以连接 Redis 。</p><p><strong>（3） port</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042101572.png" alt="image-20240804210117523"></p><p>Redis 监听的连接端口号，默认 6379 。</p><p><strong>（4） tcp-backlog</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042101389.png" alt="image-20240804210131338"></p><p>tcp-backlog 是一个 <strong>TCP 连接的队列</strong>，其主要用于解决<strong>高并发场景下客户端 慢连接 问题</strong>。这里设置的值就是这个队列的长度。该队列与 TCP 连接的三次握手有关。不同的 Linux 内核，backlog 队列中存放的元素（客户端连接）类型是不同的。</p><ol><li>Linux 内核 2.2 版本之前 ，该队列中存放的是已完成了第一次握手的所有客户端连接其中就包含已完成三次握手的客户端连接。当然，此时的 backlog 队列中的连接也具有两种状态：未完成三次握手的连接状态为 SYN_RECEIVED ，已完成三次握手的连接状态为 ESTABLISHED 。只有 ESTABLISHED 状态的连接才会被 Redis 处理。</li><li>Linux 内核 2.2 版本之后 TCP 系统中维护了两个队列： SYN_RECEIVED 队列与 ESTABLISHED队列。 <strong>SYN_RECEIVED 队列中存放的是未完成三次握手的连接</strong>， <strong>ESTABLISHED 队列中存放的是已完成三次握手的连接</strong>。此时的 backlog 就是 ESTABLISHED 队列。</li></ol><p>查看Linux 内核版本：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042104709.png" alt="image-20240804210417652"></p><p>TCP 中的 backlog 队列的长度在 Linux 中由内核参 数 <strong>somaxconn</strong> 来决定。所以，在 Redis中该队列的长度由 <strong>Redis 配置文件设置</strong>与 <strong>somaxconn 来共同决定</strong>：取它们中的最小值。查看当前 Linux 内核中 somaxconn 的值。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042105364.png" alt="image-20240804210511316"></p><p>生产环境下（特别是高并发场景下）， backlog 的值最好要大一些，否则可能会影响系统性能。<br>修改 &#x2F;etc&#x2F;sysctl.conf 文件，在文件最后添加如下内容：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042106244.png" alt="image-20240804210605186"></p><p>修改过后可以重启虚拟机，也可以通过执行如下命令来使新的修改生效。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042106189.png" alt="image-20240804210621143"></p><p><strong>（5） timeout</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042106409.png" alt="image-20240804210634358"></p><p>空闲超时。当客户端与 Redis 间的空闲时间超过该时长后，连接自动断开。单位秒。默认值为 0 ，表示永远不超时。</p><p><strong>（6） tcp keepalive</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042108623.png" alt="image-20240804210804576"></p><p>该配置主要用于设置Redis 检测与其连接的所有客户端的存活性时间间隔，单位秒。一般是在空闲超时 timeout 设置为 0 时进行配置。</p><h4 id="2-4-5-general"><a href="#2-4-5-general" class="headerlink" title="2.4.5 general"></a>2.4.5 general</h4><p><strong>（1） daemonize</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042108691.png" alt="image-20240804210841640"></p><p>该配置可以控制 Redis 启动是否采用守护进程方式，即是否是后台启动。 yes 是采用后台启动。</p><p><strong>（2） pidfile</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042109872.png" alt="image-20240804210937826"></p><p>该配置用于指定 Redis 运行时 pid 写入的文件，无论 Redis 是否采用守护进程方式启动，pid 都会写入到该配置的文件。</p><p>注意，如果没有配置 pid 文件，不同的启动方式， pid 文件的产生效果是不同的：</p><ul><li>采用守护进程方式启动（后台启动， daemonize 为 yes pid 文件为 &#x2F;var&#x2F;run&#x2F;redis.pid 。</li><li>采用前台启动（ daemonize 为 no ）：不生产 pid 文件</li></ul><p><strong>（3） loglevel</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042110288.png" alt="image-20240804211039240"></p><p>配置日志的级别。 Redis 中共有四个级别，由低到高依次是：</p><ul><li>debug ：可以获取到很多的信息，一般在开发和测试时使用。</li><li>verbose ：可以获取到很多不太有用的信息，但不像 debug 级别那么多。</li><li>notice ：可以获取到在生产中想获取到的适当多的信息，默认级别。</li><li>warning ：只记录非常重要 关键的信息。</li></ul><p><strong>（4） logfile</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042111775.png" alt="image-20240804211140725"></p><p>指定日志文件。如果设置为空串，则强制将日志记录到标准输出设备（显示器）。如果使用的是守护进程启动方式，设置为空串，则意味着会将日志发送到设备 &#x2F;dev&#x2F;null （空设备) 。</p><p><strong>（5） databases</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042112808.png" alt="image-20240804211228759"></p><p>设置数据库的数量。默认数据库是0 号数据库。 可以使用 select dbid 在每个连接的基础上选择一个不同的数据库，其中 dbid 是介于 0 和 ‘ 1’ 之间的数字</p><h4 id="2-4-6-security"><a href="#2-4-6-security" class="headerlink" title="2.4.6 security"></a>2.4.6 security</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042113081.png"></p><p>用户设置 ACL 权限、 Redis 访问密码相关配置。该模块中最常用的就是 requirepass 属性。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042113698.png" alt="image-20240804211326644"></p><p>设置客户端访问密码。注释掉后则没有密码。</p><h4 id="2-4-7-clients"><a href="#2-4-7-clients" class="headerlink" title="2.4.7 clients"></a>2.4.7 clients</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042113695.png" alt="image-20240804211336637"></p><p>该模块用于设置与客户端相关的属性，其中仅包含一个属性 maxclients 。<br>maxclients用于设置 Redis 可并发处理的客户端连接数量， 默认 值为 10000 。如果达到了该最大连接数，则会<strong>拒绝再来的新连接</strong>，并返回一个异常信息：已达到最大连接数。<br>注意，该值不能超过 Linux 系统支持的可打开的文件描述符最大数量阈值。查看该阈值的方式如下。修改该值，可以通过修改 &#x2F;etc&#x2F;secutiry&#x2F;limits.conf 文件（自己查）。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202408042114072.png" alt="image-20240804211430023"></p>]]></content>
    
    
    <summary type="html">Redis学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="Redis" scheme="https://bennettgao.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot基础</title>
    <link href="https://bennettgao.github.io/2024/07/29/SpringBootWeb%E5%85%A5%E9%97%A8/"/>
    <id>https://bennettgao.github.io/2024/07/29/SpringBootWeb%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-29T13:06:49.161Z</published>
    <updated>2024-08-06T09:48:00.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot基础"><a href="#SpringBoot基础" class="headerlink" title="SpringBoot基础"></a>SpringBoot基础</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><blockquote><ol><li><p>SpringBootWeb入门</p></li><li><p>HTTP协议</p></li><li><p>Web服务器-Tomcat</p></li></ol></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>![image-20221130095316032](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221130095316032.png)</p><p>下面我们将进入SpringBoot基础阶段的学习。</p><p>在没有正式的学习SpringBoot之前，我们要先来了解下什么是Spring。</p><p>我们可以打开Spring的官网(<a href="https://spring.io)，去看一下Spring的简介：Spring">https://spring.io)，去看一下Spring的简介：Spring</a> makes Java simple。</p><p>![](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20220617222738668.png)</p><p>Spring的官方提供很多开源的项目，我们可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107501.png"></p><p>Spring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套spring家族的技术，来解决对应领域的问题，那我们称这一套技术为<strong>spring全家桶</strong>。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107531.png"></p><p>而Spring家族旗下这么多的技术，最基础、最核心的是 SpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p><p>![](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20220617224427947.png)</p><p>而如果我们在项目中，直接基于SpringFramework进行开发，存在两个问题：配置繁琐、入门难度大。 </p><p>![](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20220823185227296.png)</p><p>所以基于此呢，spring官方推荐我们从另外一个项目开始学习，那就是目前最火爆的SpringBoot。 </p><p>通过springboot就可以快速的帮我们构建应用程序，所以springboot呢，最大的特点有两个 ：</p><ul><li>简化配置</li><li>快速开发</li></ul><p><strong>Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。</strong></p><p>接下来，我们就直接通过一个SpringBoot的web入门程序，让大家快速感受一下，基于SpringBoot进行Web开发的便捷性。</p><h2 id="1-SpringBootWeb快速入门"><a href="#1-SpringBootWeb快速入门" class="headerlink" title="1. SpringBootWeb快速入门"></a>1. SpringBootWeb快速入门</h2><h3 id="1-1-需求"><a href="#1-1-需求" class="headerlink" title="1.1 需求"></a>1.1 需求</h3><p>需求：基于SpringBoot的方式开发一个web应用，浏览器发起请求&#x2F;hello后，给浏览器返回字符串 “Hello World ~”。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107539.png"></p><h3 id="1-2-开发步骤"><a href="#1-2-开发步骤" class="headerlink" title="1.2 开发步骤"></a>1.2 开发步骤</h3><p>第1步：创建SpringBoot工程项目</p><p>第2步：定义HelloController类，添加方法hello，并添加注解</p><p>第3步：测试运行</p><h4 id="1-2-1-创建SpringBoot工程（需要联网）"><a href="#1-2-1-创建SpringBoot工程（需要联网）" class="headerlink" title="1.2.1 创建SpringBoot工程（需要联网）"></a>1.2.1 创建SpringBoot工程（需要联网）</h4><p>基于Spring官方骨架，创建SpringBoot工程。</p><img src="D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221201184702136.png" alt="image-20221201184702136" style="zoom:80%;" /><p>基本信息描述完毕之后，勾选web开发相关依赖。</p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107553.png" alt="image-20221201184850248" style="zoom:80%;" /><p>点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：</p><ul><li>&#x3D;&#x3D;注意：在联网创建过程中，会下载相关资源(请耐心等待)&#x3D;&#x3D;</li></ul><p>![image-20221201185910596](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221201185910596.png) </p><h4 id="1-2-2-定义请求处理类"><a href="#1-2-2-定义请求处理类" class="headerlink" title="1.2.2 定义请求处理类"></a>1.2.2 定义请求处理类</h4><p>在com.itheima这个包下创建一个子包controller</p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107616.png" alt="image-20221201190541295" style="zoom:80%;" /><p>然后在controller包下新建一个类：HelloController</p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107663.png" alt="image-20221201190825439" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="1-2-3-运行测试"><a href="#1-2-3-运行测试" class="headerlink" title="1.2.3 运行测试"></a>1.2.3 运行测试</h4><p>运行SpringBoot自动生成的引导类</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107375.png" alt="image-20221201191028124"> </p><p>![image-20221201191348924](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221201191348924.png) </p><p>打开浏览器，输入 <code>http://localhost:8080/hello</code></p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107418.png" style="zoom:80%;" /><h3 id="1-3-Web分析"><a href="#1-3-Web分析" class="headerlink" title="1.3 Web分析"></a>1.3 Web分析</h3><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107461.png" alt="image-20221201224603497"></p><p>浏览器：</p><ul><li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p><ul><li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p><blockquote><p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p></blockquote></li><li><p>通过端口号8080找到计算机上运行的程序</p><blockquote><p><code>localhost:8080</code>  , 意思是在本地计算机中找到正在运行的8080端口的程序</p></blockquote></li><li><p>&#x2F;hello是请求资源位置</p><ul><li>资源：对计算机而言资源就是数据<ul><li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li></ul></li></ul><blockquote><p><code>localhost:8080/hello</code> ，意思是向本地计算机中的8080端口程序，获取资源位置是&#x2F;hello的数据</p><ul><li>8080端口程序，在服务器找&#x2F;hello位置的资源数据，发给浏览器</li></ul></blockquote></li></ul></li></ul><p>服务器：（可以理解为ServerSocket）</p><ul><li>接收到浏览器发送的信息（如：&#x2F;hello）</li><li>在服务器上找到&#x2F;hello的资源</li><li>把资源发送给浏览器</li></ul><blockquote><p>我们在JavaSE阶段学习网络编程时，有讲过网络三要素：</p><ul><li>IP  ：网络中计算机的唯一标识</li><li>端口 ：计算机中运行程序的唯一标识</li><li>协议 ：网络中计算机之间交互的规则</li></ul><p><strong>问题：浏览器和服务器两端进行数据交互，使用什么协议？</strong></p><p><strong>答案：http协议</strong></p></blockquote><h2 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. HTTP协议</h2><h3 id="2-1-HTTP-概述"><a href="#2-1-HTTP-概述" class="headerlink" title="2.1 HTTP-概述"></a>2.1 HTTP-概述</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107505.png"></p><p>HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p><ul><li>http是互联网上应用最为广泛的一种网络协议 </li><li>http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</li></ul><p>如果想知道http协议的数据传输格式有哪些，可以打开浏览器，点击<code>F12</code>打开开发者工具，点击<code>Network</code>来查看</p><p>![image-20221202105735230](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202105735230.png)</p><p>浏览器向服务器进行请求时：</p><ul><li>服务器按照固定的格式进行解析</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107400.png" alt="image-20221202111044434"></p><p>服务器向浏览器进行响应时：</p><ul><li>浏览器按照固定的格式进行解析</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107410.png" alt="image-20221202111307819"></p><p><strong>所以，我们学习HTTP主要就是学习请求和响应数据的具体格式内容。</strong></p><h4 id="2-2-2-特点"><a href="#2-2-2-特点" class="headerlink" title="2.2.2 特点"></a>2.2.2 特点</h4><p>我们刚才初步认识了HTTP协议，那么我们在看看HTTP协议有哪些特点：</p><ul><li><p>**基于TCP协议: **   面向连接，安全</p><blockquote><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p></blockquote></li><li><p><strong>基于请求-响应模型:</strong>   一次请求对应一次响应（先请求后响应）</p><blockquote><p>请求和响应是一一对应关系，没有请求，就没有响应</p></blockquote></li><li><p><strong>HTTP协议是无状态协议:</strong>  对于数据没有记忆能力。每次请求-响应都是独立的</p><blockquote><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p><ul><li>缺点:  多次请求间不能共享数据</li><li>优点:  速度快</li></ul><p>请求之间无法共享数据会引发的问题：</p><ul><li>如：京东购物。加入购物车和去购物车结算是两次请求</li><li>由于HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面课程中会讲到。</p></blockquote><p>刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?</p></li></ul><h3 id="2-2-HTTP-请求协议"><a href="#2-2-HTTP-请求协议" class="headerlink" title="2.2 HTTP-请求协议"></a>2.2 HTTP-请求协议</h3><p>浏览器和服务器是按照HTTP协议进行数据通信的。</p><p>HTTP协议又分为：请求协议和响应协议</p><ul><li>请求协议：浏览器将数据以请求格式发送到服务器<ul><li>包括：<strong>请求行</strong>、<strong>请求头</strong> 、<strong>请求体</strong></li></ul></li><li>响应协议：服务器将数据以响应格式返回给浏览器<ul><li>包括：<strong>响应行</strong> 、<strong>响应头</strong> 、<strong>响应体</strong></li></ul></li></ul><p>在HTTP1.1版本中，浏览器访问服务器的几种方式： </p><table><thead><tr><th align="center">请求方式</th><th align="left">请求说明</th></tr></thead><tbody><tr><td align="center"><strong>GET</strong></td><td align="left">获取资源。<br/>向特定的资源发出请求。例：<a href="http://www.baidu.com/s?wd=itheima">http://www.baidu.com/s?wd=itheima</a></td></tr><tr><td align="center"><strong>POST</strong></td><td align="left">传输实体主体。<br/>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td></tr><tr><td align="center">OPTIONS</td><td align="left">返回服务器针对特定资源所支持的HTTP请求方式。<br/>因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法，例如：DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。</td></tr><tr><td align="center">HEAD</td><td align="left">获得报文首部。<br/>HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。通常用于确认URI的有效性及资源更新时间等。</td></tr><tr><td align="center">PUT</td><td align="left">传输文件。<br/>PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。</td></tr><tr><td align="center">DELETE</td><td align="left">删除文件。<br/>请求服务器删除Request-URI所标识的资源</td></tr><tr><td align="center">TRACE</td><td align="left">追踪路径。<br/>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td align="center">CONNECT</td><td align="left">要求用隧道协议连接代理。<br/>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p>在我们实际应用中常用的也就是 ：<strong>GET、POST</strong></p><p><strong>GET方式的请求协议：</strong></p><p>![](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20220823200708026.png) </p><ul><li><p>请求行 ：HTTP请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）</p><ul><li>请求方式：GET  </li><li>资源路径：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1<ul><li>请求路径：&#x2F;brand&#x2F;findAll</li><li>请求参数：name&#x3D;OPPO&amp;status&#x3D;1<ul><li>请求参数是以key&#x3D;value形式出现</li><li>多个请求参数之间使用<code>&amp;</code>连接</li></ul></li><li>请求路径和请求参数之间使用<code>?</code>连接</li></ul><p>  </p></li><li>协议&#x2F;版本：HTTP&#x2F;1.1</li></ul></li><li><p>请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key: value形式 </p><ul><li>http是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了</li></ul><p>常见的HTTP请求头有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Host: 表示请求的主机名</span><br><span class="line"></span><br><span class="line">User-Agent: 浏览器版本。 例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79 ，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko</span><br><span class="line"></span><br><span class="line">Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；</span><br><span class="line"></span><br><span class="line">Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</span><br><span class="line"></span><br><span class="line">Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</span><br><span class="line"></span><br><span class="line">Content-Type：请求主体的数据类型</span><br><span class="line"></span><br><span class="line">Content-Length：数据主体的大小（单位：字节）</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>举例说明：服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p><p>比如:</p><ul><li>不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果</li><li>服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题）</li></ul></blockquote><ul><li>请求体 ：存储请求参数<ul><li>GET请求的请求参数在请求行中，故不需要设置请求体</li></ul></li></ul><p><strong>POST方式的请求协议：</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107490.png"></p><ul><li>请求行(以上图中红色部分)：包含请求方式、资源路径、协议&#x2F;版本<ul><li>请求方式：POST</li><li>资源路径：&#x2F;brand</li><li>协议&#x2F;版本：HTTP&#x2F;1.1</li></ul></li><li>请求头(以上图中黄色部分)   </li><li>请求体(以上图中绿色部分) ：存储请求参数 <ul><li>请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束）</li></ul></li></ul><p>GET请求和POST请求的区别：</p><table><thead><tr><th>区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td>请求参数</td><td>请求参数在请求行中。<br/>例：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1</td><td>请求参数在请求体中</td></tr><tr><td>请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td>安全性</td><td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td><td>安全性相对高</td></tr></tbody></table><h3 id="2-3-HTTP-响应协议"><a href="#2-3-HTTP-响应协议" class="headerlink" title="2.3 HTTP-响应协议"></a>2.3 HTTP-响应协议</h3><h4 id="2-3-1-格式介绍"><a href="#2-3-1-格式介绍" class="headerlink" title="2.3.1 格式介绍"></a>2.3.1 格式介绍</h4><p>与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong> 、<strong>响应体</strong> </p><p>![](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20220823202344149.png) </p><ul><li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p><ul><li>协议&#x2F;版本：HTTP&#x2F;1.1</li><li>响应状态码：200</li><li>状态码描述：OK</li></ul></li><li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p><ul><li>http是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li></ul><p>常见的HTTP响应头有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span><br><span class="line"></span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line"></span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip ；</span><br><span class="line"></span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ;</span><br><span class="line"></span><br><span class="line">Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span><br></pre></td></tr></table></figure></li></ul><ul><li>响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据<ul><li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li></ul></li></ul><h4 id="2-3-2-响应状态码"><a href="#2-3-2-响应状态码" class="headerlink" title="2.3.2 响应状态码"></a>2.3.2 响应状态码</h4><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong> — 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td></tr><tr><td>2xx</td><td><strong>成功</strong> — 表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong> — 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong> — 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong> — 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>参考: 资料&#x2F;SpringbootWeb&#x2F;响应状态码.md</p><p>关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握：</p><ul><li>200    ok   客户端请求成功</li><li>404  Not Found  请求资源不存在</li><li>500  Internal Server Error  服务端发生不可预期的错误</li></ul><h3 id="2-4-HTTP-协议解析"><a href="#2-4-HTTP-协议解析" class="headerlink" title="2.4 HTTP-协议解析"></a>2.4 HTTP-协议解析</h3><p>将资料中准备好的Demo工程，导入到我们的IDEA中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是<code>ServerSocket</code>和<code>Socket</code></p><blockquote><p>&#x3D;&#x3D;说明：以下代码大家不需要自己写，我们主要是通过代码，让大家了解到服务器针对HTTP协议的解析机制&#x3D;&#x3D;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义web服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getInputStream();</span><br><span class="line">             <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 读取HTTP请求:</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">requestOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (first.startsWith(<span class="string">&quot;GET / HTTP/1.&quot;</span>)) &#123;</span><br><span class="line">            requestOk = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (header.isEmpty()) &#123; <span class="comment">// 读取到空行时, HTTP Header读取完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(header);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(requestOk ? <span class="string">&quot;Response OK&quot;</span> : <span class="string">&quot;Response Error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!requestOk) &#123;<span class="comment">// 发送错误响应:</span></span><br><span class="line">            writer.write(<span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Length: 0\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 发送成功响应:</span></span><br><span class="line">            <span class="comment">//读取html文件，转换为字符串</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Server.class.getClassLoader().getResourceAsStream(<span class="string">&quot;html/a.html&quot;</span>);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> data.toString().getBytes(StandardCharsets.UTF_8).length;</span><br><span class="line"></span><br><span class="line">            writer.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Connection: keep-alive\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Length: &quot;</span> + length + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 空行标识Header和Body的分隔</span></span><br><span class="line">            writer.write(data.toString());</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动ServerSocket程序：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107572.png" alt="image-20221202170430928"></p><p>浏览器输入：<code>http://localhost:8080</code>  就会访问到ServerSocket程序 </p><ul><li>ServerSocket程序，会读取服务器上<code>html/a.html</code>文件，并把文件数据发送给浏览器</li><li>浏览器接收到a.html文件中的数据后进行解析，显示以下内容</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107046.png" alt="image-20221202171204705"> </p><p>现在大家知道了服务器是可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，而在开发中真正用到的Web服务器，我们不会自己写的，都是使用目前比较流行的web服务器。如：<strong>Tomcat</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107099.png"> </p><h2 id="3-WEB服务器-Tomcat"><a href="#3-WEB服务器-Tomcat" class="headerlink" title="3. WEB服务器-Tomcat"></a>3. WEB服务器-Tomcat</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><h4 id="3-1-1-服务器概述"><a href="#3-1-1-服务器概述" class="headerlink" title="3.1.1 服务器概述"></a>3.1.1 服务器概述</h4><p><strong>服务器硬件</strong></p><ul><li>指的也是计算机，只不过服务器要比我们日常使用的计算机大很多。</li></ul><p>![image-20221202173148317](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202173148317.png) </p><p>服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。</p><p>服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。</p><p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>服务器只是一台设备，必须安装服务器软件才能提供相应的服务。</p><p><strong>服务器软件</strong></p><p>服务器软件：基于ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107398.png" alt="1530625192392"></p><h4 id="3-1-2-Web服务器"><a href="#3-1-2-Web服务器" class="headerlink" title="3.1.2 Web服务器"></a>3.1.2 Web服务器</h4><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p>![](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20220824233614686.png)</p><p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><p>第1步：准备静态资源</p><ul><li>在提供的资料中找到静态资源文件</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107494.png" alt="image-20221202180119859"> </p><p>第2步：下载安装Web服务器软件</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107740.png" alt="image-20221202181110555"></p><p>第3步：将静态资源部署到Web服务器上</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107918.png" alt="image-20221202180805686"></p><p>第4步：启动Web服务器使用浏览器访问对应的资源</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107080.png" alt="image-20221202181346327"></p><p>浏览器输入：<code>http://localhost:8080/demo/index.html</code></p><p>![image-20221202181651469](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202181651469.png)</p><p>上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107217.png" alt="image-20220824233728524"> </p><p>Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:</p><ol><li><p>简介：初步认识下Tomcat</p></li><li><p>基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作</p></li><li><p>IDEA中如何创建Maven Web项目</p></li><li><p>IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式</p></li></ol><p>首选我们来认识下Tomcat。</p><h4 id="3-1-3-Tomcat"><a href="#3-1-3-Tomcat" class="headerlink" title="3.1.3 Tomcat"></a>3.1.3 Tomcat</h4><p>Tomcat服务器软件是一个免费的开源的web应用服务器。是Apache软件基金会的一个核心项目。由Apache，Sun和其他一些公司及个人共同开发而成。</p><p>由于Tomcat只支持Servlet&#x2F;JSP少量JavaEE规范，所以是一个开源免费的轻量级Web服务器。</p><blockquote><p>JavaEE规范：   JavaEE &#x3D;&gt; Java Enterprise Edition(Java企业版)</p><p>avaEE规范就是指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF</p></blockquote><p>因为Tomcat支持Servlet&#x2F;JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。</p><p>Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> </p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107251.png" alt="image-20220824233903517"> </p><h3 id="3-2-基本使用"><a href="#3-2-基本使用" class="headerlink" title="3.2 基本使用"></a>3.2 基本使用</h3><h4 id="3-2-1-下载"><a href="#3-2-1-下载" class="headerlink" title="3.2.1 下载"></a>3.2.1 下载</h4><p>直接从官方网站下载：<a href="https://tomcat.apache.org/download-90.cgi">https://tomcat.apache.org/download-90.cgi</a></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107578.png"></p><blockquote><p>Tomcat软件类型说明：</p><ul><li>tar.gz文件，是linux和mac操作系统下的压缩版本</li><li>zip文件，是window操作系统下压缩版本（我们选择zip文件）</li></ul></blockquote><p>大家可以自行下载，也可以直接使用资料中已经下载好的资源，</p><p>Tomcat的软件程序  ：&#x2F;资料&#x2F;SpringbootWeb&#x2F;apache-tomcat-9.0.27-windows-x64.zip</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107606.png"> </p><h4 id="3-2-2-安装与卸载"><a href="#3-2-2-安装与卸载" class="headerlink" title="3.2.2 安装与卸载"></a>3.2.2 安装与卸载</h4><p><strong>安装:</strong> Tomcat是绿色版，直接解压即安装</p><blockquote><p>在E盘的develop目录下，将<code>apache-tomcat-9.0.27-windows-x64.zip</code>进行解压缩，会得到一个<code>apache-tomcat-9.0.27</code>的目录，Tomcat就已经安装成功。</p></blockquote><p>![image-20221202184545321](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202184545321.png)</p><p>&#x3D;&#x3D;注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。&#x3D;&#x3D;</p><p>打开<code>apache-tomcat-9.0.27</code>目录就能看到如下目录结构，每个目录中包含的内容需要认识下</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107930.png">  </p><p>bin：目录下有两类文件，一种是以<code>.bat</code>结尾的，是Windows系统的可执行文件，一种是以<code>.sh</code>结尾的，是Linux系统的可执行文件。</p><p>webapps：就是以后项目部署的目录</p><p><strong>卸载：</strong>卸载比较简单，可以直接删除目录即可</p><h4 id="3-2-3-启动与关闭"><a href="#3-2-3-启动与关闭" class="headerlink" title="3.2.3 启动与关闭"></a>3.2.3 启动与关闭</h4><p><strong>启动Tomcat</strong> </p><ul><li>双击tomcat解压目录&#x2F;bin&#x2F;<strong>startup.bat</strong>文件即可启动tomcat</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107054.png" alt="image-20221202183201663"></p><p>&#x3D;&#x3D;注意: tomcat服务器启动后,黑窗口不会关闭,只要黑窗口不关闭,就证明tomcat服务器正在运行&#x3D;&#x3D;</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107097.png" alt="image-20221202183409304"></p><p>Tomcat的默认端口为8080，所以在浏览器的地址栏输入：<code>http://127.0.0.1:8080</code> 即可访问tomcat服务器</p><blockquote><p>127.0.0.1 也可以使用localhost代替。如：<code>http://localhost:8080</code></p></blockquote><p>![image-20221202183550682](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202183550682.png)</p><ul><li>能看到以上图片中Apache Tomcat的内容就说明Tomcat已经启动成功</li></ul><p>&#x3D;&#x3D;注意事项&#x3D;&#x3D; ：Tomcat启动的过程中，遇到控制台有中文乱码时，可以通常修改conf&#x2F;logging.prooperties文件解决</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107517.png" alt="image-20220825083848086"> </p><p><strong>关闭:</strong>  关闭有三种方式 </p><p>1、强制关闭：直接x掉Tomcat窗口（不建议）</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107684.png" alt="image-20221202184753808"></p><p>2、正常关闭：bin\shutdown.bat</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107842.png" alt="image-20221202185103941"></p><p>3、正常关闭：在Tomcat启动窗口中按下 Ctrl+C</p><ul><li>说明：如果按下Ctrl+C没有反映，可以多按几次</li></ul><h4 id="3-2-4-常见问题"><a href="#3-2-4-常见问题" class="headerlink" title="3.2.4 常见问题"></a>3.2.4 常见问题</h4><p><strong>问题1：Tomcat启动时，窗口一闪而过</strong></p><ul><li>检查JAVA_HOME环境变量是否正确配置</li></ul><p>![image-20221202190033167](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202190033167.png)</p><p><strong>问题2：端口号冲突</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107078.png" alt="image-20220825084104447"></p><ul><li><p>发生问题的原因：Tomcat使用的端口被占用了。</p></li><li><p>解决方案：换Tomcat端口号</p><ul><li>要想修改Tomcat启动的端口号，需要修改 conf&#x2F;server.xml文件</li></ul></li></ul><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107456.png" alt="image-20220825084017185" style="zoom:80%;" /> <blockquote><p>注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p></blockquote><h3 id="3-3-入门程序解析"><a href="#3-3-入门程序解析" class="headerlink" title="3.3 入门程序解析"></a>3.3 入门程序解析</h3><p>关于web开发的基础知识，我们可以告一段落了。下面呢，我们在基于今天的核心技术点SpringBoot快速入门案例进行分析。</p><h4 id="3-3-1-Spring官方骨架"><a href="#3-3-1-Spring官方骨架" class="headerlink" title="3.3.1 Spring官方骨架"></a>3.3.1 Spring官方骨架</h4><p>之前我们创建的SpringBoot入门案例，是基于Spring官方提供的骨架实现的。</p><p>Spring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107603.png" alt="image-20221202195646621"></p><p>我们可以通过访问：<a href="https://start.spring.io/">https://start.spring.io/</a> ，进入到官方骨架页面</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107645.png" alt="image-20221202201623424"></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107695.png" alt="image-20221202200356398"></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107826.png" alt="image-20221202200547676"></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107077.png" alt="image-20221202200708988"></p><p>Spring官方生成的SpringBoot项目，怎么使用呢？</p><ul><li>解压缩后，就会得到一个SpringBoot项目工程</li></ul><p>![image-20221202201042109](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202201042109.png)</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107399.png" alt="image-20221202201221136"></p><p>打开pom.xml文件，我们可以看到springboot项目中引入了web依赖和test依赖</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107430.png" alt="image-20221202201826364"></p><blockquote><p><strong>结论：不论使用IDEA创建SpringBoot项目，还是直接在官方网站利用骨架生成SpringBoot项目，项目的结构和pom.xml文件中内容是相似的。</strong></p></blockquote><h4 id="3-3-2-起步依赖"><a href="#3-3-2-起步依赖" class="headerlink" title="3.3.2 起步依赖"></a>3.3.2 起步依赖</h4><p>在我们之前讲解的SpringBoot快速入门案例中，同样也引用了：web依赖和test依赖</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107612.png" alt="image-20221202202305118"></p><p>spring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：起步依赖</p><p>而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为起步依赖。</p><p>起步依赖有什么特殊之处呢，这里我们以入门案例中引入的起步依赖做为讲解：</p><ul><li>spring-boot-starter-web：包含了web应用开发所需要的常见依赖</li><li>spring-boot-starter-test：包含了单元测试所需要的常见依赖</li></ul><blockquote><p><strong>spring-boot-starter-web</strong>内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入 <code>spring-boot-starter-web</code> 依赖就可以实现Web开发的需要的功能</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107953.png" alt="image-20221202204013113"></p></blockquote><p>Spring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。</p><p>官方地址：<a href="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters</a></p><p>![image-20221202204536647](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202204536647.png)</p><p>每一个起步依赖，都用于开发一个特定的功能。</p><blockquote><p>举例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖。</p></blockquote><h4 id="3-3-2-SpringBoot父工程"><a href="#3-3-2-SpringBoot父工程" class="headerlink" title="3.3.2 SpringBoot父工程"></a>3.3.2 SpringBoot父工程</h4><p>在我们之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107095.png" alt="image-20221202205103486"></p><p>为什么没有指定<version>版本号，可以正常使用呢？</p><ul><li>因为每一个SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。</li></ul><p>![image-20221202205318778](D:\Desktop\Java学习\黑马Javaweb文档\day04-Maven-SpringBootWeb入门\02. SpringBootWeb入门\assets\image-20221202205318778.png)</p><h4 id="3-3-3-内嵌Tomcat"><a href="#3-3-3-内嵌Tomcat" class="headerlink" title="3.3.3 内嵌Tomcat"></a>3.3.3 内嵌Tomcat</h4><p>问题：为什么我们之前书写的SpringBoot入门程序中，并没有把程序部署到Tomcat的webapps目录下，也可以运行呢？</p><p>原因呢，是因为在我们的SpringBoot中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器。</p><p>我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107302.png"> </p><p>当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407292107555.png" alt="image-20220825195359993"></p>]]></content>
    
    
    <summary type="html">java自用学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="java" scheme="https://bennettgao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>docker部署mysql数据库数据恢复</title>
    <link href="https://bennettgao.github.io/2024/07/12/docker%E9%83%A8%E7%BD%B2%E7%9A%84mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    <id>https://bennettgao.github.io/2024/07/12/docker%E9%83%A8%E7%BD%B2%E7%9A%84mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/</id>
    <published>2024-07-12T12:56:14.020Z</published>
    <updated>2024-08-06T09:50:02.279Z</updated>
    
    <content type="html"><![CDATA[<p>接博客上文</p><p><a href="http://t.csdnimg.cn/ZEz7M%EF%BC%8C%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E6%8C%82%E8%BD%BD%E7%9A%84my.cnf%E6%96%87%E4%BB%B6%E5%90%8E%E8%BF%9C%E7%A8%8B%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E4%B8%8A%E4%BA%86docker%E9%83%A8%E7%BD%B2mysql%EF%BC%8C%E4%BD%86%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%99%E6%98%AF%E7%94%B1%E4%BA%8E%E5%88%9A%E5%88%9A%E4%BF%AE%E8%AF%A5%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%80%A0%E6%88%90%E7%9A%84">http://t.csdnimg.cn/ZEz7M，通过修改本地挂载的my.cnf文件后远程成功连接上了docker部署mysql，但是数据库无法进行修改、删除等操作，这是由于刚刚修该的配置文件造成的</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只有在紧急情况下才能设置</span><br><span class="line">innodb_force_recovery大于0，默认值是0，不进行强制恢复的正常启动。innodb_force_recovery一共有6个级别，举例说明：值为3时包括了1和2的功能，值越小越安全；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="关于innodb-force-recovery的值"><a href="#关于innodb-force-recovery的值" class="headerlink" title="关于innodb_force_recovery的值"></a>关于innodb_force_recovery的值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 (SRV_FORCE_IGNORE_CORRUPT)：即使服务器检测到损坏的页仍让它运行。试图使SELECT* FROM tbl_name跳过损坏的索引记录和页，这样有助于转储表。</span><br><span class="line">2 (SRV_FORCE_NO_BACKGROUND)：阻止主线程和任何清除线程的运行。如果崩溃会在清除操作中发生，该恢复值会阻止它。</span><br><span class="line">3 (SRV_FORCE_NO_TRX_UNDO)：不要在崩溃恢复后运行事务回滚。</span><br><span class="line">4 (SRV_FORCE_NO_IBUF_MERGE)：阻止插入缓冲合并操作。如果它们会导致崩溃，不要做这些。不计算表统计。这个值可以永久损坏数据文件。使用这个值后，准备号删除并重建所有辅助索引。在MySQL5.6.15中，设置InnoDB为只读。</span><br><span class="line">5 (SRV_FORCE_NO_UNDO_LOG_SCAN)：在启动数据库时不查看撤消日志：InnoDB将即使未完成的事务也作为已提交。这个值可以永久损坏数据文件。在MySQL5.6.15中，设置InnoDB为只读。</span><br><span class="line">6 (SRV_FORCE_NO_LOG_REDO)：不要通过恢复对重做日志进行前滚。这个值可能永久损坏数据文件。数据库页被留在一个陈旧的状态，这反过来又可能带给B-trees和其它数据库结构更多的损坏。</span><br></pre></td></tr></table></figure><p><strong>这时就需要重建恢复数据库了</strong>。</p><h5 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1.备份数据"></a>1.备份数据</h5><p>1.通过docker exec -it mysql容器名 bash 命令进入容器内部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql容器名 bash</span><br></pre></td></tr></table></figure><p>2.测试数据库是否可以连通：mysql -uroot -p密码<br>如果可以正常连通则退出可以备份数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p密码 --all-databases  &gt; /tmp/all_mysql_bak.sql </span><br><span class="line"></span><br><span class="line">（/tmp可以是其他目录， all_mysql_bak.sql文件就是所有的库数据和表数据，到时候回重新导入数据库中；）</span><br></pre></td></tr></table></figure><p>3.通过下面命令将刚刚备份好的数据拷贝到容器外</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  mysql:/tmp/all_mysql_bak.sql /root </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407122113558.png" alt="image-20240712211331326"></p><p>4.停止当前mysql 容器 ，然后将容器删除，<strong>如果本地挂载了数据卷，同时需要把数据卷删除，再新建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop mysql容器名</span><br><span class="line">docker rm  mysql容器名</span><br></pre></td></tr></table></figure><p>5.重新部署mysql容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建并运行新mysql容器，挂载本地目录</span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --restart=always</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>通过<strong>docker ps -a</strong> 命令查看发现已经部署成功。</p><p>6.将拷贝到容器外的备份数据在拷贝回容器内部，重新进入mysql容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master]docker cp  /root/all_mysql_bak.sql  mysql:/tmp/all_mysql_bak.sql （再拷贝到容器里面）</span><br><span class="line">#进入容器内部</span><br><span class="line">[root@master]docker exec -it mysql容器名 bash</span><br></pre></td></tr></table></figure><h5 id="2-数据恢复"><a href="#2-数据恢复" class="headerlink" title="2.数据恢复"></a>2.数据恢复</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">恢复数据：</span><br><span class="line">mysql -uroot -p密码 -e &quot;source \tmp\all_mysql_bak.sql&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407122127952.png" alt="image-20240712212749876"></p><p>查看数据库数据已经恢复。</p><p>以上是我解决docker部署mysql数据重建恢复的一种方式，欢迎积极讨论。</p>]]></content>
    
    
    <summary type="html">docker学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="docker" scheme="https://bennettgao.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker部署mysql数据库数据恢复问题（1）</title>
    <link href="https://bennettgao.github.io/2024/07/12/docker%E9%83%A8%E7%BD%B2%E7%9A%84mysql%E7%94%B1%E4%BA%8E%E7%AA%81%E7%84%B6%E6%96%AD%E7%94%B5%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%20Restarting%E7%8A%B6%E6%80%81/"/>
    <id>https://bennettgao.github.io/2024/07/12/docker%E9%83%A8%E7%BD%B2%E7%9A%84mysql%E7%94%B1%E4%BA%8E%E7%AA%81%E7%84%B6%E6%96%AD%E7%94%B5%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%20Restarting%E7%8A%B6%E6%80%81/</id>
    <published>2024-07-12T03:09:21.786Z</published>
    <updated>2024-08-06T09:50:25.931Z</updated>
    
    <content type="html"><![CDATA[<h5 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h5><p>在学习后端开发的过程中，今天突然发现自己在docker上部署的mysql突然连不上了，</p><p>通过docker ps  -a 命令查看发现mysql一直出于Restarting状态，重启了mysql容器，也还是没解决问题（下图中hm-mysql处于Restarting状态），于是小小的记录一下解决的方法：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407121437397.png" alt="image-20240712143733966"></p><h5 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h5><p>当Docker部署的MySQL一直处于Restarting状态时，这通常意味着MySQL容器在启动过程中遇到了问题。这可能是由于配置错误、端口冲突或其他原因导致的。为了解决这个问题，我们需要查看Docker日志以获取更多详细信息，并检查MySQL容器的配置。</p><p>通过&#x3D;&#x3D;docker logs -f hm-mysql&#x3D;&#x3D; 命令来查看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">The manual page at http://dev.mysql.com/doc/mysql/en/crashing.html contains</span><br><span class="line">information that should help you find out what is causing the crash.</span><br><span class="line">2024-07-12 10:59:02+08:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.4.0-1.el9 started.</span><br><span class="line">2024-07-12 10:59:02+08:00 [Note] [Entrypoint]: Switching to dedicated user &#x27;mysql&#x27;</span><br><span class="line">2024-07-12 10:59:02+08:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.4.0-1.el9 started.</span><br><span class="line">&#x27;/var/lib/mysql/mysql.sock&#x27; -&gt; &#x27;/var/run/mysqld/mysqld.sock&#x27;</span><br><span class="line">2024-07-12T02:59:03.120616Z 0 [System] [MY-015015] [Server] MySQL Server - start.</span><br><span class="line">2024-07-12T02:59:03.338524Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.4.0) starting as process 1</span><br><span class="line">2024-07-12T02:59:03.350277Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.</span><br><span class="line">2024-07-12T02:59:05.197985Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.</span><br><span class="line">2024-07-12T02:59:05.440020Z 0 [System] [MY-010229] [Server] Starting XA crash recovery...</span><br><span class="line">2024-07-12T02:59:05.467112Z 0 [System] [MY-010232] [Server] XA crash recovery finished.</span><br><span class="line">2024-07-12T02:59:05.507320Z 0 [ERROR] [MY-013183] [InnoDB] Assertion failure: trx0types.h:542:m_rsegs_n &lt; 2 thread 140279654897216</span><br><span class="line">InnoDB: We intentionally generate a memory trap.</span><br><span class="line">InnoDB: Submit a detailed bug report to http://bugs.mysql.com.</span><br><span class="line">InnoDB: If you get repeated assertion failures or crashes, even</span><br><span class="line">InnoDB: immediately after the mysqld startup, there may be</span><br><span class="line">InnoDB: corruption in the InnoDB tablespace. Please refer to</span><br><span class="line">InnoDB: http://dev.mysql.com/doc/refman/8.4/en/forcing-innodb-recovery.html</span><br><span class="line">InnoDB: about forcing recovery.</span><br><span class="line">2024-07-12T02:59:05Z UTC - mysqld got signal 6 ;</span><br><span class="line">Most likely, you have hit a bug, but this error can also be caused by malfunctioning hardware.</span><br><span class="line">BuildID[sha1]=353ae40c5329277f3033302aee25ef64367c8a66</span><br><span class="line">Thread pointer: 0x7f9570000df0</span><br><span class="line">Attempting backtrace. You can use the following information to find out</span><br><span class="line">where mysqld died. If you see no messages after this, something went</span><br><span class="line">terribly wrong...</span><br><span class="line">stack_bottom = 7f9566ffcb00 thread_stack 0x100000</span><br><span class="line">2024-07-12T02:59:05.600161Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.</span><br><span class="line">2024-07-12T02:59:05.600219Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel.</span><br><span class="line">2024-07-12T02:59:05.616580Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location &#x27;/var/run/mysqld&#x27; in the path is accessible to all OS users. Consider choosing a different directory.</span><br></pre></td></tr></table></figure><p>在日志中发现，日志显示了一个问题：</p><p>&#x3D;&#x3D;2024-07-12T02:59:05.507320Z 0 [ERROR] [MY-013183] [InnoDB] Assertion failure: trx0types.h:542:m_rsegs_n &lt; 2 thread 140279654897216&#x3D;&#x3D;</p><p>InnoDB 出现了断言失败。这可能是软件错误或者硬件故障导致的。</p><p>具体来说，在 InnoDB 中检测到一个违反断言的情况（trx0types.h:542:m_rsegs_n &lt; 2），并提示可能存在表空间损坏，建议参考相关文档进行强制恢复等操作。同时，还提到可能遇到了一个错误，也可能是硬件故障引起的。</p><p>于是上网开始查找资料</p><blockquote><p>文章地址：<a href="http://www.linuxeye.com/database/2830.html">http://www.linuxeye.com/database/2830.html</a> （MySQL意外断电，InnoDB数据库恢复）</p><p>分析日志后发现，数据库无法重启的原因是因为ibdata1文件损坏，重启后无法正常恢复。<br>现在我们就需要跳过恢复步骤，修改my.cnf文件，在my.cnf中的[mysqld]中添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_force_recovery = 6</span><br><span class="line">innodb_purge_threads = 0</span><br></pre></td></tr></table></figure><p>innodbforcerecovery可以设置为1-6,大的数字包含前面所有数字的影响。<br>\1. (SRVFORCEIGNORECORRUPT):忽略检查到的corrupt页。<br>\2. (SRVFORCENOBACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。<br>\3. (SRVFORCENOTRXUNDO):不执行事务回滚操作。<br>\4. (SRVFORCENOIBUFMERGE):不执行插入缓冲的合并操作。<br>\5. (SRVFORCENOUNDOLOGSCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。<br>\6. (SRVFORCENOLOG_REDO):不执行前滚的操作。</p></blockquote><p>于是我修改挂载在本地目录mysql&#x2F;conf下的hm.cnf配置文件，加上上述配置，重启mysql容器后，发现能远程连接上我的mysql容器了，问题解决。</p><p>但是后续mysql容器如果出现读写问题，容器数据库需要恢复可以参考下面这篇文章：</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>后来回想问题发生的原因，是我之前虚拟机没关闭的情况下就把电脑关机了，导致mysql容器意外断电导致了<code>Innodb</code>的文件损坏，出现了此次问题。</p>]]></content>
    
    
    <summary type="html">docker学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="docker" scheme="https://bennettgao.github.io/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud微服务学习（下）</title>
    <link href="https://bennettgao.github.io/2024/07/09/SpringCloud%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://bennettgao.github.io/2024/07/09/SpringCloud%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2024-07-09T09:28:01.333Z</published>
    <updated>2024-08-06T09:45:50.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud微服务学习（以黑马商城为例）"><a href="#SpringCloud微服务学习（以黑马商城为例）" class="headerlink" title="SpringCloud微服务学习（以黑马商城为例）"></a>SpringCloud微服务学习（以黑马商城为例）</h1><p>由于每个微服务都有不同的地址或端口，入口不同，相信大家在与前端联调的时候发现了一些问题：</p><ul><li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li><li>前端无法调用nacos，无法实时更新服务列表</li></ul><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p><ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul><p>不要着急，这些问题都可以在今天的学习中找到答案，我们会通过<strong>网关</strong>技术解决上述问题。今天的内容会分为3章：</p><ul><li>第一章：网关路由，解决前端请求入口的问题。</li><li>第二章：网关鉴权，解决统一登录校验和用户信息获取的问题。</li><li>第三章：统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li></ul><p>通过今天的学习你将掌握下列能力：</p><ul><li>会利用微服务网关做请求路由</li><li>会利用微服务网关做登录身份校验</li><li>会利用Nacos实现统一配置管理</li><li>会利用Nacos实现配置热更新</li></ul><p>好了，接下来我们就一起进入今天的学习吧。</p><h1 id="1-网关路由（重点）"><a href="#1-网关路由（重点）" class="headerlink" title="1.网关路由（重点）"></a>1.网关路由（重点）</h1><h2 id="1-1-认识网关"><a href="#1-1-认识网关" class="headerlink" title="1.1.认识网关"></a>1.1.认识网关</h2><p>什么是网关？</p><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由</strong>（判断选择服务的目的地址）和<strong>转发以及数据安全的校验</strong>。</p><p>更通俗的来讲，网关就像是以前园区传达室的大爷。</p><ul><li>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。</li><li>外面的人要传话或送信，要找大爷。大爷帮你带给目标人。</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091729358.jpeg" alt="img"></p><p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091744884.jpeg" alt="img"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>课堂中我们以SpringCloudGateway为例来讲解，官方网站：</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.9/reference/html/#gateway-request-predicates-factories">Spring Cloud 网关</a></p><h2 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2.快速入门"></a>1.2.快速入门</h2><p>接下来，我们先看下如何利用网关实现请求路由。由于<strong>网关本身也是一个独立的微服务</strong>，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h3 id="1-2-1-创建项目"><a href="#1-2-1-创建项目" class="headerlink" title="1.2.1.创建项目"></a>1.2.1.创建项目</h3><p>首先，我们要在hmall下创建一个新的module，命名为hm-gateway，作为网关微服务：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091756636.png" alt="img"></p><h3 id="1-2-2-引入依赖"><a href="#1-2-2-引入依赖" class="headerlink" title="1.2.2.引入依赖"></a>1.2.2.引入依赖</h3><p>在<code>hm-gateway</code>模块的<code>pom.xml</code>文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-启动类"><a href="#1-2-3-启动类" class="headerlink" title="1.2.3.启动类"></a>1.2.3.启动类</h3><p>在<code>hm-gateway</code>模块的<code>com.hmall.gateway</code>包下新建一个启动类：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091756698.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-配置路由"><a href="#1-2-4-配置路由" class="headerlink" title="1.2.4.配置路由"></a>1.2.4.配置路由</h3><p>接下来，在<code>hm-gateway</code>模块的<code>resources</code>目录新建一个<code>application.yaml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.170</span><span class="number">.10</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><h3 id="1-2-5-测试"><a href="#1-2-5-测试" class="headerlink" title="1.2.5.测试"></a>1.2.5.测试</h3><p>启动GatewayApplication，以 <a href="http://localhost:8080/">http://localhost:8080</a> 拼接微服务接口路径来测试。例如：</p><p><a href="http://localhost:8080/items/page?pageNo=1&pageSize=1">http://localhost:8080/items/page?pageNo=1&amp;pageSize=1</a></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091756759.png" alt="img"></p><p>此时，启动UserApplication、CartApplication，然后打开前端页面，发现相关功能都可以正常访问了：</p><h2 id="1-3-路由过滤"><a href="#1-3-路由过滤" class="headerlink" title="1.3.路由过滤"></a>1.3.路由过滤</h2><p>路由规则的定义语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>其中routes对应的类型如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091756914.png" alt="img"></p><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk1YWFiYTJjNjM2ZDk5Y2E0MDY4ZTI4OGI2MjVlYThfVWtGcWVwc1ZJN2xzNWhsc3hnNllhREFVdE9qb2NlaWFfVG9rZW46Q1Y4SmJGMVNrb0k0Q1l4YnAxQmM5anVqbm9mXzE3MjA1MTkwMTg6MTcyMDUyMjYxOF9WNA" alt="img"></p><p>四个属性含义如下：</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里我们重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">java自用学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="java" scheme="https://bennettgao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringCloud微服务学习（上）</title>
    <link href="https://bennettgao.github.io/2024/07/07/SpringCloud%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://bennettgao.github.io/2024/07/07/SpringCloud%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2024-07-07T08:26:52.603Z</published>
    <updated>2024-08-06T09:45:23.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud微服务学习（以黑马商城为例）"><a href="#SpringCloud微服务学习（以黑马商城为例）" class="headerlink" title="SpringCloud微服务学习（以黑马商城为例）"></a><strong>SpringCloud微服务学习（以黑马商城为例）</strong></h1><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>这一章我们从单体架构的优缺点来分析，看看开发大型项目采用单体架构存在哪些问题，而微服务架构又是如何解决这些问题的。</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p>单体架构（monolithic structure）：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。</p><p>单体架构（monolithic structure）：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091009234.jpeg" alt="img"></p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p><p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>在上述问题中，前两点相信大家在实战过程中应该深有体会。对于第三点系统可用性问题，很多同学可能感触不深。接下来我们就通过黑马商城这个项目，给大家做一个简单演示。</p><p>首先，我们修改hm-service模块下的<code>com.hmall.controller.HelloController</code>中的<code>hello</code>方法，模拟方法执行时的耗时：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042091.png" alt="img"></p><p>接下来，启动项目，目前有两个接口是无需登录即可访问的：</p><ul><li><code>http://localhost:8080/hi</code></li><li><code>http://localhost:8080/search/list</code></li></ul><p>经过测试，目前<code>/search/list</code> 是比较正常的，访问耗时在30毫秒左右。</p><p>接下来，我们假设<code>/hi</code>这个接口是一个并发较高的热点接口，我们通过Jemeter来模拟500个用户不停访问。在课前资料中已经提供了Jemeter的测试脚本：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042970.png" alt="img"></p><p>导入Jemeter并测试：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091341744.png" alt="image-20240709134151355"></p><p>这个脚本会开启500个线程并发请求<code>http://localhost/hi</code>这个接口。由于该接口存在执行耗时（500毫秒），这就服务端导致每秒能处理的请求数量有限，最终会有越来越多请求积压，直至Tomcat资源耗尽。这样，其它本来正常的接口（例如<code>/search/list</code>）也都会被拖慢，甚至因超时而无法访问了。</p><p>我们测试一下，启动测试脚本，然后在浏览器访问<code>http://localhost:8080/search/list</code>这个接口，会发现响应速度非常慢：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091342604.png" alt="image-20240709134224517"></p><p>如果进一步提高<code>/hi</code>这个接口的并发，最终会发现<code>/search/list</code>接口的请求响应速度会越来越慢。</p><p>可见，单体架构的可用性是比较差的，功能之间相互影响比较大。</p><p>当然，有同学会说我们可以做水平扩展。</p><p>此时如果我们对系统做水平扩展，增加更多机器，资源还是会被这样的热点接口占用，从而影响到其它接口，并不能从根本上解决问题。这也就是单体架构的扩展性差的一个原因。</p><p>而要想解决这些问题，就需要使用微服务架构了。</p><h2 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2.微服务"></a>1.2.微服务</h2><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p>例如，黑马商城项目，我们就可以把商品、用户、购物车、交易等模块拆分，交给不同的团队去开发，并独立部署：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042870.jpeg" alt="img"></p><p>那么，单体架构存在的问题有没有解决呢？</p><ul><li>团队协作成本高？<ul><li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在1~3名，协作成本大大降低</li></ul></li><li>系统发布效率低？<ul><li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li></ul></li><li>系统可用性差？<ul><li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务。</li></ul></li></ul><p>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过分布式架构，分布式就是服务拆分的过程，其实微服务架构正式分布式架构的一种最佳实践的方案。</p><p>当然，微服务架构虽然能解决单体架构的各种问题，但在拆分的过程中，还会面临很多其它问题。比如：</p><ul><li>如果出现跨服务的业务该如何处理？</li><li>页面请求到底该访问哪个服务？</li><li>如何实现各个服务之间的服务隔离？</li></ul><p>这些问题，我们在后续的学习中会给大家逐一解答。</p><h2 id="1-3-SpringCloud"><a href="#1-3-SpringCloud" class="headerlink" title="1.3.SpringCloud"></a>1.3.SpringCloud</h2><p>微服务拆分以后碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前<strong>Java领域最全面的微服务组件</strong>的集合了。</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042991.png" alt="img"></p><p>而且SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用SpringCloud全家桶来实现微服务开发可以说是最合适的选择了！</p><p><a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p><p>另外，Alibaba的微服务产品SpringCloudAlibaba目前也成为了SpringCloud组件中的一员，我们课堂中也会使用其中的部分组件。</p><p>在我们的父工程hmall中已经配置了SpringCloud以及SpringCloudAlibaba的依赖：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042794.png" alt="img"></p><p>对应的版本：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042009.png" alt="img"></p><p>这样，我们在后续需要使用SpringCloud或者SpringCloudAlibaba组件时，就无需单独指定版本了。</p><h1 id="2-微服务拆分"><a href="#2-微服务拆分" class="headerlink" title="2.微服务拆分"></a>2.微服务拆分</h1><p>接下来，我们就一起将黑马商城这个单体项目拆分为微服务项目，并解决其中出现的各种问题。</p><h2 id="2-1-熟悉黑马商城"><a href="#2-1-熟悉黑马商城" class="headerlink" title="2.1.熟悉黑马商城"></a>2.1.熟悉黑马商城</h2><p>首先，我们需要熟悉黑马商城项目的基本结构：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042440.png" alt="img"></p><p>大家可以直接启动该项目，测试效果。不过，需要修改数据库连接参数，在application-local.yaml中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 修改为你自己的虚拟机IP地址</span></span><br><span class="line">    <span class="attr">pw:</span> <span class="number">123</span> <span class="comment"># 修改为docker中的MySQL密码</span></span><br></pre></td></tr></table></figure><p>同时配置启动项激活的是local环境：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042526.png" alt="img"></p><h3 id="2-1-1-登录"><a href="#2-1-1-登录" class="headerlink" title="2.1.1.登录"></a>2.1.1.登录</h3><p>首先来看一下登录业务流程：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407100843655.png" alt="image-20240710084307501"></p><p>登录入口在<code>com.hmall.controller.UserController</code>中的<code>login</code>方法：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042911.png" alt="img"></p><h3 id="2-2-2-搜索商品"><a href="#2-2-2-搜索商品" class="headerlink" title="2.2.2.搜索商品"></a>2.2.2.搜索商品</h3><p>在首页搜索框输入关键字，点击搜索即可进入搜索列表页面：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042942.png" alt="img"></p><p>该页面会调用接口：<code>/search/list</code>，对应的服务端入口在<code>com.hmall.controller.SearchController</code>中的<code>search</code>方法：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042829.png" alt="img"></p><p>这里目前是利用数据库实现了简单的分页查询。</p><h3 id="2-2-3-购物车"><a href="#2-2-3-购物车" class="headerlink" title="2.2.3.购物车"></a>2.2.3.购物车</h3><p>在搜索到的商品列表中，点击按钮<code>加入购物车</code>，即可将商品加入购物车：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042865.png" alt="img"></p><p>加入成功后即可进入购物车列表页，查看自己购物车商品列表：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042995.png" alt="img"></p><p>同时这里还可以对购物车实现修改、删除等操作。</p><p>相关功能全部在<code>com.hmall.controller.CartController</code>中：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042282.png" alt="img"></p><p>其中，查询购物车列表时，由于要判断商品最新的价格和状态，所以还需要查询商品信息，业务流程如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407100844667.png" alt="image-20240710084408585"></p><h3 id="2-2-4-下单"><a href="#2-2-4-下单" class="headerlink" title="2.2.4.下单"></a>2.2.4.下单</h3><p>在购物车页面点击<code>结算</code>按钮，会进入订单结算页面：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042438.png" alt="img"></p><p>点击提交订单，会提交请求到服务端，服务端做3件事情：</p><ul><li>创建一个新的订单</li><li>扣减商品库存</li><li>清理购物车中商品</li></ul><p>业务入口在<code>com.hmall.controller.OrderController</code>中的<code>createOrder</code>方法：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407100844590.png" alt="image-20240710084448490"></p><h3 id="2-2-5-支付"><a href="#2-2-5-支付" class="headerlink" title="2.2.5.支付"></a>2.2.5.支付</h3><p>下单完成后会跳转到支付页面，目前只支持<strong>余额支付</strong>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042236.png" alt="img"></p><p>在选择<strong>余额支付</strong>这种方式后，会发起请求到服务端，服务端会立刻创建一个支付流水单，并返回支付流水单号到前端。</p><p>当用户输入用户密码，然后点击确认支付时，页面会发送请求到服务端，而服务端会做几件事情：</p><ul><li>校验用户密码</li><li>扣减余额</li><li>修改支付流水状态</li><li>修改交易订单状态</li></ul><p>请求入口在<code>com.hmall.controller.PayController</code>中：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042746.png" alt="img"></p><h2 id="2-2-服务拆分原则"><a href="#2-2-服务拆分原则" class="headerlink" title="2.2.服务拆分原则"></a>2.2.服务拆分原则</h2><p>服务拆分一定要考虑几个问题：</p><ul><li>什么时候拆？</li><li>如何拆？</li></ul><h3 id="2-2-1-什么时候拆"><a href="#2-2-1-什么时候拆" class="headerlink" title="2.2.1.什么时候拆"></a>2.2.1.什么时候拆</h3><p>一般情况下，对于一个初创的项目，首先要做的是验证项目的可行性。因此这一阶段的首要任务是敏捷开发，快速产出生产可用的产品，投入市场做验证。为了达成这一目的，该阶段项目架构往往会比较简单，很多情况下会直接采用单体架构，这样开发成本比较低，可以快速产出结果，一旦发现项目不符合市场，损失较小。</p><p>如果这一阶段采用复杂的微服务架构，投入大量的人力和时间成本用于架构设计，最终发现产品不符合市场需求，等于全部做了无用功。</p><p>所以，对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、业务复杂后<strong>再逐渐拆分为微服务架构</strong>。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）。</p><p>而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）。</p><h3 id="2-2-2-怎么拆"><a href="#2-2-2-怎么拆" class="headerlink" title="2.2.2.怎么拆"></a>2.2.2.怎么拆</h3><p>之前我们说过，微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析：</p><ul><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</li><li><strong>低耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</li></ul><p><strong>高内聚</strong>首先是<strong>单一职责，</strong>但<strong>不能说一个微服务就一个接口</strong>，而是要保证微服务内部业务的完整性为前提。目标是当我们要修改某个业务时，最好就只修改当前微服务，这样变更的成本更低。</p><p>一旦微服务做到了高内聚，那么服务之间的<strong>耦合度</strong>自然就降低了。</p><p>当然，微服务之间不可避免的会有或多或少的业务交互，比如下单时需要查询商品数据。这个时候我们不能在订单服务直接查询商品数据库，否则就导致了数据耦合。而应该由商品服务对应暴露接口，并且一定要保证微服务对外<strong>接口的稳定性</strong>（即：尽量保证接口外观不变）。虽然出现了服务间调用，但此时无论你如何在商品服务做内部修改，都不会影响到订单微服务，服务间的耦合度就降低了。</p><p>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式：</p><ul><li><strong>纵向</strong>拆分—–按照项目的功能模块来拆分</li><li><strong>横向</strong>拆分—–抽取公共服务，提高复用性</li></ul><p>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</p><p>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合。</p><p>当然，由于黑马商城并不是一个完整的项目，其中的短信发送、风控管理并没有实现，这里就不再考虑了。而其它的业务按照纵向拆分，可以分为以下几个微服务：</p><ul><li>用户服务</li><li>商品服务</li><li>订单服务</li><li>购物车服务</li><li>支付服务</li></ul><h2 id="2-3-拆分购物车、商品服务"><a href="#2-3-拆分购物车、商品服务" class="headerlink" title="2.3.拆分购物车、商品服务"></a>2.3.拆分购物车、商品服务</h2><p>接下来，我们先把商品管理功能、购物车功能抽取为两个独立服务。</p><p>一般微服务项目有两种不同的工程结构：</p><ul><li><strong>完全解耦</strong>：<strong>每一个微服务都创建为一个独立的工程</strong>，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li><strong>Maven聚合</strong>：<strong>整个项目为一个Project，然后每个微服务是其中的一个Module</strong><ul><li>优点：项目代码集中，管理和运维方便（授课也方便）</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><p><strong>注意</strong>：</p><p>为了授课方便，我们会采用Maven聚合工程，大家以后到了企业，可以根据需求自由选择工程结构。</p><p>在hmall父工程之中，我已经提前定义了SpringBoot、SpringCloud的依赖版本，所以为了方便期间，我们直接在这个项目中创建微服务module.</p><h3 id="2-3-1-商品服务"><a href="#2-3-1-商品服务" class="headerlink" title="2.3.1.商品服务"></a>2.3.1.商品服务</h3><p>在hmall中创建module：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042608.png" alt="img"></p><p>选择maven模块，并设定JDK版本为11：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042329.png" alt="img"></p><p>商品模块，我们起名为<code>item-service</code>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042555.png" alt="img"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>item-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写启动类：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042445.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描mapper层所在</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.item.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ItemApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是配置文件，可以从<code>hm-service</code>中拷贝：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101128891.png" alt="image-20240710112855781"></p><p>其中，<code>application.yaml</code>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-item?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">  <span class="comment">#指定了默认的枚举类型处理器，用于处理枚举类型与数据库字段之间的转换</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span> <span class="comment">#这里设置为 not_null，表示更新策略为仅在字段值不为空时进行更新。</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment">#设置主键的类型为 auto，通常表示主键自增</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">商品服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span> <span class="comment">#表示分组配置信息</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment">#表示默认分组的配置信息</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span> <span class="comment">#设置默认分组的名称为“default”。</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span> <span class="comment">#设置分组规则为按包名进行分组。</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span> <span class="comment">#表示分组规则对应的资源列表。</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.item.controller</span> <span class="comment">#表示将com.hmall.item.controller包下的控制器类作为分组的资源。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的<code>application-dev.yaml</code>和<code>application-local.yaml</code>直接从hm-service拷贝即可。</p><p>然后拷贝<code>hm-service</code>中与商品管理有关的代码到<code>item-service</code>，如图：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042772.png" alt="img"></p><p>这里有一个地方的代码需要改动，就是<code>ItemServiceImpl</code>中的<code>deductStock</code>方法：</p><p><strong>改动前</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042235.png" alt="img"></p><p><strong>改动后</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101136625.png" alt="img"></p><p>这也是因为ItemMapper的所在包发生了变化，因此这里代码必须修改包路径。</p><p>最后，还要导入数据库表。默认的数据库连接的是虚拟机，在你docker数据库执行课前资料提供的SQL文件：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042003.png" alt="img"></p><p>最终，会在数据库创建一个名为hm-item的database，将来的每一个微服务都会有自己的一个database：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042013.png" alt="img"></p><p><strong>注意</strong>：在企业开发的生产环境中，每一个微服务都应该有自己的<strong>独立数据库服务</strong>，而不仅仅是database，课堂我们用database来代替。</p><p>接下来，就可以启动测试了，在启动前我们要配置一下启动项，让默认激活的配置为<code>local</code>而不是<code>dev</code>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042613.png" alt="img"></p><p>在打开的编辑框填写<code>active profiles</code>:</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042700.png" alt="img"></p><p>接着，启动<code>item-service</code>，访问商品微服务的swagger接口文档：<a href="http://localhost:8081/doc.html">http://localhost:8081/doc.html</a></p><p>然后测试其中的根据id批量查询商品这个接口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101155397.png" alt="image-20240710115553290"></p><p>测试参数：100002672302,100002624500,100002533430，结果如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042825.png" alt="img"></p><p>说明商品微服务抽取成功了。</p><h3 id="2-3-2-购物车服务"><a href="#2-3-2-购物车服务" class="headerlink" title="2.3.2.购物车服务"></a>2.3.2.购物车服务</h3><p>与商品服务类似，在hmall下创建一个新的<code>module</code>，起名为<code>cart-service</code>:</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042005.png" alt="img"></p><p>然后是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cart-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是配置文件，同样可以拷贝自<code>item-service</code>，不过其中的<code>application.yaml</code>需要修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-cart?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">商品服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.cart.controller</span></span><br></pre></td></tr></table></figure><p>最后，把hm-service中的与购物车有关功能拷贝过来，最终的项目结构如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042663.png" alt="img"></p><p>特别注意的是<code>com.hmall.cart.service.impl.CartServiceImpl</code>，其中有两个地方需要处理：</p><ul><li>需要<strong>获取登录用户信息</strong>，但登录校验功能目前没有复制过来，先写死固定用户id</li><li>查询购物车时需要<strong>查询商品信息</strong>，而商品信息不在当前服务，需要先将这部分代码注释</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101138389.png" alt="image-20240710113848263"></p><p>我们对这部分代码做如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.dto.CartFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.po.Cart;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.vo.CartVO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.mapper.CartMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.service.ICartService;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BizIllegalException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 订单详情表 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-05-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="keyword">implements</span> <span class="title class_">ICartService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private final IItemService itemService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem2Cart</span><span class="params">(CartFormDTO cartFormDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断是否已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (checkItemExists(cartFormDTO.getItemId(), userId)) &#123;</span><br><span class="line">            <span class="comment">// 2.1.存在，则更新数量</span></span><br><span class="line">            baseMapper.updateNum(cartFormDTO.getItemId(), userId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.不存在，判断是否超过购物车数量</span></span><br><span class="line">        checkCartsFull(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.新增购物车条目</span></span><br><span class="line">        <span class="comment">// 3.1.转换PO</span></span><br><span class="line">        <span class="type">Cart</span> <span class="variable">cart</span> <span class="operator">=</span> BeanUtils.copyBean(cartFormDTO, Cart.class);</span><br><span class="line">        <span class="comment">// 3.2.保存当前用户</span></span><br><span class="line">        cart.setUserId(userId);</span><br><span class="line">        <span class="comment">// 3.3.保存到数据库</span></span><br><span class="line">        save(cart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CartVO&gt; <span class="title function_">queryMyCarts</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询我的购物车列表</span></span><br><span class="line">        List&lt;Cart&gt; carts = lambdaQuery().eq(Cart::getUserId, <span class="number">1L</span> <span class="comment">/*TODO UserContext.getUser()*/</span>).list();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(carts)) &#123;</span><br><span class="line">            <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.转换VO</span></span><br><span class="line">        List&lt;CartVO&gt; vos = BeanUtils.copyList(carts, CartVO.class);</span><br><span class="line">        <span class="comment">// 3.处理VO中的商品信息</span></span><br><span class="line">        handleCartItems(vos);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> vos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取商品id TODO 处理商品信息</span></span><br><span class="line">        <span class="comment">/*Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span></span><br><span class="line"><span class="comment">        // 2.查询商品</span></span><br><span class="line"><span class="comment">        List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span></span><br><span class="line"><span class="comment">        if (CollUtils.isEmpty(items)) &#123;</span></span><br><span class="line"><span class="comment">            throw new BadRequestException(&quot;购物车中商品不存在！&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 3.转为 id 到 item的map</span></span><br><span class="line"><span class="comment">        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));</span></span><br><span class="line"><span class="comment">        // 4.写入vo</span></span><br><span class="line"><span class="comment">        for (CartVO v : vos) &#123;</span></span><br><span class="line"><span class="comment">            ItemDTO item = itemMap.get(v.getItemId());</span></span><br><span class="line"><span class="comment">            if (item == null) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            v.setNewPrice(item.getPrice());</span></span><br><span class="line"><span class="comment">            v.setStatus(item.getStatus());</span></span><br><span class="line"><span class="comment">            v.setStock(item.getStock());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeByItemIds</span><span class="params">(Collection&lt;Long&gt; itemIds)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.构建删除条件，userId和itemId</span></span><br><span class="line">        QueryWrapper&lt;Cart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Cart&gt;();</span><br><span class="line">        queryWrapper.lambda()</span><br><span class="line">                .eq(Cart::getUserId, UserContext.getUser())</span><br><span class="line">                .in(Cart::getItemId, itemIds);</span><br><span class="line">        <span class="comment">// 2.删除</span></span><br><span class="line">        remove(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkCartsFull</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery().eq(Cart::getUserId, userId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(StrUtil.format(<span class="string">&quot;用户购物车课程不能超过&#123;&#125;&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkItemExists</span><span class="params">(Long itemId, Long userId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">                .eq(Cart::getUserId, userId)</span><br><span class="line">                .eq(Cart::getItemId, itemId)</span><br><span class="line">                .count();</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，还是要导入数据库表，在本地数据库直接执行课前资料对应的SQL文件：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042195.png" alt="img"></p><p>在数据库中会出现名为<code>hm-cart</code>的<code>database</code>，以及其中的<code>cart</code>表，代表购物车：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042668.png" alt="img"></p><p>接下来，就可以测试了。不过在启动前，同样要配置启动项的<code>active profile</code>为<code>local</code>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042396.png" alt="img"></p><p>然后启动<code>CartApplication</code>，访问swagger文档页面：<a href="http://localhost:8082/doc.html">http://localhost:8082/doc.html</a></p><p>我们测试其中的<code>查询我的购物车列表</code>接口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042660.png" alt="img"></p><p>无需填写参数，直接访问：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042634.png" alt="img"></p><p>我们注意到，其中与商品有关的几个字段值都为空！这就是因为刚才我们注释掉了查询购物车时，查询商品信息的相关代码。</p><p>那么，我们该如何在<code>cart-service</code>服务中实现对<code>item-service</code>服务的查询呢？</p><h2 id="2-4-服务调用"><a href="#2-4-服务调用" class="headerlink" title="2.4.服务调用"></a>2.4.服务调用</h2><p>在拆分的时候，我们发现一个问题：就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询。</p><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）。</p><p>因此，现在查询购物车列表的流程变成了这样：</p><p>暂时无法在飞书文档外展示此内容</p><p>代码中需要变化的就是这一步：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042929.png" alt="img"></p><p>那么问题来了：我们该如何跨服务调用，准确的说，如何在<code>cart-service</code>中获取<code>item-service</code>服务中的提供的商品数据呢？</p><p>大家思考一下，我们以前有没有实现过类似的远程查询的功能呢？</p><p>答案是肯定的，我们前端向服务端查询数据，其实就是从浏览器远程查询服务端数据。比如我们刚才通过Swagger测试商品查询接口，就是向<code>http://localhost:8081/items</code>这个接口发起的请求：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042478.png" alt="img"></p><p>而这种查询就是通过http请求的方式来完成的，不仅仅可以实现远程查询，还可以实现新增、删除等各种远程请求。</p><p>假如我们在cart-service中能模拟浏览器，发送http请求到item-service，是不是就实现了跨微服务的<strong>远程调用</strong>了呢？</p><p>那么：我们该如何用Java代码发送Http的请求呢？</p><h3 id="2-4-1-RestTemplate"><a href="#2-4-1-RestTemplate" class="headerlink" title="2.4.1.RestTemplate"></a>2.4.1.RestTemplate</h3><p>Spring给我们提供了一个RestTemplate的API，可以方便的实现Http请求的发送。</p><blockquote><p>org.springframework.web.client public class RestTemplate</p><p>extends InterceptingHttpAccessor</p><p>implements RestOperations</p><p>-—————————————————————————————————————</p><p>同步客户端执行HTTP请求，在底层HTTP客户端库(如JDK HttpURLConnection、Apache HttpComponents等)上公开一个简单的模板方法API。RestTemplate通过HTTP方法为常见场景提供了模板，此外还提供了支持不太常见情况的通用交换和执行方法。 RestTemplate通常用作共享组件。然而，它的配置不支持并发修改，因此它的配置通常是在启动时准备的。如果需要，您可以在启动时创建多个不同配置的RestTemplate实例。如果这些实例需要共享HTTP客户端资源，它们可以使用相同的底层ClientHttpRequestFactory。 注意:从5.0开始，这个类处于维护模式，只有对更改和错误的小请求才会被接受。请考虑使用org.springframework.web.react .client. webclient，它有更现代的API，支持同步、异步和流场景。  </p><p>-—————————————————————————————————————</p><p>自: 3.0 参见: HttpMessageConverter, RequestCallback, ResponseExtractor, ResponseErrorHandler</p></blockquote><p>其中提供了大量的方法，方便我们发送Http请求，例如：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042652.png" alt="img"></p><p>可以看到常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。</p><p>我们在<code>cart-service</code>服务中定义一个配置类：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042954.png" alt="img"></p><p>先将RestTemplate注册为一个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-远程调用"><a href="#2-4-2-远程调用" class="headerlink" title="2.4.2.远程调用"></a>2.4.2.远程调用</h3><p>接下来，我们修改<code>cart-service</code>中的<code>com.hmall.cart.service.impl.CartServiceImpl</code>的<code>handleCartItems</code>方法，发送http请求到<code>item-service</code>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042864.png"></p><p><code>handleCartItems</code>方法的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：通过RestTemplate发送http请求来时远程调用（不推荐ip容易写死，不好处理服务器负载均衡）</span></span><br><span class="line">        <span class="comment">// 第二种方式：利用Spring Cloud进行服务注册，通过Feign来实现远程调用（推荐，代码简单，能实现服务器负载均衡）</span></span><br><span class="line">        <span class="comment">// 1.获取商品id</span></span><br><span class="line">        Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// 2.查询商品</span></span><br><span class="line"><span class="comment">//        List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span></span><br><span class="line">        <span class="comment">//第一种方式使用：</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * exchange方法</span></span><br><span class="line"><span class="comment">//         * 对给定的 URI 模板执行 HTTP 方法，将给定的请求实体写入请求，并将响应返回为 ResponseEntity。给定 ParameterizedTypeReference 用于传递泛型类型信息：</span></span><br><span class="line"><span class="comment">//         *   ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean =</span></span><br><span class="line"><span class="comment">//         *       new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() &#123;&#125;;</span></span><br><span class="line"><span class="comment">//         *   ResponseEntity&lt;List&lt;MyBean&gt;&gt; response =</span></span><br><span class="line"><span class="comment">//         *       template.exchange(&quot;https://example.com&quot;,HttpMethod.GET, null, myBean);</span></span><br><span class="line"><span class="comment">//         * 参数：</span></span><br><span class="line"><span class="comment">//         * url – 网址</span></span><br><span class="line"><span class="comment">//         * method – HTTP 方法（GET、POST 等）</span></span><br><span class="line"><span class="comment">//         * requestEntity – 要写入请求的实体（标头和/或正文）（可能是 null）</span></span><br><span class="line"><span class="comment">//         * responseType – 要将响应 Void.class 转换为或无正文的类型</span></span><br><span class="line"><span class="comment">//         * uriVariables – 要在模板中展开的变量</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt;  responseItems = restTemplate.exchange(</span></span><br><span class="line"><span class="comment">//                //指定请求地址</span></span><br><span class="line"><span class="comment">//                &quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;,</span></span><br><span class="line"><span class="comment">//                //指定请求方式</span></span><br><span class="line"><span class="comment">//                HttpMethod.GET,</span></span><br><span class="line"><span class="comment">//                null,</span></span><br><span class="line"><span class="comment">//                //指定响应格式</span></span><br><span class="line"><span class="comment">//                new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span></span><br><span class="line"><span class="comment">//                &#125;,</span></span><br><span class="line"><span class="comment">//                //以逗号分隔拼接,使用可使用hutool工具包内方法来实现拼接</span></span><br><span class="line"><span class="comment">//                Map.of(&quot;ids&quot;,CollUtil.join(itemIds,&quot;,&quot;))</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line"><span class="comment">//        if (!responseItems.getStatusCode().is2xxSuccessful())&#123;</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        List&lt;ItemDTO&gt; items = responseItems.getBody();</span></span><br></pre></td></tr></table></figure><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li>① 请求方式</li><li>② 请求路径</li><li>③ 请求参数</li><li>④  返回值类型</li></ul><p>好了，现在重启<code>cart-service</code>，再次测试查询我的购物车列表接口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042400.png" alt="img"></p><p>可以发现，所有商品相关数据都已经查询到了。</p><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>什么时候需要拆分微服务？</p><ul><li>如果是创业型公司，最好先用单体架构快速迭代开发，验证市场运作模型，快速试错。当业务跑通以后，随着业务规模扩大、人员规模增加，再考虑拆分微服务。</li><li>如果是大型企业，有充足的资源，可以在项目开始之初就搭建微服务架构。</li></ul><p>如何拆分？</p><ul><li>首先要做到高内聚、低耦合</li><li>从拆分方式来说，有横向拆分和纵向拆分两种。纵向就是按照业务功能模块，横向则是拆分通用性业务，提高复用性</li></ul><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为RPC，即远程过程调用。RPC的实现方式有很多，比如：</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li></ul><p>我们课堂中使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可，更符合微服务的需要。</p><p>Java发送http请求可以使用Spring提供的RestTemplate，使用的基本步骤如下：</p><ul><li>注册RestTemplate到Spring容器</li><li>调用RestTemplate的API发送请求，常见方法有：<ul><li>getForObject：发送Get请求并返回指定类型对象</li><li>PostForObject：发送Post请求并返回指定类型对象</li><li>put：发送PUT请求</li><li>delete：发送Delete请求</li><li>exchange：发送任意类型请求，返回ResponseEntity</li></ul></li></ul><h1 id="3-服务注册和发现"><a href="#3-服务注册和发现" class="headerlink" title="3.服务注册和发现"></a>3.服务注册和发现</h1><p>在上一章我们实现了微服务拆分，并且通过Http请求实现了跨微服务的远程调用。不过这种手动发送Http请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，我们进行了多实例部署，如图：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091514724.png" alt="image-20240709151434440"></p><p>此时，每个<code>item-service</code>的实例其IP或端口不同，问题来了：</p><ul><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h2 id="3-1-注册中心原理"><a href="#3-1-注册中心原理" class="headerlink" title="3.1.注册中心原理"></a>3.1.注册中心原理</h2><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042533.jpeg" alt="img"></p><p>流程如下：</p><ul><li><strong>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</strong></li><li><strong>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表</strong>（1个服务可能多实例部署）</li><li><strong>调用者自己对实例列表负载均衡，挑选一个实例</strong>（常用负载均衡算法：随机、轮询、加权轮询）</li><li><strong>调用者向该实例发起远程调用</strong></li></ul><p>当<strong>服务提供者的实例宕机或者启动新实例</strong>时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（<strong>心跳请求机制</strong>）</li><li>当<strong>注册中心长时间收不到提供者的心跳时</strong>，会认为该<strong>实例宕机</strong>，将其从服务的实例列表中<strong>剔除</strong></li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="3-2-Nacos注册中心"><a href="#3-2-Nacos注册中心" class="headerlink" title="3.2.Nacos注册中心"></a>3.2.Nacos注册中心</h2><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用（现已经停止维护）</li><li><strong>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</strong></li><li><strong>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</strong></li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。由于Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多，课堂中我们会Nacos为例来学习。</p><p>官方网站如下：</p><p><a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p><p>我们基于Docker来部署Nacos的注册中心，首先我们要准备MySQL数据库表，用来存储Nacos的数据。由于是Docker部署，所以大家需要将资料中的SQL文件导入到你<strong>Docker中的MySQL容器</strong>中：</p><p>部署nacos sql语句源文件地址：</p><p><a href="https://github.com/alibaba/nacos/blob/master/distribution/conf/mysql-schema.sql">nacos&#x2F;distribution&#x2F;conf&#x2F;mysql-schema.sql at master · alibaba&#x2F;nacos (github.com)</a></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091527319.png" alt="image-20240709152712787"></p><p>最终表结构如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042582.png" alt="img"></p><p>然后，找到课前资料下的nacos文件夹：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042914.png" alt="img"></p><p>其中的<code>nacos/custom.env</code>文件中，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为你自己的虚拟机IP地址例如个人为<u>192.168.170.10</u>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042844.png" alt="img"></p><p><strong>docker拉取<a href="https://so.csdn.net/so/search?q=nacos&spm=1001.2101.3001.7020">nacos</a>镜像</strong></p><p>1.拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search nacos ---搜索nacos源</span><br><span class="line">docker pull nacos/nacos-server -----拉取nacos镜像</span><br></pre></td></tr></table></figure><p>然后，将课前资料中的<code>nacos</code>目录上传至虚拟机的<code>/root</code>目录。</p><p>进入root目录，然后执行下面的docker命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br><span class="line"></span><br><span class="line">//<span class="number">8848</span> 是用于客户端与服务通信的主要端口。</span><br><span class="line"><span class="number">9848</span> 是 gRPC 端口，用于与 Nacos 的 gRPC 通信（如果需要）。</span><br><span class="line"><span class="number">9849</span> 是 Raft 端口，用于 Nacos 集群中节点之间的通信（如果运行集群模式）。</span><br></pre></td></tr></table></figure><p>启动完成后，访问下面地址：<a href="http://192.168.170.10:8848/nacos/%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%B0%86%60192.168.170.10%60%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAIP%E5%9C%B0%E5%9D%80%E3%80%82">http://192.168.170.10:8848/nacos/，注意将`192.168.170.10`替换为你自己的虚拟机IP地址。</a></p><p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042711.png" alt="img"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>接下来，我们把<code>item-service</code>注册到Nacos，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>重启</li></ul><h3 id="3-3-1-添加依赖"><a href="#3-3-1-添加依赖" class="headerlink" title="3.3.1.添加依赖"></a>3.3.1.添加依赖</h3><p>在<code>item-service</code>的<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-配置Nacos"><a href="#3-3-2-配置Nacos" class="headerlink" title="3.3.2.配置Nacos"></a>3.3.2.配置Nacos</h3><p>在<code>item-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.170</span><span class="number">.10</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-启动服务实例"><a href="#3-3-3-启动服务实例" class="headerlink" title="3.3.3.启动服务实例"></a>3.3.3.启动服务实例</h3><p>为了测试一个服务多个实例的情况，我们再配置一个<code>item-service</code>的部署实例：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042131.png" alt="img"></p><p>然后配置启动项，注意重命名并且配置新的端口，避免冲突：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091602001.png" alt="image-20240709160243921"></p><p>重启<code>item-service</code>的两个实例：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042233.png" alt="img"></p><p>访问nacos控制台，可以发现服务注册成功：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042405.png" alt="img"></p><p>点击详情，可以查看到<code>item-service</code>服务的两个实例信息：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042722.png" alt="img"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><h3 id="3-4-1-引入依赖"><a href="#3-4-1-引入依赖" class="headerlink" title="3.4.1.引入依赖"></a>3.4.1.引入依赖</h3><p>服务发现除了要引入nacos依赖以外，由于还需要<strong>负载均衡</strong>，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>我们在<code>cart-service</code>中的<code>pom.xml</code>中添加下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，这里Nacos的依赖于服务注册时一致，这个<strong>依赖中同时包含了服务注册和发现的功能</strong>。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><p>因此，等一会儿<code>cart-service</code>启动，同样会注册到Nacos</p><h3 id="3-4-2-配置Nacos地址"><a href="#3-4-2-配置Nacos地址" class="headerlink" title="3.4.2.配置Nacos地址"></a>3.4.2.配置Nacos地址</h3><p>在<code>cart-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.170</span><span class="number">.10</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h3 id="3-4-3-发现并调用服务"><a href="#3-4-3-发现并调用服务" class="headerlink" title="3.4.3.发现并调用服务"></a>3.4.3.发现并调用服务</h3><p>接下来，服务调用者<code>cart-service</code>就可以去订阅<code>item-service</code>服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li><strong>随机</strong></li><li><strong>轮询</strong></li><li>IP的hash</li><li><strong>最近最少访问</strong></li><li>…</li></ul><p>这里我们可以选择<strong>最简单的随机负载均衡</strong>。</p><p>另外，服务发现需要用到一个工具，DiscoveryClient，<strong>SpringCloud已经帮我们自动装配</strong>，我们可以直接注入使用：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042878.png" alt="img"></p><p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042896.png" alt="img"></p><p>但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042498.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//第一种方式使用升级版 解决ip地址写死的问题</span></span><br><span class="line">        <span class="comment">//1.根据服务名称获取实例列表</span></span><br><span class="line">        <span class="comment">//获取与特定 serviceId 关联的所有 ServiceInstances。</span></span><br><span class="line">        <span class="comment">//参数：</span></span><br><span class="line">        <span class="comment">//serviceId – 要查询的 serviceId。</span></span><br><span class="line">        <span class="comment">//返回：</span></span><br><span class="line">        <span class="comment">//ServiceInstance 的列表。</span></span><br><span class="line"><span class="comment">//        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;item-service&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //2.编写负载均衡算法，这里采用最简单的随机负载均衡算法</span></span><br><span class="line"><span class="comment">//        ServiceInstance serviceInstance = instances.get(RandomUtil.randomInt(instances.size()));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //3.获取负载均衡的实例请求地址</span></span><br><span class="line"><span class="comment">//        URI uri = serviceInstance.getUri();</span></span><br><span class="line"><span class="comment">//        //通过RestTemplate发送http请求来时远程调用</span></span><br><span class="line"><span class="comment">//        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; responseItems = restTemplate.exchange(</span></span><br><span class="line"><span class="comment">//                //指定请求地址</span></span><br><span class="line"><span class="comment">//                uri + &quot;/items?ids=&#123;ids&#125;&quot;,</span></span><br><span class="line"><span class="comment">//                //指定请求方式</span></span><br><span class="line"><span class="comment">//                HttpMethod.GET,</span></span><br><span class="line"><span class="comment">//                null,</span></span><br><span class="line"><span class="comment">//                //指定响应格式</span></span><br><span class="line"><span class="comment">//                new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,</span></span><br><span class="line"><span class="comment">//                //以逗号分隔拼接,使用可使用hutool工具包内方法来实现拼接</span></span><br><span class="line"><span class="comment">//                Map.of(&quot;ids&quot;,CollUtil.join(itemIds,&quot;,&quot;))</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line"><span class="comment">//        if (!responseItems.getStatusCode().is2xxSuccessful())&#123;</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        List&lt;ItemDTO&gt; items = responseItems.getBody();</span></span><br></pre></td></tr></table></figure><p>经过swagger测试，发现没有任何问题。</p><h1 id="4-OpenFeign-重点"><a href="#4-OpenFeign-重点" class="headerlink" title="4.OpenFeign(重点)"></a>4.OpenFeign(重点)</h1><p>在上一章，我们利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用。但是远程调用的代码太复杂了：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042946.png" alt="img"></p><p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><p>接下来，我们就通过一个快速入门的案例来体验一下OpenFeign的便捷吧。</p><h2 id="4-1-快速入门"><a href="#4-1-快速入门" class="headerlink" title="4.1.快速入门"></a>4.1.快速入门</h2><p>我们还是以cart-service中的查询我的购物车为例。因此下面的操作都是在cart-service中进行。</p><h3 id="4-1-1-引入依赖"><a href="#4-1-1-引入依赖" class="headerlink" title="4.1.1.引入依赖"></a>4.1.1.引入依赖</h3><p>在<code>cart-service</code>服务的pom.xml中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-启用OpenFeign"><a href="#4-1-2-启用OpenFeign" class="headerlink" title="4.1.2.启用OpenFeign"></a>4.1.2.启用OpenFeign</h3><p>接下来，我们在<code>cart-service</code>的<code>CartApplication</code>启动类上添加注解，启动OpenFeign功能：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042840.png" alt="img"></p><h3 id="4-1-3-编写OpenFeign客户端"><a href="#4-1-3-编写OpenFeign客户端" class="headerlink" title="4.1.3.编写OpenFeign客户端"></a>4.1.3.编写OpenFeign客户端</h3><p>在<code>cart-service</code>中，定义一个新的接口，编写<strong>Feign客户端</strong>：</p><p>其中代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.cart.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.cart.domain.dto.ItemDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient(&quot;item-service&quot;)</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;/items&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h3 id="4-1-4-使用FeignClient"><a href="#4-1-4-使用FeignClient" class="headerlink" title="4.1.4.使用FeignClient"></a>4.1.4.使用FeignClient</h3><p>最后，我们在<code>cart-service</code>的<code>com.hmall.cart.service.impl.CartServiceImpl</code>中改造代码，直接调用<code>ItemClient</code>的方法：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042340.png" alt="img"></p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式：利用Spring Cloud进行服务注册，通过Feign来实现远程调用（推荐，代码简单，能实现服务器负载均衡）</span></span><br><span class="line"></span><br><span class="line">        List&lt;ItemDTO&gt; items = itemOpenFeignClient.queryItemByIds(itemIds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(items)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.转为 id 到 item的map</span></span><br><span class="line">        Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));</span><br><span class="line">        <span class="comment">// 4.写入vo</span></span><br><span class="line">        <span class="keyword">for</span> (CartVO v : vos) &#123;</span><br><span class="line">            <span class="type">ItemDTO</span> <span class="variable">item</span> <span class="operator">=</span> itemMap.get(v.getItemId());</span><br><span class="line">            <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v.setNewPrice(item.getPrice());</span><br><span class="line">            v.setStatus(item.getStatus());</span><br><span class="line">            v.setStock(item.getStock());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作，是不是看起来优雅多了。</p><p>而且，这里我们不再需要RestTemplate了，还省去了RestTemplate的注册。</p><h2 id="4-2-连接池"><a href="#4-2-连接池" class="headerlink" title="4.2.连接池"></a>4.2.连接池</h2><p>Feign底层发起http请求（<strong>底层默认发送请求方式性能较差</strong>，不支持连接池），依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li><strong>HttpURLConnection</strong>：默认实现，不支持连接池</li><li><strong>Apache HttpClient</strong> ：支持连接池</li><li><strong>OKHttp</strong>：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><h3 id="4-2-1-引入依赖"><a href="#4-2-1-引入依赖" class="headerlink" title="4.2.1.引入依赖"></a>4.2.1.引入依赖</h3><p>在<code>cart-service</code>的<code>pom.xml</code>中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-开启连接池"><a href="#4-2-2-开启连接池" class="headerlink" title="4.2.2.开启连接池"></a>4.2.2.开启连接池</h3><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><p>重启服务，连接池就生效了。</p><h3 id="4-2-3-验证"><a href="#4-2-3-验证" class="headerlink" title="4.2.3.验证"></a>4.2.3.验证</h3><p>我们可以打断点验证连接池是否生效，在<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>中的<code>execute</code>方法中打断点：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091627738.png" alt="image-20240709162750648"></p><p>Debug方式启动cart-service，请求一次查询我的购物车方法，进入断点：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042474.png" alt="img"></p><p>可以发现这里底层的实现已经改为<code>OkHttpClient</code></p><h2 id="4-3-最佳实践"><a href="#4-3-最佳实践" class="headerlink" title="4.3.最佳实践"></a>4.3.最佳实践</h2><p>将来我们要把与下单有关的业务抽取为一个独立微服务:<code>trade-service</code>，不过我们先来看一下<code>hm-service</code>中原本与下单有关的业务逻辑。</p><p>入口在<code>com.hmall.controller.OrderController</code>的<code>createOrder</code>方法，然后调用了<code>IOrderService</code>中的<code>createOrder</code>方法。</p><p>由于下单时前端提交了商品id，为了计算订单总价，需要查询商品信息：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042370.png" alt="img"></p><p>也就是说，如果拆分了交易微服务（<code>trade-service</code>），它也需要远程调用<code>item-service</code>中的根据id批量查询商品功能。这个需求与<code>cart-service</code>中是一样的。</p><p>因此，我们就需要在<code>trade-service</code>中再次定义<code>ItemClient</code>接口，这不是<strong>重复编码</strong>吗？ 有什么办法能加避免重复编码呢？</p><h3 id="4-3-1-思路分析"><a href="#4-3-1-思路分析" class="headerlink" title="4.3.1.思路分析"></a>4.3.1.思路分析</h3><p>相信大家都能想到，避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p><ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul><p>如图：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042539.jpeg" alt="img"></p><p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><p>由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.</p><h3 id="4-3-2-抽取Feign客户端"><a href="#4-3-2-抽取Feign客户端" class="headerlink" title="4.3.2.抽取Feign客户端"></a>4.3.2.抽取Feign客户端</h3><p>在<code>hmall</code>下定义一个新的module，命名为hm-api</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042728.png" alt="img"></p><p>其依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--open feign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- load balancer--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- swagger 注解依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把ItemDTO和ItemClient都拷贝过来，最终结构如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091632358.png" alt="image-20240709163237266"></p><p>现在，任何微服务要调用<code>item-service</code>中的接口，只需要引入<code>hm-api</code>模块依赖即可，无需自己编写Feign客户端了。</p><h3 id="4-3-3-扫描包"><a href="#4-3-3-扫描包" class="headerlink" title="4.3.3.扫描包"></a>4.3.3.扫描包</h3><p>接下来，我们在<code>cart-service</code>的<code>pom.xml</code>中引入<code>hm-api</code>模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--feign模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除<code>cart-service</code>中原来的ItemDTO和ItemClient，重启项目，发现报错了：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042874.png" alt="img"></p><p>这里因为<code>ItemClient</code>现在定义到了<code>com.hmall.api.client</code>包下，而cart-service的启动类定义在<code>com.hmall.cart</code>包下，扫描不到<code>ItemClient</code>，所以报错了。</p><p>解决办法很简单，在<strong>cart-service的启动类上添加声明</strong>即可，两种方式：</p><ul><li>方式1：声明扫描包：</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042090.png" alt="img"></p><ul><li>方式2：声明要用的FeignClient</li></ul><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042767.png" alt="img"></p><h2 id="4-4-日志配置"><a href="#4-4-日志配置" class="headerlink" title="4.4.日志配置"></a>4.4.日志配置</h2><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</p><h3 id="4-4-1-定义日志级别"><a href="#4-4-1-定义日志级别" class="headerlink" title="4.4.1.定义日志级别"></a>4.4.1.定义日志级别</h3><p>在hm-api模块下新建一个配置类，定义Feign的日志级别：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091042001.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-配置"><a href="#4-4-2-配置" class="headerlink" title="4.4.2.配置"></a>4.4.2.配置</h3><p>接下来，要让日志级别生效，还需要配置这个类。有两种方式：</p><ul><li><strong>局部</strong>生效：在某个<code>FeignClient</code>中配置，只对当前<code>FeignClient</code>生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><ul><li><strong>全局</strong>生效：在<code>@EnableFeignClients</code>中配置，针对所有<code>FeignClient</code>生效。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><p>日志格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; GET http://item-service/items?ids=100000006163 HTTP/1.1</span><br><span class="line">17:35:32:148 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] ---&gt; END HTTP (0-byte body)</span><br><span class="line">17:35:32:278 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- HTTP/1.1 200  (127ms)</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] connection: keep-alive</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] content-type: application/json</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] date: Fri, 26 May 2023 09:35:32 GMT</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] keep-alive: timeout=60</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] transfer-encoding: chunked</span><br><span class="line">17:35:32:279 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] </span><br><span class="line">17:35:32:280 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] [&#123;&quot;id&quot;:100000006163,&quot;name&quot;:&quot;巴布豆(BOBDOG)柔薄悦动婴儿拉拉裤XXL码80片(15kg以上)&quot;,&quot;price&quot;:67100,&quot;stock&quot;:10000,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t23998/350/2363990466/222391/a6e9581d/5b7cba5bN0c18fb4f.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉拉裤&quot;,&quot;brand&quot;:&quot;巴布豆&quot;,&quot;spec&quot;:&quot;&#123;&#125;&quot;,&quot;sold&quot;:11,&quot;commentCount&quot;:33343434,&quot;isAD&quot;:false,&quot;status&quot;:2&#125;]</span><br><span class="line">17:35:32:281 DEBUG 18620 --- [nio-8082-exec-1] com.hmall.api.client.ItemClient          : [ItemClient#queryItemByIds] &lt;--- END HTTP (369-byte body)</span><br></pre></td></tr></table></figure><h1 id="后续微服务拆分："><a href="#后续微服务拆分：" class="headerlink" title="后续微服务拆分："></a>后续微服务拆分：</h1><h1 id="1-用户服务"><a href="#1-用户服务" class="headerlink" title="1.用户服务"></a>1.用户服务</h1><h2 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1.创建项目"></a>1.1.创建项目</h2><p>在hmall下新建一个module，命名为user-service：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712820.png" alt="img"></p><h2 id="1-2-依赖"><a href="#1-2-依赖" class="headerlink" title="1.2.依赖"></a>1.2.依赖</h2><p>user-service的pom.xml文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--api--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-启动类"><a href="#1-3-启动类" class="headerlink" title="1.3.启动类"></a>1.3.启动类</h2><p>在user-service中的<code>com.hmall.user</code>包下创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.user.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-配置文件"><a href="#1-4-配置文件" class="headerlink" title="1.4.配置文件"></a>1.4.配置文件</h2><p>从<code>hm-service</code>项目中复制3个yaml配置文件到<code>user-service</code>的<code>resource</code>目录。</p><p>其中<code>application-dev.yaml</code>和<code>application-local.yaml</code>保持不变。<code>application.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-user?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.170</span><span class="number">.10</span> <span class="comment"># nacos地址</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">用户服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.user.controller</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span></span><br></pre></td></tr></table></figure><p>将hm-service下的hmall.jks文件拷贝到user-service下的resources目录，这是JWT加密的秘钥文件：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2JjNTNmMzNlZmQ1ZWFiZWIyMGU2NGE1NTJiNGJkN2ZfNHk0dldZbVA5a3VyYnA1YUtrZ2s1S1d6eDZvVmwzTTJfVG9rZW46UUw2MGJDQ2cyb0JuUUJ4ZERyZGMybHQ1blBlXzE3MjA1MTYzNjY6MTcyMDUxOTk2Nl9WNA" alt="img"></p><h2 id="1-5-代码"><a href="#1-5-代码" class="headerlink" title="1.5.代码"></a>1.5.代码</h2><p>复制hm-service中所有与user、address、jwt有关的代码，最终项目结构如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712883.png" alt="img"></p><h2 id="1-6-数据库"><a href="#1-6-数据库" class="headerlink" title="1.6.数据库"></a>1.6.数据库</h2><p>user-service也需要自己的独立的database，向MySQL中导入课前资料提供的SQL：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NjhjY2U2NmZiYjhiNTJiNTAwNjhmMjhiOGE3NzBiYTlfYnVNdnhTck5tdmcxMXlqc0xZV0trZTNLY0QzUW9wQXZfVG9rZW46QUxndGJXdGprb3JTYU14SkYxN2NlQ2xkblJkXzE3MjA1MTYzNjY6MTcyMDUxOTk2Nl9WNA" alt="img"></p><p>导入结果如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712776.png" alt="img"></p><h2 id="1-7-配置启动项"><a href="#1-7-配置启动项" class="headerlink" title="1.7.配置启动项"></a>1.7.配置启动项</h2><p>给user-service配置启动项，设置profile为local：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712887.png" alt="img"></p><h2 id="1-8-测试"><a href="#1-8-测试" class="headerlink" title="1.8.测试"></a>1.8.测试</h2><p>启动UserApplication，访问<a href="http://localhost:8084/doc.html#/default/%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/loginUsingPOST%EF%BC%8C%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%9A">http://localhost:8084/doc.html#/default/用户相关接口/loginUsingPOST，测试登录接口：</a></p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101143640.png" alt="image-20240710114349489"></p><p>用户服务测试通过。</p><h1 id="2-交易服务"><a href="#2-交易服务" class="headerlink" title="2.交易服务"></a>2.交易服务</h1><h2 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1.创建项目"></a>2.1.创建项目</h2><p>在hmall下新建一个module，命名为trade-service：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712618.png" alt="img"></p><h2 id="2-2-依赖"><a href="#2-2-依赖" class="headerlink" title="2.2.依赖"></a>2.2.依赖</h2><p>trade-service的pom.xml文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--api--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3.启动类"></a>2.3.启动类</h2><p>在trade-service中的<code>com.hmall.trade</code>包下创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.trade.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TradeApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TradeApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4.配置文件"></a>2.4.配置文件</h2><p>从<code>hm-service</code>项目中复制3个yaml配置文件到<code>trade-service</code>的<code>resource</code>目录。</p><p>其中<code>application-dev.yaml</code>和<code>application-local.yaml</code>保持不变。<code>application.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-trade?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.170</span><span class="number">.10</span> <span class="comment"># nacos地址</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">交易服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;信息&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.trade.controller</span></span><br></pre></td></tr></table></figure><h2 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5.代码"></a>2.5.代码</h2><h3 id="2-5-1-基础代码"><a href="#2-5-1-基础代码" class="headerlink" title="2.5.1.基础代码"></a>2.5.1.基础代码</h3><p>复制hm-service中所有与trade有关的代码，最终项目结构如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712744.png" alt="img"></p><p>在交易服务中，用户下单时需要做下列事情：</p><ul><li><strong>根据id查询商品列表</strong></li><li>计算商品总价</li><li>保存订单</li><li><strong>扣减库存</strong></li><li><strong>清理购物车商品</strong></li></ul><p>其中，查询商品、扣减库存都是与商品有关的业务，在item-service中有相关功能；清理购物车商品是购物车业务，在cart-service中有相关功能。</p><p>因此交易服务要调用他们，必须通过OpenFeign远程调用。我们需要将上述功能抽取为FeignClient.</p><h3 id="2-5-2-抽取ItemClient接口"><a href="#2-5-2-抽取ItemClient接口" class="headerlink" title="2.5.2.抽取ItemClient接口"></a>2.5.2.抽取ItemClient接口</h3><p>首先是<strong>扣减库存</strong>，在<code>item-service</code>中的对应业务接口如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101144447.png" alt="image-20240710114429323"></p><p>我们将这个接口抽取到<code>hm-api</code>模块的<code>com.hmall.api.client.ItemClient</code>中:</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712841.png" alt="img"></p><p>将接口参数的<code>OrderDetailDTO</code>抽取到<code>hm-api</code>模块的<code>com.hmall.api.dto</code>包下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101147936.png" alt="image-20240710114735834"></p><h3 id="2-5-3-抽取CartClient接口"><a href="#2-5-3-抽取CartClient接口" class="headerlink" title="2.5.3.抽取CartClient接口"></a>2.5.3.抽取CartClient接口</h3><p>接下来是<strong>清理购物车商品</strong>，在<code>cart-service</code>中的对应业务接口如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712775.png" alt="img"></p><p>我们在<code>hm-api</code>模块的<code>com.hmall.api.client</code>包下定义一个<code>CartClient</code>接口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712614.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;cart-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CartClient</span> &#123;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/carts&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteCartItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-4-改造OrderServiceImpl"><a href="#2-5-4-改造OrderServiceImpl" class="headerlink" title="2.5.4.改造OrderServiceImpl"></a>2.5.4.改造OrderServiceImpl</h3><p>接下来，就可以改造OrderServiceImpl中的逻辑，将本地方法调用改造为基于FeignClient的调用，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.CartClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.ItemClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.ItemDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.OrderDetailDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BadRequestException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.dto.OrderFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.Order;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.OrderDetail;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.mapper.OrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderDetailService;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderMapper, Order&gt; <span class="keyword">implements</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderDetailService detailService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CartClient cartClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.订单数据</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        <span class="comment">// 1.1.查询商品</span></span><br><span class="line">        List&lt;OrderDetailDTO&gt; detailDTOS = orderFormDTO.getDetails();</span><br><span class="line">        <span class="comment">// 1.2.获取商品id和数量的Map</span></span><br><span class="line">        Map&lt;Long, Integer&gt; itemNumMap = detailDTOS.stream()</span><br><span class="line">                .collect(Collectors.toMap(OrderDetailDTO::getItemId, OrderDetailDTO::getNum));</span><br><span class="line">        Set&lt;Long&gt; itemIds = itemNumMap.keySet();</span><br><span class="line">        <span class="comment">// 1.3.查询商品</span></span><br><span class="line">        List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br><span class="line">        <span class="keyword">if</span> (items == <span class="literal">null</span> || items.size() &lt; itemIds.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;商品不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.4.基于商品价格、购买数量计算商品总价：totalFee</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ItemDTO item : items) &#123;</span><br><span class="line">            total += item.getPrice()  itemNumMap.get(item.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        order.setTotalFee(total);</span><br><span class="line">        <span class="comment">// 1.5.其它属性</span></span><br><span class="line">        order.setPaymentType(orderFormDTO.getPaymentType());</span><br><span class="line">        order.setUserId(UserContext.getUser());</span><br><span class="line">        order.setStatus(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 1.6.将Order写入数据库order表中</span></span><br><span class="line">        save(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.保存订单详情</span></span><br><span class="line">        List&lt;OrderDetail&gt; details = buildDetails(order.getId(), items, itemNumMap);</span><br><span class="line">        detailService.saveBatch(details);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.扣减库存</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            itemClient.deductStock(detailDTOS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.清理购物车商品</span></span><br><span class="line">        cartClient.deleteCartItemByIds(itemIds);</span><br><span class="line">        <span class="keyword">return</span> order.getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderDetail&gt; <span class="title function_">buildDetails</span><span class="params">(Long orderId, List&lt;ItemDTO&gt; items, Map&lt;Long, Integer&gt; numMap)</span> &#123;</span><br><span class="line">        List&lt;OrderDetail&gt; details = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(items.size());</span><br><span class="line">        <span class="keyword">for</span> (ItemDTO item : items) &#123;</span><br><span class="line">            <span class="type">OrderDetail</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDetail</span>();</span><br><span class="line">            detail.setName(item.getName());</span><br><span class="line">            detail.setSpec(item.getSpec());</span><br><span class="line">            detail.setPrice(item.getPrice());</span><br><span class="line">            detail.setNum(numMap.get(item.getId()));</span><br><span class="line">            detail.setItemId(item.getId());</span><br><span class="line">            detail.setImage(item.getImage());</span><br><span class="line">            detail.setOrderId(orderId);</span><br><span class="line">            details.add(detail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> details;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-数据库"><a href="#2-6-数据库" class="headerlink" title="2.6.数据库"></a>2.6.数据库</h2><p>trade-service也需要自己的独立的database，向MySQL中导入课前资料提供的SQL：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712160.png" alt="img"></p><p>导入结果如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712351.png" alt="img"></p><h2 id="2-7-配置启动项"><a href="#2-7-配置启动项" class="headerlink" title="2.7.配置启动项"></a>2.7.配置启动项</h2><p>给trade-service配置启动项，设置profile为local：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712368.png" alt="img"></p><h2 id="2-8-测试"><a href="#2-8-测试" class="headerlink" title="2.8.测试"></a>2.8.测试</h2><p>启动TradeApplication，访问<a href="http://localhost:8085/doc.html#/default/%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3/queryOrderByIdUsingGET">http://localhost:8085/doc.html</a>，测试查询订单接口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091712840.png" alt="img"></p><p>请求参数：1654779387523936258，交易服务测试通过。</p><p>注意，创建订单接口无法测试，因为无法获取登录用户信息。</p><h1 id="3-支付服务"><a href="#3-支付服务" class="headerlink" title="3.支付服务"></a>3.支付服务</h1><h2 id="3-1-创建项目"><a href="#3-1-创建项目" class="headerlink" title="3.1.创建项目"></a>3.1.创建项目</h2><p>在<code>hmall</code>下新建一个module，命名为<code>pay-service</code>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713014.png" alt="img"></p><h2 id="3-2-依赖"><a href="#3-2-依赖" class="headerlink" title="3.2.依赖"></a>3.2.依赖</h2><p><code>pay-service</code>的<code>pom.xml</code>文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pay-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--api--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-启动类"><a href="#3-3-启动类" class="headerlink" title="3.3.启动类"></a>3.3.启动类</h2><p>在pay-service中的<code>com.hmall.pay</code>包下创建启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.hmall.pay.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-配置文件"><a href="#3-4-配置文件" class="headerlink" title="3.4.配置文件"></a>3.4.配置文件</h2><p>从<code>hm-service</code>项目中复制3个yaml配置文件到<code>trade-service</code>的<code>resource</code>目录。</p><p>其中<code>application-dev.yaml</code>和<code>application-local.yaml</code>保持不变。<code>application.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pay-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;hm.db.host&#125;:3306/hm-pay?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.170</span><span class="number">.10</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">支付服务接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;支付服务接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.pay.controller</span></span><br></pre></td></tr></table></figure><h2 id="3-5-代码"><a href="#3-5-代码" class="headerlink" title="3.5.代码"></a>3.5.代码</h2><h3 id="3-5-1-基础代码"><a href="#3-5-1-基础代码" class="headerlink" title="3.5.1.基础代码"></a>3.5.1.基础代码</h3><p>复制hm-service中所有与支付有关的代码，最终项目结构如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101148651.png" alt="image-20240710114829555"></p><p>在支付服务中，基于用户余额支付时需要做下列事情：</p><ul><li><strong>扣减用户余额</strong></li><li>标记支付单状态为已支付</li><li><strong>标记订单状态为已支付</strong></li></ul><p>其中，<strong>扣减用户余额</strong>是在<code>user-service</code>中有相关功能；<strong>标记订单状态</strong>则是在<code>trade-service</code>中有相关功能。因此交易服务要调用他们，必须通过OpenFeign远程调用。我们需要将上述功能抽取为FeignClient.</p><h3 id="3-5-2-抽取UserClient接口"><a href="#3-5-2-抽取UserClient接口" class="headerlink" title="3.5.2.抽取UserClient接口"></a>3.5.2.抽取UserClient接口</h3><p>首先是<strong>扣减用户余额</strong>，在<code>user-service</code>中的对应业务接口如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713093.png" alt="img"></p><p>我们将这个接口抽取到<code>hm-api</code>模块的<code>com.hmall.api.client.UserClient</code>中:</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713219.png" alt="img"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/users/money/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">(<span class="meta">@RequestParam(&quot;pw&quot;)</span> String pw,<span class="meta">@RequestParam(&quot;amount&quot;)</span> Integer amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-抽取TradeClient接口"><a href="#3-5-3-抽取TradeClient接口" class="headerlink" title="3.5.3.抽取TradeClient接口"></a>3.5.3.抽取TradeClient接口</h3><p>接下来是<strong>标记订单状态</strong>，在<code>trade-service</code>中的对应业务接口如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713473.png" alt="img"></p><p>我们将这个接口抽取到<code>hm-api</code>模块的<code>com.hmall.api.client.TradeClient</code>中:</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713839.png" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;trade-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TradeClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-4-改造PayOrderServiceImpl"><a href="#3-5-4-改造PayOrderServiceImpl" class="headerlink" title="3.5.4.改造PayOrderServiceImpl"></a>3.5.4.改造PayOrderServiceImpl</h3><p>接下来，就可以改造<code>PayOrderServiceImpl</code>中的逻辑，将本地方法调用改造为基于<code>FeignClient</code>的调用，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.pay.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.IdWorker;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.TradeClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.UserClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.exception.BizIllegalException;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.UserContext;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.domain.dto.PayApplyDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.domain.dto.PayOrderFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.domain.po.PayOrder;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.enums.PayStatus;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.mapper.PayOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmall.pay.service.IPayOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 支付订单 服务实现类</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;PayOrderMapper, PayOrder&gt; <span class="keyword">implements</span> <span class="title class_">IPayOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TradeClient tradeClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">applyPayOrder</span><span class="params">(PayApplyDTO applyDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.幂等性校验</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> checkIdempotent(applyDTO);</span><br><span class="line">        <span class="comment">// 2.返回结果</span></span><br><span class="line">        <span class="keyword">return</span> payOrder.getId().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderFormDTO payOrderDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询支付单</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">        <span class="comment">// 2.判断状态</span></span><br><span class="line">        <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">            <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">        userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">        <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.修改订单状态</span></span><br><span class="line">        tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markPayOrderSuccess</span><span class="params">(Long id, LocalDateTime successTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lambdaUpdate()</span><br><span class="line">                .set(PayOrder::getStatus, PayStatus.TRADE_SUCCESS.getValue())</span><br><span class="line">                .set(PayOrder::getPaySuccessTime, successTime)</span><br><span class="line">                .eq(PayOrder::getId, id)</span><br><span class="line">                <span class="comment">// 支付状态的乐观锁判断</span></span><br><span class="line">                .in(PayOrder::getStatus, PayStatus.NOT_COMMIT.getValue(), PayStatus.WAIT_BUYER_PAY.getValue())</span><br><span class="line">                .update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayOrder <span class="title function_">checkIdempotent</span><span class="params">(PayApplyDTO applyDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.首先查询支付单</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">oldOrder</span> <span class="operator">=</span> queryByBizOrderNo(applyDTO.getBizOrderNo());</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (oldOrder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不存在支付单，说明是第一次，写入新的支付单并返回</span></span><br><span class="line">            <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> buildPayOrder(applyDTO);</span><br><span class="line">            payOrder.setPayOrderNo(IdWorker.getId());</span><br><span class="line">            save(payOrder);</span><br><span class="line">            <span class="keyword">return</span> payOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.旧单已经存在，判断是否支付成功</span></span><br><span class="line">        <span class="keyword">if</span> (PayStatus.TRADE_SUCCESS.equalsValue(oldOrder.getStatus())) &#123;</span><br><span class="line">            <span class="comment">// 已经支付成功，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;订单已经支付！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.旧单已经存在，判断是否已经关闭</span></span><br><span class="line">        <span class="keyword">if</span> (PayStatus.TRADE_CLOSED.equalsValue(oldOrder.getStatus())) &#123;</span><br><span class="line">            <span class="comment">// 已经关闭，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;订单已关闭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.旧单已经存在，判断支付渠道是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(oldOrder.getPayChannelCode(), applyDTO.getPayChannelCode())) &#123;</span><br><span class="line">            <span class="comment">// 支付渠道不一致，需要重置数据，然后重新申请支付单</span></span><br><span class="line">            <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> buildPayOrder(applyDTO);</span><br><span class="line">            payOrder.setId(oldOrder.getId());</span><br><span class="line">            payOrder.setQrCodeUrl(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            updateById(payOrder);</span><br><span class="line">            payOrder.setPayOrderNo(oldOrder.getPayOrderNo());</span><br><span class="line">            <span class="keyword">return</span> payOrder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.旧单已经存在，且可能是未支付或未提交，且支付渠道一致，直接返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> oldOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PayOrder <span class="title function_">buildPayOrder</span><span class="params">(PayApplyDTO payApplyDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.数据转换</span></span><br><span class="line">        <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> BeanUtils.toBean(payApplyDTO, PayOrder.class);</span><br><span class="line">        <span class="comment">// 2.初始化数据</span></span><br><span class="line">        payOrder.setPayOverTime(LocalDateTime.now().plusMinutes(<span class="number">120L</span>));</span><br><span class="line">        payOrder.setStatus(PayStatus.WAIT_BUYER_PAY.getValue());</span><br><span class="line">        payOrder.setBizUserId(UserContext.getUser());</span><br><span class="line">        <span class="keyword">return</span> payOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> PayOrder <span class="title function_">queryByBizOrderNo</span><span class="params">(Long bizOrderNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lambdaQuery()</span><br><span class="line">                .eq(PayOrder::getBizOrderNo, bizOrderNo)</span><br><span class="line">                .one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-数据库"><a href="#3-6-数据库" class="headerlink" title="3.6.数据库"></a>3.6.数据库</h2><p><code>pay-service</code>也需要自己的独立的database，向MySQL中导入课前资料提供的SQL：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407101150967.png" alt="image-20240710115043860"></p><p>导入结果如下：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713737.png" alt="img"></p><h2 id="3-7-配置启动项"><a href="#3-7-配置启动项" class="headerlink" title="3.7.配置启动项"></a>3.7.配置启动项</h2><p>给<code>pay-service</code>配置启动项，设置profile为<code>local</code>：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713041.png" alt="img"></p><h2 id="3-8-测试"><a href="#3-8-测试" class="headerlink" title="3.8.测试"></a>3.8.测试</h2><p>在支付服务的PayController中添加一个接口方便测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;查询支付单&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PayOrderVO&gt; <span class="title function_">queryPayOrders</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyList(payOrderService.list(), PayOrderVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动PayApplication，访问<a href="http://localhost:8086/doc.html#/default/%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/queryPayOrdersUsingGET">http://localhost:8086/doc.html</a>，测试查询订单接口：</p><p><img src="https://gitee.com/BennettG6/image-bed/raw/master/img/202407091713503.png" alt="img"></p><p>支付服务测试通过。</p>]]></content>
    
    
    <summary type="html">java自用学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="java" scheme="https://bennettgao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>解决引入sentinel依赖时与web依赖形成循环依赖的问题</title>
    <link href="https://bennettgao.github.io/2024/06/02/%E8%A7%A3%E5%86%B3%E5%BC%95%E5%85%A5sentinel%E4%BE%9D%E8%B5%96%E6%97%B6%E4%B8%8Eweb%E4%BE%9D%E8%B5%96%E5%BD%A2%E6%88%90%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://bennettgao.github.io/2024/06/02/%E8%A7%A3%E5%86%B3%E5%BC%95%E5%85%A5sentinel%E4%BE%9D%E8%B5%96%E6%97%B6%E4%B8%8Eweb%E4%BE%9D%E8%B5%96%E5%BD%A2%E6%88%90%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-06-02T09:15:32.186Z</published>
    <updated>2024-08-06T09:46:16.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决引入sentinel依赖时与web依赖形成循环依赖的问题"><a href="#解决引入sentinel依赖时与web依赖形成循环依赖的问题" class="headerlink" title="解决引入sentinel依赖时与web依赖形成循环依赖的问题"></a>解决引入sentinel依赖时与web依赖形成循环依赖的问题</h1><p>最近在学习黑马的微服务课程，在学到Sentinel并引入相关依赖时发现出现了SentinelWebAutoConfiguration循环依赖的异常，在此小小记录一下解决问题方法：</p><p>在学习黑马微服务课程微服务保护机制，在购物车模块引入Sentinel的依赖，在重启微服务的过程中，出现如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">The dependencies of some of the beans in the application context form a cycle:</span><br><span class="line"></span><br><span class="line">   cartController defined in file [D:\JavaFrameworkAndProjectExercises\hmall\cart-sevice\target\classes\com\hmall\cart\controller\CartController.class]</span><br><span class="line">      ↓</span><br><span class="line">   cartServiceImpl</span><br><span class="line">      ↓</span><br><span class="line">   org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration</span><br><span class="line">┌─────┐</span><br><span class="line">|  com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration (field private java.util.Optional com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration.sentinelWebInterceptorOptional)</span><br><span class="line">└─────┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Relying upon circular references is discouraged and they are prohibited by default. Update your application to remove the dependency cycle between beans. As a last resort, it may be possible to break the cycle automatically by setting spring.main.allow-circular-references to true.</span><br></pre></td></tr></table></figure><p>这个错误提示表明在应用程序上下文中存在循环依赖。具体来说，‘cartController’ 依赖于 ‘cartServiceImpl’，而 ‘cartServiceImpl’ 又依赖于 ‘org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration$EnableWebMvcConfiguration’，形成了一个循环依赖关系。</p><p>为了解决这个问题，可以尝试以下方法：</p><ol><li><p>检查并更新您的代码，确保没有循环依赖。这可能涉及到重构代码、更改注入方式（例如使用构造函数注入代替字段注入）等。</p></li><li><p>如果问题是由库的特定版本引起的，尝试更新到较新的版本，看看问题是否得到解决。</p></li><li><p>禁用Sentinel的自动配置。在<code>application.properties</code>文件中添加以下行：</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.autoconfigure.exclude</span>=<span class="string">com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>或者在<code>application.yml</code>文件中添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>这将禁用Sentinel的自动配置，从而避免循环依赖的问题。但请注意，这也意味着将无法使用Sentinel的流量控制和熔断降级功能。</p><ol start="4"><li>作为最后的手段，可以设置<code>spring.main.allow-circular-references</code>属性为<code>true</code>，以允许循环引用。但是，请注意，这可能会导致难以调试的问题和意外的应用程序行为。在<code>application.properties</code>文件中添加以下行：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.main.allow-circular-references</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>或者在<code>application.yml</code>文件中添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-circular-references:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>​5.禁用Sentinel的过滤器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>在Spring Boot中，通过设置<code>spring.sentinel.filter.enabled</code>属性为<code>false</code>，可以禁用Sentinel的过滤器功能。这一配置直接影响到Sentinel的流量控制和熔断降级功能，因为这些特性通常依赖于过滤器来实施规则和管理流量。</p><p>最后这几种方法可能会对程序产生影响，或者会使Sentinel部分功能失效等，因此，都不是推荐的解决方案。</p><p><strong>最好考虑版本兼容性寻找SpringBoot、SpringCloud、Spring Cloud Alibaba对应版本，减少bug的产生</strong>。</p><p>以下是三者之间版本对应关系：</p><h2 id="SpringBoot、SpringCloud、Spring-Cloud-Alibaba版本对应"><a href="#SpringBoot、SpringCloud、Spring-Cloud-Alibaba版本对应" class="headerlink" title="SpringBoot、SpringCloud、Spring Cloud Alibaba版本对应"></a>SpringBoot、SpringCloud、Spring Cloud Alibaba版本对应</h2><p>由于 Spring Boot 3.0，Spring Boot 2.7~2.4 和 2.4 以下版本之间变化较大，目前企业级客户老项目相关 Spring Boot 版本仍停留在 Spring Boot 2.4 以下，为了同时满足存量用户和新用户不同需求，社区以 Spring Boot 3.0 和 2.4 分别为分界线，同时维护 2022.x、2021.x、2.2.x 三个分支迭代。如果不想跨分支升级，如需使用新特性，请升级为对应分支的新版本。 为了规避相关构建过程中的依赖冲突问题，可以通过 <a href="https://start.aliyun.com/">云原生应用脚手架</a> 进行项目创建。</p><h3 id="2022-x-分支"><a href="#2022-x-分支" class="headerlink" title="2022.x 分支"></a>2022.x 分支</h3><p>适配 Spring Boot 3.0，Spring Cloud 2022.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）： (注意，该分支 Spring Cloud Alibaba 版本命名方式进行了调整，未来将对应 Spring Cloud 版本，前三位为 Spring Cloud 版本，最后一位为扩展版本，比如适配 Spring Cloud 2022.0.0 版本对应的 Spring Cloud Alibaba 第一个版本为：2022.0.0.0，第个二版本为：2022.0.0.1，依此类推)</p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Spring Cloud Version</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>2022.0.0.0-RC2*</td><td>Spring Cloud 2022.0.0</td><td>3.0.2</td></tr><tr><td>2022.0.0.0-RC1</td><td>Spring Cloud 2022.0.0</td><td>3.0.0</td></tr></tbody></table><h3 id="2021-x-分支"><a href="#2021-x-分支" class="headerlink" title="2021.x 分支"></a>2021.x 分支</h3><p>适配 Spring Boot 2.4，Spring Cloud 2021.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）：</p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Spring Cloud Version</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>2021.0.5.0*</td><td>Spring Cloud 2021.0.5</td><td>2.6.13</td></tr><tr><td>2021.0.4.0</td><td>Spring Cloud 2021.0.4</td><td>2.6.11</td></tr><tr><td>2021.0.1.0</td><td>Spring Cloud 2021.0.1</td><td>2.6.3</td></tr><tr><td>2021.1</td><td>Spring Cloud 2020.0.1</td><td>2.4.2</td></tr></tbody></table><h3 id="2-2-x-分支"><a href="#2-2-x-分支" class="headerlink" title="2.2.x 分支"></a>2.2.x 分支</h3><p>适配 Spring Boot 为 2.4，Spring Cloud Hoxton 版本及以下的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）：</p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Spring Cloud Version</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>2.2.10-RC1*</td><td>Spring Cloud Hoxton.SR12</td><td>2.3.12.RELEASE</td></tr><tr><td>2.2.9.RELEASE</td><td>Spring Cloud Hoxton.SR12</td><td>2.3.12.RELEASE</td></tr><tr><td>2.2.8.RELEASE</td><td>Spring Cloud Hoxton.SR12</td><td>2.3.12.RELEASE</td></tr><tr><td>2.2.7.RELEASE</td><td>Spring Cloud Hoxton.SR12</td><td>2.3.12.RELEASE</td></tr><tr><td>2.2.6.RELEASE</td><td>Spring Cloud Hoxton.SR9</td><td>2.3.2.RELEASE</td></tr><tr><td>2.2.1.RELEASE</td><td>Spring Cloud Hoxton.SR3</td><td>2.2.5.RELEASE</td></tr><tr><td>2.2.0.RELEASE</td><td>Spring Cloud Hoxton.RELEASE</td><td>2.2.X.RELEASE</td></tr><tr><td>2.1.4.RELEASE</td><td>Spring Cloud Greenwich.SR6</td><td>2.1.13.RELEASE</td></tr><tr><td>2.1.2.RELEASE</td><td>Spring Cloud Greenwich</td><td>2.1.X.RELEASE</td></tr><tr><td>2.0.4.RELEASE(停止维护，建议升级)</td><td>Spring Cloud Finchley</td><td>2.0.X.RELEASE</td></tr><tr><td>1.5.1.RELEASE(停止维护，建议升级)</td><td>Spring Cloud Edgware</td><td>1.5.X.RELEASE</td></tr></tbody></table><h3 id="Spring-Cloud-Alibaba-组件版本关系"><a href="#Spring-Cloud-Alibaba-组件版本关系" class="headerlink" title="Spring Cloud Alibaba 组件版本关系"></a>Spring Cloud Alibaba 组件版本关系</h3><p>每个 Spring Cloud Alibaba 版本及其自身所适配的各组件对应版本如下表所示（注意，Spring Cloud <a href="https://so.csdn.net/so/search?q=Dubbo&spm=1001.2101.3001.7020">Dubbo</a> 从 2021.0.1.0 起已被移除出主干，不再随主干演进）：</p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Sentinel Version</th><th>Nacos Version</th><th>RocketMQ Version</th><th>Dubbo Version</th><th>Seata Version</th></tr></thead><tbody><tr><td>2022.0.0.0-RC2</td><td>1.8.6</td><td>2.2.1</td><td>4.9.4</td><td>~</td><td>1.7.0-native-rc2</td></tr><tr><td>2021.0.5.0</td><td>1.8.6</td><td>2.2.0</td><td>4.9.4</td><td>~</td><td>1.6.1</td></tr><tr><td>2.2.10-RC1</td><td>1.8.6</td><td>2.2.0</td><td>4.9.4</td><td>~</td><td>1.6.1</td></tr><tr><td>2022.0.0.0-RC1</td><td>1.8.6</td><td>2.2.1-RC</td><td>4.9.4</td><td>~</td><td>1.6.1</td></tr><tr><td>2.2.9.RELEASE</td><td>1.8.5</td><td>2.1.0</td><td>4.9.4</td><td>~</td><td>1.5.2</td></tr><tr><td>2021.0.4.0</td><td>1.8.5</td><td>2.0.4</td><td>4.9.4</td><td>~</td><td>1.5.2</td></tr><tr><td>2.2.8.RELEASE</td><td>1.8.4</td><td>2.1.0</td><td>4.9.3</td><td>~</td><td>1.5.1</td></tr><tr><td>2021.0.1.0</td><td>1.8.3</td><td>1.4.2</td><td>4.9.2</td><td>~</td><td>1.4.2</td></tr><tr><td>2.2.7.RELEASE</td><td>1.8.1</td><td>2.0.3</td><td>4.6.1</td><td>2.7.13</td><td>1.3.0</td></tr><tr><td>2.2.6.RELEASE</td><td>1.8.1</td><td>1.4.2</td><td>4.4.0</td><td>2.7.8</td><td>1.3.0</td></tr><tr><td>2021.1 or 2.2.5.RELEASE or 2.1.4.RELEASE or 2.0.4.RELEASE</td><td>1.8.0</td><td>1.4.1</td><td>4.4.0</td><td>2.7.8</td><td>1.3.0</td></tr><tr><td>2.2.3.RELEASE or 2.1.3.RELEASE or 2.0.3.RELEASE</td><td>1.8.0</td><td>1.3.3</td><td>4.4.0</td><td>2.7.8</td><td>1.3.0</td></tr><tr><td>2.2.1.RELEASE or 2.1.2.RELEASE or 2.0.2.RELEASE</td><td>1.7.1</td><td>1.2.1</td><td>4.4.0</td><td>2.7.6</td><td>1.2.0</td></tr><tr><td>2.2.0.RELEASE</td><td>1.7.1</td><td>1.1.4</td><td>4.4.0</td><td>2.7.4.1</td><td>1.0.0</td></tr><tr><td>2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE</td><td>1.7.0</td><td>1.1.4</td><td>4.4.0</td><td>2.7.3</td><td>0.9.0</td></tr><tr><td>2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE</td><td>1.6.3</td><td>1.1.1</td><td>4.4.0</td><td>2.7.3</td><td>0.7.1</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">java自用学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="java" scheme="https://bennettgao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>解决此错误:无法将apis(com.google.common.base.Predicate)应用于(java.util.function.Predicate)</title>
    <link href="https://bennettgao.github.io/2024/04/06/swagger%E6%8A%A5%E9%94%99/"/>
    <id>https://bennettgao.github.io/2024/04/06/swagger%E6%8A%A5%E9%94%99/</id>
    <published>2024-04-06T07:02:03.970Z</published>
    <updated>2024-08-05T14:41:17.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决此错误-无法将apis-com-google-common-base-Predicate-应用于-java-util-function-Predicate"><a href="#解决此错误-无法将apis-com-google-common-base-Predicate-应用于-java-util-function-Predicate" class="headerlink" title="解决此错误:无法将apis(com.google.common.base.Predicate)应用于(java.util.function.Predicate)"></a>解决此错误:无法将apis(com.google.common.base.Predicate)应用于(java.util.function.Predicate)</h1><p>在本篇博客中，我将分享我在完成黑马项目苍穹外卖导入knife4j依赖过程中遇到的报错。</p><p>通过这篇博客，希望能帮助到其他遇到相似问题的，并加深自对问题的理解解决能力</p><p>报错描述</p><p>apis(com.google.common.base.Predicate&lt;springfox.documentation.RequestHandler&gt;)’ in ‘springfox.documentation.spring.web.plugins.ApiSelectorBuilder’ cannot be applied to ‘(java.util.function.Predicate&lt;springfox.documentation.RequestHandler&gt;)</p><p>苍穹外卖提供的knife4j依赖如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置类如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">  public Docket docket() &#123;</span><br><span class="line">      ApiInfo apiInfo = new ApiInfoBuilder()</span><br><span class="line">              .title(&quot;苍穹外卖项目接口文档&quot;)</span><br><span class="line">              .version(&quot;2.0&quot;)</span><br><span class="line">              .description(&quot;苍穹外卖项目接口文档&quot;)</span><br><span class="line">              .build();</span><br><span class="line">      Docket docket = new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">              .apiInfo(apiInfo)</span><br><span class="line">              .select()</span><br><span class="line">              .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))</span><br><span class="line">              .paths(PathSelectors.any())</span><br><span class="line">              .build();</span><br><span class="line">      return docket;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在进行调试时发现这个依赖并未生效，访问doc.hmtl为404，想着可能是版本依赖问题，所以将版本改为了3.0.3，进行编译时</p><p>apis(RequestHandlerSelectors.basePackage(“com.sky.controller”))出现报错，apis(com.google.common.base.Predicate&lt;springfox.documentation.RequestHandler&gt;)’ in ‘springfox.documentation.spring.web.plugins.ApiSelectorBuilder’ cannot be applied to ‘(java.util.function.Predicate&lt;springfox.documentation.RequestHandler&gt;)传入参数与需要类型不一致导致，于是进行类型强转发现也没有用，于是查看pom.xml文件，发现导入了swagger2依赖，经过查询发现不能混合Springfox 2.9.2和knife4j依赖 -&gt;删除springfox启动程序，reload后成功启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>由于Knife4j 使用了 Java 8 函数库，而 springfox-swagger2 使用了 Guava 类库。在旧版本的 springfox-swagger2（例如2.9.2版本）中，<code>RequestHandlerSelectors.basePackage</code>方法期望传入<code>com.google.common.base.Predicate&lt;springfox.documentation.RequestHandler&gt;</code>而不是<code>java.util.function.Predicate&lt;springfox.documentation.RequestHandler&gt;</code>。</p><p>通过以上方法，成功解决了这个报错，并顺进行了接口调试。希望这个经验可以对你有所帮助，如果有任何疑问或其他解决方法欢迎在评论中！</p>]]></content>
    
    
    <summary type="html">解决此错误:无法将apis(com.google.common.base.Predicate)应用于(java.util.function.Predicate)</summary>
    
    
    
    <category term="java" scheme="https://bennettgao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的响应状态码</title>
    <link href="https://bennettgao.github.io/2024/01/11/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://bennettgao.github.io/2024/01/11/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2024-01-11T05:38:52.968Z</published>
    <updated>2024-08-06T09:50:37.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h2><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h2 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h2><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;200&#x3D;&#x3D;</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>&#x3D;&#x3D;404&#x3D;&#x3D;</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td>指示用户在给定时间内发送了<strong>太多请求</strong>（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>&#x3D;&#x3D;500&#x3D;&#x3D;</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p>]]></content>
    
    
    <summary type="html">自用学习笔记，欢迎学习与交流</summary>
    
    
    
    <category term="计算机网络" scheme="https://bennettgao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基础环境配置</title>
    <link href="https://bennettgao.github.io/2023/09/13/Linux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/"/>
    <id>https://bennettgao.github.io/2023/09/13/Linux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C/</id>
    <published>2023-09-13T00:22:18.444Z</published>
    <updated>2023-09-13T00:24:13.247Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1-切换为root用户"><a href="#1-切换为root用户" class="headerlink" title="1.切换为root用户"></a>1.切换为root用户</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@localhost ~]$ su -root</span><br></pre></td></tr></table></figure><h6 id="2-修改主机名"><a href="#2-修改主机名" class="headerlink" title="2.修改主机名"></a>2.修改主机名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]hostnamectl set-hostname master</span><br><span class="line">[root@localhost ~]bash</span><br><span class="line">[root@master ~]</span><br></pre></td></tr></table></figure><h6 id="3-静态网络配置"><a href="#3-静态网络配置" class="headerlink" title="3.静态网络配置"></a>3.静态网络配置</h6><p>1.查看ip地址的起始和结束地址</p><p><img src="https://img-blog.csdnimg.cn/73f221c91d834bb1ae62deb85e229bd9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5rGk5ZCM5a2mVFlU,size_12,color_FFFFFF,t_70,g_se,x_16#pic_left" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c974890da4d84d80bbcb9a7f8f674495.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5rGk5ZCM5a2mVFlU,size_11,color_FFFFFF,t_70,g_se,x_16#pic_left" alt="在这里插入图片描述"></p><p>2.修改网络配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br></pre></td></tr></table></figure><p>ip地址参照4步骤自行选择（必须在起始和结束的范围内）<br>子网掩码默认设置为255.255.255.0<br>网关的值为将ip地址中最后一段的值改为2<br>DNS使用谷歌提供的免费dns1：8.8.8.8</p><p><img src="D:\Desktop\Hadoop截图\Inked屏幕截图%202022-08-11%20113459.jpg"></p><p>3.重启网络服务，查看是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cc05b71850684ab6a03ea6c609f6fa2a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5rGk5ZCM5a2mVFlU,size_16,color_FFFFFF,t_70,g_se,x_16#pic_left"></p><h6 id="4-主机映射配置hosts文件"><a href="#4-主机映射配置hosts文件" class="headerlink" title="4.主机映射配置hosts文件"></a>4.主机映射配置hosts文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/153747e13bf945268275556851466207.png#pic_center" alt="在这里插入图片描述"></p><p>改为自己主机IP地址</p><h6 id="5-关闭防火墙（三台都要关闭）"><a href="#5-关闭防火墙（三台都要关闭）" class="headerlink" title="5.关闭防火墙（三台都要关闭）"></a>5.关闭防火墙（三台都要关闭）</h6><p>1.关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><p>2.关闭防火墙自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><p>3.查看防火墙状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# systemctl status firewalld.service</span><br></pre></td></tr></table></figure><h6 id="6-禁用SELinux"><a href="#6-禁用SELinux" class="headerlink" title="6.禁用SELinux"></a>6.禁用SELinux</h6><p>1.临时关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]#setenforce 0</span><br></pre></td></tr></table></figure><p>2.永久关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]#vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p>修改&#x2F;etc&#x2F;selinux目录下的config文件<br>将SELINUX&#x3D;enforcing改为SELINUX&#x3D;disabled</p><p><img src="https://img-blog.csdnimg.cn/20210318175524364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDA5MzM0Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述的"> <img src="https://img-blog.csdnimg.cn/20210318175637486.png" alt="在这里插入图片描述"></p><p> 然后重启服务器即可。</p><h6 id="7-ssh免密（实现远程登录和免密等率）"><a href="#7-ssh免密（实现远程登录和免密等率）" class="headerlink" title="7.ssh免密（实现远程登录和免密等率）"></a>7.ssh免密（实现远程登录和免密等率）</h6><p>1.生成公钥(三个主机同时进行)</p><p>切换为hadoop用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]#su - hadoop</span><br><span class="line">[hadoop@master ~]#ssh-keygen -t rsa -P &quot;&quot;</span><br></pre></td></tr></table></figure><p>2.把每一台的公钥拷贝到同一台虚拟机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@master ~]#ssh-copy-id -i ~/.ssh/id_rsa.pub masterIP地址   (root用户.ssh在root目录下)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210815173926689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUwNjMxNzgz,size_16,color_FFFFFF,t_70"></p><p>3.将有所有的公钥文件分别拷贝到另外两个节点（拷贝2个文件）</p><p>在master 上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@master ~]#scp -r ~/.ssh/authorized_keys hadoop@slave1:~/.ssh/</span><br><span class="line">[hadoop@master ~]#scp -r ~/.ssh/known_hosts hadoop@slave1:~/.ssh/</span><br><span class="line">[hadoop@master ~]#scp -r ~/.ssh/authorized_keys hadoop@slave2:~/.ssh/</span><br><span class="line">[hadoop@master ~]#scp -r ~/.ssh/known_hosts hadoop@slave2:~/.ssh/   </span><br></pre></td></tr></table></figure><p>4、测试免密是否成功</p><p>ssh 主机ip，不输密码就能登上就是成功 </p><p><img src="https://img-blog.csdnimg.cn/20210815175424491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUwNjMxNzgz,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <summary type="html">大数据平台搭载Linux基础环境配置</summary>
    
    
    
    <category term="大数据" scheme="https://bennettgao.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>java基础学习笔记</title>
    <link href="https://bennettgao.github.io/2023/08/21/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://bennettgao.github.io/2023/08/21/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-21T08:15:30.795Z</published>
    <updated>2023-09-12T12:05:11.291Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><meta name="referrer" content="no-referrer" /><h3 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h3><h4 id="Java-语言的产生、应用前景和特点；（了解）"><a href="#Java-语言的产生、应用前景和特点；（了解）" class="headerlink" title="Java 语言的产生、应用前景和特点；（了解）"></a>Java 语言的产生、应用前景和特点；（了解）</h4><p>Java语言是由Sun Microsystems公司于1995年推出的一种面向对象编程语言，其产生源于对嵌入式设备和网络应用的需求。Java拥有跨平台、高效性、安全性等优点，被广泛应用于Web开发、企业级应用开发、移动应用开发、游戏开发等领域。</p><p>Java语言的主要特点包括：</p><ol><li><p>跨平台性：Java代码在编译后生成字节码，可以在任何支持Java虚拟机（JVM）的平台上运行，实现了”一次编写，到处运行”。</p></li><li><p>面向对象：Java是一种纯粹的面向对象编程语言，所有的数据类型都是对象，所有的操作都是方法调用。</p></li><li><p>自动内存管理：Java具有内置的垃圾收集器，可以自动回收不再使用的内存空间，避免了C++中常见的内存泄漏问题。</p></li><li><p>强类型检查：Java程序在编译时会进行类型检查，避免了类型转换错误等运行时错误。</p></li><li><p>安全性：Java提供了丰富的安全机制，如字节码校验、安全管理器等，可以保证程序的安全性。</p></li><li><p>多线程支持：Java提供了高级的多线程支持库和同步机制，方便开发人员编写多线程程序。</p></li></ol><p>从目前的趋势来看，Java仍然是一种非常流行的编程语言，它的应用前景非常广泛。在企业级应用开发、Web应用开发、大数据处理、云计算等领域，Java都有着广泛的应用。同时，Java社区也非常活跃，涌现出了很多优秀的开源框架和工具，如Spring、Hibernate、Maven等，它们可以帮助开发人员更高效地进行开发，并提高了Java应用程序的质量。此外，由于移动互联网的普及，Java在移动应用开发领域也有不少的应用，如Android应用程序开发。</p><p>总之，Java作为一种强大、灵活、安全和跨平台的编程语言，具有广泛的应用前景，在各行业都有着较为广泛的应用需求。同时，由于其开源性质，Java社区中不断涌现出更多优秀的框架和工具，使得Java语言变得更加易于使用和学习。</p><h4 id="Java虚拟机及Java运行系统；（了解）"><a href="#Java虚拟机及Java运行系统；（了解）" class="headerlink" title="Java虚拟机及Java运行系统；（了解）"></a>Java虚拟机及Java运行系统；（了解）</h4><p>Java虚拟机（JVM）是一个可以执行Java字节码的虚拟计算机，负责将编译后的Java源代码转换成可执行的字节码，并提供了内存管理、垃圾回收、安全检查和动态链接等功能。JVM的核心是一个解释器和一个即时编译器，能够在运行时动态优化代码，提高应用程序的性能。</p><p>Java运行系统（JRE）是Java应用程序的运行环境，包括Java虚拟机、Java类库和其他运行所需的文件。JRE可以在不同的平台上运行Java程序，并且与操作系统相对独立，因此Java程序能够实现跨平台运行。</p><p>Java虚拟机和Java运行系统的结构如下：</p><ol><li><p>Java虚拟机由三个子系统组成：类加载器、运行时数据区和执行引擎。类加载器负责将编写好的Java代码加载到JVM中；运行时数据区包括方法区、堆、栈、本地方法栈和程序计数器等几个部分，用于存储Java对象、JVM执行状态和方法信息等；执行引擎则负责执行Java字节码。</p></li><li><p>Java运行系统包括两部分：JRE和Java开发工具包（JDK）。JRE是Java应用程序的运行环境，包括Java虚拟机、Java类库和其他运行所需的文件；而JDK则是Java开发人员的工具包，除了包含JRE之外，还包括编译器、调试器、文档生成器等开发工具，用于编写和调试Java程序。</p></li></ol><p>总之，Java虚拟机和Java运行系统是Java程序运行的基础，Java程序通过这些机制来实现跨平台运行，并提供了强大的内存管理、安全检查和动态链接等功能，极大地简化了Java应用程序的开发和部署。因此，Java虚拟机和Java运行系统是Java语言成功的关键所在，也是Java语言广泛应用于各个领域的重要原因之一。</p><h4 id="Java-语言和-C-语言的相同及不同之处；"><a href="#Java-语言和-C-语言的相同及不同之处；" class="headerlink" title="Java 语言和 C++语言的相同及不同之处；"></a>Java 语言和 C++语言的相同及不同之处；</h4><p>Java 和 C++ 都是面向对象的编程语言，它们在语法和基本概念上有些相似，例如类、继承、多态等。但是，两者之间还存在一些不同之处：</p><ol><li><p>平台依赖性：Java是跨平台的，因为Java程序不直接运行于操作系统，而是通过Java虚拟机（JVM）来执行，可以在任何支持JVM的平台上运行；而C++是与特定操作系统相关的，需要编译成对应平台的可执行文件。</p></li><li><p>内存管理：Java中的内存管理是由垃圾回收器负责的，开发人员无需手动分配或释放内存，避免了C++中常见的内存泄漏问题。</p></li><li><p>异常处理：Java支持异常处理机制，在出现异常时会抛出异常并进行处理，而C++中则使用try&#x2F;catch机制实现异常处理。</p></li><li><p>多线程：Java天生支持多线程编程，提供了高级的线程支持库和同步机制，方便开发人员编写多线程程序。C++也支持多线程编程，但需要使用操作系统提供的线程API和同步机制。</p></li><li><p>代码复杂度：相对于C++，Java的代码更容易阅读和理解，因为Java具有更简单的语法，同时也有更多的自动化功能，如垃圾回收等。</p></li></ol><p>总体来说，Java更适合开发大型企业级应用程序，尤其是网络应用程序，而C++更适合低层次系统编程和性能要求高的应用程序。</p><h4 id="Java-应用程序的编写、编译和运行过程。"><a href="#Java-应用程序的编写、编译和运行过程。" class="headerlink" title="Java 应用程序的编写、编译和运行过程。"></a>Java 应用程序的编写、编译和运行过程。</h4><p>Java应用程序的编写、编译和运行过程主要包括以下几个步骤：</p><ol><li><p>编写Java源代码：使用文本编辑器或IDE（集成开发环境）编写Java源代码，以.java为文件扩展名保存。</p></li><li><p>编译Java源代码：使用Java编译器将Java源代码编译成字节码，以.class为文件扩展名保存。在命令行窗口中，可以使用“javac”命令进行编译，例如：“javac HelloWorld.java”。</p></li><li><p>运行Java程序：使用Java虚拟机（JVM）来执行编译后的Java字节码文件，以.class为文件扩展名。在命令行窗口中，可以使用“java”命令来运行Java程序，例如：“java HelloWorld”。</p></li><li><p>测试和调试：通过单元测试、集成测试等方式对Java程序进行测试，如果出现问题，则需要进行调试和修复，在开发过程中反复进行上述步骤。</p></li></ol><p>总之，Java应用程序的编写、编译和运行过程是一个由多个步骤组成的过程，需要遵循一定的规范和标准。开发人员在编写Java程序时，需要熟悉Java语言和编程环境，并且注意代码的质量和性能。同时，Java社区中也有很多优秀的开源框架和工具，如Spring、Hibernate、Maven等，可以帮助开发人员更高效地进行开发，并提高了Java应用程序的质量。</p><h3 id="java语言基础"><a href="#java语言基础" class="headerlink" title="java语言基础"></a>java语言基础</h3><h4 id="数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）"><a href="#数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）" class="headerlink" title="数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）"></a>数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）</h4><p>数据类型的转换：</p><p>Java中有两种数据类型的转换：自动类型转换和强制类型转换。</p><ol><li><p>自动类型转换：当一种数据类型的值赋值给另一种数据类型时，如果目标类型可以容纳原始类型的数据，则会自动进行类型转换。例如，将int类型的值赋值给double类型的变量，编译器会自动将int类型转换为double类型。</p></li><li><p>强制类型转换：当需要将一个较大的数值类型转换成一个较小的数值类型时，需要使用强制类型转换。在强制类型转换时，需要在括号内指定要转换的数据类型。例如，将double类型的值转换为int类型的值，可以使用强制类型转换运算符，例如：“int a &#x3D; (int) 3.14”。<br><img src="https://img-blog.csdnimg.cn/20210429150845555.png" alt="在这里插入图片描述"></p></li></ol><p>运算符的优先级和结合性：</p><p>Java中有多种运算符，它们具有不同的优先级和结合性，可以通过以下规则来确定表达式的计算顺序：</p><ol><li><p>括号优先级最高，先计算括号内的表达式。</p></li><li><p>先计算高优先级的运算符，再计算低优先级的运算符。如果有相同优先级的运算符，则按照结合性从左到右或从右到左计算，例如“+”和“-”运算符的结合性是从左到右。</p></li><li><p>赋值运算符“&#x3D;”的优先级最低。</p></li></ol><p>下面是常见运算符的优先级从高到低的顺序：</p><p>以下是Java中常见的运算符优先级，按照从高到低的顺序排列：</p><table><thead><tr><th>运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td>() []</td><td align="center">括号，具有最高优先级，用于强制改变运算符的计算顺序</td></tr><tr><td>! ~ ++ – -</td><td align="center">一元运算符，包括取反、位非、自增、自减、负数等</td></tr><tr><td>* &#x2F; %</td><td align="center">乘法、除法、取模 new同级</td></tr><tr><td>+ -</td><td align="center">加法、减法</td></tr><tr><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td align="center">位移运算符，分别表示左移、右移、无符号右移</td></tr><tr><td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td align="center">关系运算符，用于比较两个值的大小关系</td></tr><tr><td>&#x3D;&#x3D; !&#x3D;</td><td align="center">等于、不等于</td></tr><tr><td>&amp;</td><td align="center">按位与</td></tr><tr><td>^</td><td align="center">按位异或</td></tr><tr><td>|</td><td align="center">按位或</td></tr><tr><td>&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td>||</td><td align="center">逻辑或</td></tr><tr><td>?:</td><td align="center">三目运算符，用于条件判断</td></tr><tr><td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</td><td align="center">赋值运算符，包括复合赋值运算符和位移赋值运算符</td></tr></tbody></table><p>在实际编程中，为了避免优先级和结合性引起的错误，建议使用括号来明确表达式的计算顺序。同时，也需要注意强制类型转换可能会导致数据丢失或溢出问题，需要进行适当的检查和处理。</p><h4 id="Java语言各种数据类型；"><a href="#Java语言各种数据类型；" class="headerlink" title="Java语言各种数据类型；"></a>Java语言各种数据类型；</h4><p>Java语言中有8种基本数据类型，可以分为4种整型、2种浮点型、1种字符型和1种布尔型。具体如下：</p><ol><li><p>整型（4种）：byte、short、int、long。</p></li><li><p>浮点型（2种）：float、double。</p></li><li><p>字符型（1种）：char。</p></li><li><p>布尔型（1种）：boolean。</p></li></ol><p>这些数据类型在Java中都是关键字，在程序中可以直接使用。各数据类型的范围和存储长度如下：</p><ol><li><p>byte：1字节，-128到127。</p></li><li><p>short：2字节，-32768到32767。</p></li><li><p>int：4字节，-2147483648到2147483647。</p></li><li><p>long：8字节，-9223372036854775808到9223372036854775807。</p></li><li><p>float：4字节，IEEE754标准表示的单精度浮点数。</p></li><li><p>double：8字节，IEEE754标准表示的双精度浮点数。</p></li><li><p>char：2字节，0到65535（Unicode编码）。</p></li><li><p>boolean：1位，true或false。</p></li></ol><p>可以根据需求选择不同的数据类型来存储数据，例如使用byte类型来存储文件内容，使用int类型来存储计数器等。同时，在进行数据类型转换时需要注意避免出现数据溢出或数据丢失的情况。</p><h4 id="Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；"><a href="#Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；" class="headerlink" title="Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；"></a>Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；</h4><p>Java语言中有多种运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符等。下面分别介绍这些运算符的功能及使用。</p><ol><li><p>算术运算符：用于处理数学运算，包括加减乘除、取余数等，常见的算术运算符有+、-、*、&#x2F;、%等。例如，a + b表示a与b的和，a % b表示a除以b的余数。</p></li><li><p>关系运算符：用于比较两个变量的关系，常见的关系运算符有&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;等。例如，a &gt; b表示a是否大于b，a &#x3D;&#x3D; b表示a是否等于b。</p></li><li><p>逻辑运算符：用于连接两个或多个表达式，常见的逻辑运算符有&amp;&amp;（与）、||（或）、！（非）等。例如，a &gt; b &amp;&amp; c &gt; d表示当a大于b并且c大于d时为真。</p></li><li><p>位运算符：用于对数据的二进制位进行操作，常见的位运算符有&amp;（按位与）、|（按位或）、^（按位异或）、~（按位取反）、&lt;&lt;（左移）、&gt;&gt;（右移）和&gt;&gt;&gt;（无符号右移）等。例如，a &amp; b表示将a和b按位与运算。</p></li><li><p>复合赋值运算符：用于简化赋值语句的编写，常见的复合赋值运算符有+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;、&gt;&gt;&gt;&#x3D;等。例如，a +&#x3D; b可以写成a &#x3D; a + b的形式。</p></li></ol><p>总之，Java语言中的各种运算符可帮助开发人员进行数学、逻辑和位运算，更高效地完成程序的设计和实现。在使用运算符时，需要注意数据类型的匹配和运算符的优先级和结合性，以避免出现错误的结果。同时，也可以通过括号来明确表达式的计算顺序，提高代码的可读性和可维护性。例如：</p><p><code>int a = 10, b = 3, c = 5; int result = (a + b) * c; // 使用括号明确计算顺序 System.out.println(result); // 输出65</code></p><p>另外还需要注意，在进行位运算时，需要特别小心因为这些运算是基于二进制表示的，如果使用不当可能会导致数据被修改或出现意外的结果。</p><h4 id="Java语言变量、常量的使用及其运算操作；"><a href="#Java语言变量、常量的使用及其运算操作；" class="headerlink" title="Java语言变量、常量的使用及其运算操作；"></a>Java语言变量、常量的使用及其运算操作；</h4><p>Java语言中，变量和常量是程序中存储数据的基本方式。下面分别介绍变量、常量的使用及其运算操作。</p><ol><li>变量：在程序中用于存储可变的数据值，需要先声明再使用，可以多次赋值。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a; // 声明变量a</span><br><span class="line"> a = 10; </span><br><span class="line">// 赋值为10</span><br><span class="line"> a = a + 5; </span><br><span class="line">// 加上5并重新赋值 </span><br><span class="line">System.out.println(a); // 输出15</span><br></pre></td></tr></table></figure><ol start="2"><li>常量：在程序中用于存储不可变的数据值，一旦被赋值就不能改变。通常使用关键字final来定义常量，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int MAX_VALUE = 100; // 定义一个常量</span><br><span class="line">//MAX_VALUE = 200; // 编译错误，无法更改常量的值 System.out.println(MAX_VALUE); // 输出100</span><br></pre></td></tr></table></figure><ol start="3"><li>运算操作：在Java中，变量和常量可以进行各种数学和逻辑运算，在使用运算符时需要注意数据类型的匹配和运算符的优先级和结合性。例如：</li></ol><p>java复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 3; double c = 5.0;</span><br><span class="line"> int result = a / b;</span><br><span class="line"> // 整型除法，result的值为3 double result2 = a / c;</span><br><span class="line"> // 自动类型转换为浮点型，result2的值为2.0 int result3 = a % b;</span><br><span class="line"> // 取余数操作，result3的值为1  boolean flag = true; if (flag &amp;&amp; (a &gt; b)) &#123; // 使用逻辑与运算符和关系运算符     System.out.println(&quot;a is greater than b&quot;); &#125;</span><br></pre></td></tr></table></figure><p>总之，变量和常量是Java程序中存储数据的基本方式，可以通过各种运算操作来实现程序的需求。在使用过程中，需要遵循命名规范和数据类型规范，以提高代码的可读</p><p>性和可维护性，同时也需要注意变量的作用域和生命周期等问题。</p><p>在进行数学运算时，需要注意整型除法可能会出现数据截断的问题，因此可以使用浮点型变量或强制类型转换来避免这些问题。另外，还需要注意整型溢出问题，当超出了数据类型所能表示的范围时，结果将不可预测。在使用常量时，建议使用大写字母和下划线来命名，以便于区分变量和常量。</p><h4 id="Java语言流程控制语句的功能及使用"><a href="#Java语言流程控制语句的功能及使用" class="headerlink" title="Java语言流程控制语句的功能及使用"></a>Java语言流程控制语句的功能及使用</h4><p>Java语言中，流程控制语句用于控制程序的执行顺序，可以根据条件选择不同的分支或者重复执行某些代码。下面分别介绍流程控制语句的功能及使用。</p><ol><li><p>if语句：用于根据特定条件执行不同的代码块，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">if (a &gt; b) &#123;</span><br><span class="line">    System.out.println(&quot;a is greater than b&quot;);</span><br><span class="line">&#125; else if (a &lt; b) &#123;</span><br><span class="line">    System.out.println(&quot;a is less than b&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;a is equal to b&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch语句：用于根据不同条件执行不同的代码块，比if语句更加简洁，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int dayOfWeek = 3;</span><br><span class="line">switch (dayOfWeek) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        System.out.println(&quot;Monday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        System.out.println(&quot;Tuesday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        System.out.println(&quot;Wednesday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;Other day&quot;);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for循环：用于对一段代码进行固定次数的重复执行，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while循环和do-while循环：用于在满足特定条件的情况下重复执行一段代码，其中while循环先检查条件再执行代码，而do-while循环先执行代码再检查条件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int j = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt; 10);</span><br></pre></td></tr></table></figure></li><li><p>break和continue语句：用于控制循环的执行，break语句可用于跳出循环，continue语句可用于跳过当前迭代并进入下一迭代，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break; // 跳出循环</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">    if (j % 2 == 0) &#123;</span><br><span class="line">        continue; // 跳过当前迭代</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>return语句：用于退出函数并返回一个值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throw语句：用于在程序中抛出异常，需要与try-catch语句一起使用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a &lt; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;a must be greater than 0&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总之，Java语言中的流程控制语句可以帮助开发人员根据条件选择执行不同的代码块或重复执行某些代码，从而实现程序的需求。在使用时需要注意语法和使用场景，以避免出现逻辑错误和性能问题。</p><h4 id="Java数组的定义；数组的初始化和数组的应用；二维数组的应用。"><a href="#Java数组的定义；数组的初始化和数组的应用；二维数组的应用。" class="headerlink" title="Java数组的定义；数组的初始化和数组的应用；二维数组的应用。"></a>Java数组的定义；数组的初始化和数组的应用；二维数组的应用。</h4><p>Java数组是一组相同数据类型的元素的集合，可以通过下标来访问和修改数组中的元素。下面分别介绍Java数组的定义、初始化和应用，以及二维数组的应用。</p><ol><li><p>数组的定义：在Java中，使用方括号[]来定义一个数组，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers; // 定义一个整型数组</span><br><span class="line">String[] names; // 定义一个字符串数组</span><br><span class="line">double[] prices; // 定义一个双精度浮点数数组</span><br></pre></td></tr></table></figure></li><li><p>数组的初始化：在Java中，可以使用大括号{}来初始化一个数组，也可以使用new关键字在堆上分配空间进行初始化，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;1, 2, 3&#125;; // 使用大括号初始化数组</span><br><span class="line">String[] names = new String[5]; // 在堆上分配空间并初始化为null</span><br><span class="line">double[] prices = new double[]&#123;1.0, 2.0, 3.0&#125;; // 使用new关键字和大括号初始化数组</span><br></pre></td></tr></table></figure><p>3.数组的应用：在Java中，可以使用下标来访问和修改数组中的元素，数组下标从0开始，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;1, 2, 3&#125;;</span><br><span class="line">System.out.println(numbers[0]); // 输出1</span><br><span class="line">numbers[1] = 4;</span><br><span class="line">System.out.println(numbers[1]); // 输出4</span><br><span class="line"></span><br><span class="line">//可以使用Arrays.toString()来输出一个完整数组</span><br><span class="line"> System.out.println(Arrays.toString(num));</span><br></pre></td></tr></table></figure><p>4.数组排序<br>（1）<strong>数组遍历查找最小值法</strong>是一种常用的查找数组中最小值的方法。其基本思路是使用循环遍历整个数组，通过比较每个元素的大小来找到数组中的最小值。<br>具体实现步骤如下：</p><ol><li>使用一个变量temp记录当前所遍历到的最小值，将数组中的第一个元素赋值给temp作为初始值；</li><li>使用for循环遍历数组中的每个元素，从第二个元素开始比较；</li><li>如果当前元素比temp小，则将当前元素赋值给temp，以更新最小值；</li><li>循环结束后，temp中存储的就是数组中的最小值。</li></ol><p>该方法简单易懂，适用于各种类型的数组，并且空间复杂度和时间复杂度都比较低，是一种常见的查找数组最小值的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;5, 2, 3, 4, 5,&#125;; //数组遍历查找最小值法</span><br><span class="line">        int temp = a[0];</span><br><span class="line">        for (int index = 1; index &lt; 5; index++) &#123;</span><br><span class="line">            if (a[index] &lt; temp) &#123;</span><br><span class="line">                temp=a[index];</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>（2）<strong>冒泡排序</strong>是一种简单的排序算法，它通过比较相邻元素的大小来重复地交换、移动数组中的元素，从而将一个无序的数组按照升序（或降序）排列。<br><img src="https://img-blog.csdnimg.cn/a78e034ed81343a1859783161a83f193.gif" alt="a78e034ed81343a1859783161a83f193"><br>找规律：总共比了4轮，轮数&#x3D;数组长度-1（arr.length-1）,<br>                  每轮比较的次数&#x3D;素组长度 — 轮数（arr.length-1-i），<br>   比较的轮数用一个for循环表示，每一轮里比较的次数用一个for循环表示，此处用双重for循环，<br><img src="https://img-blog.csdnimg.cn/4e744525a72247c1a091deacc3508ceb.png" alt="4e744525a72247c1a091deacc3508ceb"></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//排序算法——冒泡排序</span><br><span class="line">       int[] num=&#123;90,99,25,24,23,22&#125;;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; num.length - 1; i++) &#123;  //外层循环控制  轮数=数组长度-1（arr.length-1）</span><br><span class="line">           //内层循环控制元素两两比较的次数</span><br><span class="line">           //每轮比较的次数=素组长度 — 轮数（arr.length-1-i）</span><br><span class="line">           for (int j = 0; j &lt; num.length - 1 - i; j++) &#123;</span><br><span class="line">                //判断是否满足交换条件</span><br><span class="line">               if (num[j] &gt; num[j + 1]) &#123;</span><br><span class="line">                   //如果满足--交换两个元素的值</span><br><span class="line">                   int temp = num[j];</span><br><span class="line">                   num[j] = num[j + 1];</span><br><span class="line">                   num[j + 1] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.toString(num));</span><br></pre></td></tr></table></figure><p>   5.二维数组的应用：在Java中，可以使用二维数组来表示表格等结构化数据，二维数组可以看做是一个由数组构成的数组，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[][] matrix = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;</span><br><span class="line">System.out.println(matrix[0][1]); // 输出2</span><br><span class="line">matrix[1][0] = 5;</span><br><span class="line">System.out.println(matrix[1][0]); // 输出5</span><br><span class="line"></span><br><span class="line">//可以使用Arrays.deepToString()输出完整二维数组</span><br><span class="line">Arrays.deepToString(allScore)</span><br></pre></td></tr></table></figure><p>总之，Java数组是一种重要的数据结构，可以用于存储和处理一组相同类型的数据。在使用时需要注意数组下标从0开始、数组越界问题、数组的初始化和数组越界问题等，特别是在遍历数组时需要格外小心。另外，Java中还提供了大量的数组操作方法，如排序、查找、求和、复制等，可以大大简化数组的处理过程。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;3, 1, 4, 1, 5, 9&#125;;</span><br><span class="line">Arrays.sort(numbers); // 对数组进行排序</span><br><span class="line">int index = Arrays.binarySearch(numbers, 5); // 查找元素5的下标</span><br><span class="line">int sum = Arrays.stream(numbers).sum(); // 求和</span><br><span class="line">int[] copy = Arrays.copyOf(numbers, 3); // 复制前3个元素</span><br></pre></td></tr></table></figure><p>二维数组可以看做是一个由一维数组构成的数组，在使用时需要注意行列的顺序以及各维度的大小等问题。可以使用多重循环来遍历和处理二维数组，也可以使用流式API进行处理。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[][] matrix = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;</span><br><span class="line">for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">        System.out.println(matrix[i][j]); // 遍历二维数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum = Arrays.stream(matrix)</span><br><span class="line">                .flatMapToInt(Arrays::stream)</span><br><span class="line">                .sum(); // 使用流式API求和</span><br></pre></td></tr></table></figure><p>总之，Java数组是一个非常有用的数据结构，可以用于存储和处理一组相同类型的数据。在使用时需要注意数组下标从0开始、数组越界问题、多维数组的应用等问题，同时也可以使用大量的数组操作方法来简化处理过程.</p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="面向对象的概念（了解）"><a href="#面向对象的概念（了解）" class="headerlink" title="面向对象的概念（了解）"></a>面向对象的概念（了解）</h4><p>面向对象是一种程序设计的思想和方法，它将程序中的所有数据和操作都看做是一个对象，每个对象有自己的属性和行为，并且可以相互交互和协作。通过面向对象的方式，可以更加直观、灵活和可维护地实现程序逻辑。</p><p>在Java语言中，面向对象是一种基本的编程范式。面向对象的编程包括以下几个概念：</p><ol><li><p>类(class)：类是一种定义对象属性和行为的模板，可以看做是一种用户自定义的数据类型。每个类定义了对象的状态和行为，并提供了一组公共接口来访问和修改对象的状态。</p></li><li><p>对象(object)：对象是类的一个实例，具有类所定义的属性和行为。每个对象都具有独立的状态和行为，并可以与其他对象进行交互和协作。</p></li><li><p>方法(method)：方法是类中定义的用于执行特定任务的代码块，可以访问和修改对象的状态，并返回一个值或执行一些操作。</p></li><li><p>继承(inheritance)：继承是一种从一个类派生出新类的机制，新类可以继承原类的属性和方法，并可以添加自己的属性和方法。继承可以大大简化程序的设计和实现过程。</p></li><li><p>多态(polymorphism)：多态是一种在运行时选择不同实现的机制，允许使用相同的接口来访问不同的对象。多态可以提高程序的灵活性和可扩展性。</p></li><li><p>封装(encapsulation)：封装是一种将对象的状态和行为隐藏起来，只提供必要的接口供其他对象访问的机制。封装可以保证对象的安全性和稳定性。</p></li></ol><p>总之，面向对象是一种重要的编程思想和方法，它可以使程序更加清晰、灵活和可维护。在Java语言中，面向对象是一种基本的编程范式，包括类、对象、方法、继承、多态和封装等概念。通过面向对象的方式，可以将问题分解为更小的模块，并且可以更加直观地描述和实现系统的逻辑。同时，面向对象也可以提高程序的复用性、可扩展性和可测试性，从而大大提高程序的质量和效率。</p><p>在实践中，为了更好地应用面向对象的思想和方法，需要遵循一些设计原则和最佳实践。例如，单一职责原则(SRP)、开放封闭原则(OCP)、里氏替换原则(LSP)、依赖倒置原则(DIP)和接口隔离原则(ISP)等，这些原则可以帮助开发人员设计出更加优秀、可维护和可扩展的系统。另外，在Java中还有一些常用的设计模式，如工厂模式、单例模式、观察者模式等，这些模式可以在具体的场景中帮助开发人员更加高效地实现系统需求。</p><p>总之，面向对象是一种重要的编程思想和方法，可以使程序更加清晰、灵活和可维护。在Java语言中，面向对象是一种基本的编程范式，包括类、对象、方法、继承、多态和封装等概念，同时也需要遵循一些设计原则和最佳实践，以实现高质量的软件系统。</p><h4 id="类的创建与使用；"><a href="#类的创建与使用；" class="headerlink" title="类的创建与使用；"></a>类的创建与使用；</h4><p>在Java中，类是一种用户自定义的数据类型，它用于描述对象的属性和行为，并提供了一组公共接口来访问和修改对象的状态。下面介绍如何创建和使用Java类。</p><ol><li><p>类的创建：在Java中，可以使用关键字class来定义一个类，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个例子定义了一个名为Person的类，它具有两个私有属性name和age以及四个公共方法getName、setName、getAge和setAge。其中，构造函数用于创建对象，并初始化对象的状态</p><ol start="2"><li><p>对象的创建：在Java中，可以使用new关键字来创建一个对象，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person(&quot;Alice&quot;, 20);</span><br></pre></td></tr></table></figure></li></ol><p>这个例子创建了一个名为p的Person对象，并将其初始化为姓名为Alice、年龄为20。</p><ol start="3"><li><p>对象的使用：在Java中，使用点号(.)来访问和修改对象的属性和调用对象的方法，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = p.getName(); // 获取对象的姓名</span><br><span class="line">p.setAge(21); // 修改对象的年龄</span><br></pre></td></tr></table></figure></li><li><p>类的继承：在Java中，可以通过extends关键字来实现类的继承，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123;</span><br><span class="line">    private String major;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age, String major) &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMajor() &#123;</span><br><span class="line">        return major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMajor(String major) &#123;</span><br><span class="line">        this.major = major;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个例子定义了一个名为Student的类，它是Person类的子类，具有一个额外的属性major。在构造函数中，使用super关键字调用父类的构造函数来初始化姓名和年龄。</p><ol start="5"><li><p>对象的多态：在Java中，可以通过向上转型和方法重写等机制实现对象的多态性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Student(&quot;Bob&quot;, 22, &quot;Computer Science&quot;);</span><br><span class="line">String name = p.getName(); // 调用父类的方法</span><br></pre></td></tr></table></figure></li></ol><p>这个例子创建了一个名为p的Person对象，并将其指向一个Student对象。由于Student是Person的子类，因此可以向上转型为Person类型，并访问Person中定义的公共接口。</p><p>总之，在Java中，创建和使用类是一种基本的编程技能。需要熟悉类的定义、对象的创建和使用、继承和多态等概念，并遵循相关的设计原则和最佳实践，以实现高质量的软件系统。同时，在实践中还需要注意类的命名规范、属性的封装、方法的参数和返回值等问题，以保证程序的正确性和可维护性。</p><h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>方法是一段可重复调用的代码块，用于完成特定的任务。在程序中定义方法后，可以在需要的地方多次调用该方法，从而避免重复编写相同的代码。</p><p>方法通常由方法名、参数列表和方法体组成。方法名是唯一的标识符，描述了方法执行的任务。参数列表包含了传递给方法的参数，这些参数可以在方法体中使用。方法体是实现方法功能的代码块。</p><p>要使用一个方法，只需通过方法名和必要的参数调用它即可。方法的返回值可以用来提供操作结果或状态信息。</p><p>例如，下面是一个简单的Java方法，用于计算两个整数的和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int add(int x, int y) &#123; </span><br><span class="line"></span><br><span class="line">   return x + y</span><br><span class="line"></span><br><span class="line">;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在程序中，可以通过以下方式调用该方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result = add(2, 3);</span><br></pre></td></tr></table></figure><p>此时，result 的值将为 5，因为传递给 add 方法的两个参数分别为 2 和 3，方法计算它们的和并返回结果。</p><h4 id="对象的基本操作方式"><a href="#对象的基本操作方式" class="headerlink" title="对象的基本操作方式"></a>对象的基本操作方式</h4><p>对象是类的一个实例，通常用来表示现实世界中的某个实体或概念。在程序中，我们可以通过创建对象来操作它们的属性和方法，实现特定的功能。</p><p>以下是对象的基本操作方式：</p><ol><li><pre><code>创建对象：使用关键字“new”加上类名来创建一个对象，并将其赋值给一个变量。Person person = new Person();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   访问对象属性：使用点号（&quot;.&quot;）操作符来访问对象的属性。</span><br><span class="line">   String name = person.name;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>修改对象属性：使用点号（&quot;.&quot;）操作符来修改对象的属性。person.age = 25;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   调用对象方法：使用点号（&quot;.&quot;）操作符来调用对象的方法。</span><br><span class="line">   person.sayHello();</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>比较对象：可以使用“==”运算符来比较两个对象是否相等，或者使用对象的 equals 方法。if (person1 == person2) &#123;    System.out.println(&quot;They are the same person.&quot;);&#125;if (person1.equals(person2)) &#123;    System.out.println(&quot;They have the same name and age.&quot;);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 销毁对象：虽然Java有自动垃圾回收机制，但如果需要立即销毁一个对象，可以将其引用设置为 null，以便系统回收该对象的内存空间。</span><br><span class="line">   person = null;</span><br><span class="line"></span><br><span class="line">希望这些基本的对象操作能够帮助您更好地理解如何使用对象。</span><br><span class="line"></span><br><span class="line">#### 构造方法的定义和使用</span><br><span class="line"></span><br><span class="line">构造方法是一种特殊类型的方法，它用于在创建对象时初始化对象的属性。当我们使用“new”操作符来创建一个对象时，实际上就是调用了该类的构造方法。</span><br><span class="line"></span><br><span class="line">在Java中，构造方法与类名相同，并且没有返回类型。构造方法可以有参数，也可以没有参数。如果没有定义任何构造方法，则Java会自动提供一个无参构造方法（即默认构造方法）。</span><br><span class="line"></span><br><span class="line">下面是一个简单的Java构造方法的例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>public class Person &#123; private String name; private int age; public Person(String name, int age) &#123;     this.name = name;     this.age = age; &#125;</code></pre></li></ol><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中，Person 类有一个带有两个参数的构造方法，用于初始化对象的属性。当我们创建一个 Person 对象时，需要提供 name 和 age 两个参数。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Person person1 &#x3D; new Person(“Alice”, 25);<br>Person person2 &#x3D; new Person(“Bob”, 30);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在以上代码中，我们分别创建了 person1 和 person2 两个 Person 对象，并分别传递了不同的参数。这些参数被用于初始化相应对象的属性值。</span><br><span class="line"></span><br><span class="line">需要注意的是，构造方法的名称必须与类名相同，而且不能使用返回类型。构造方法可以重载，即在同一个类中可以定义多个具有不同参数的构造方法，以便满足不同的需求。</span><br><span class="line"></span><br><span class="line">希望这个例子能够帮助您了解如何定义和使用 Java 构造方法。</span><br><span class="line"></span><br><span class="line">#### this关键字使用</span><br><span class="line"></span><br><span class="line">在Java中，this关键字用于指代当前对象。可以使用this关键字访问当前对象的属性、方法或者构造函数。this关键字经常被用于以下情况：</span><br><span class="line"></span><br><span class="line">1. 引用当前对象的成员变量</span><br><span class="line"></span><br><span class="line">在类的实例方法中，可以使用this关键字来引用当前对象的成员变量。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Person {<br>    private String name;</p><pre><code>public void setName(String name) &#123;    this.name = name;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，使用了this关键字来引用当前对象的name属性。</span><br><span class="line"></span><br><span class="line">2. 调用当前对象的其他方法</span><br><span class="line"></span><br><span class="line">在类的某个实例方法中，可以使用this关键字来调用该对象的其他方法。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Person {<br>    public void sayHello() {<br>        System.out.println(“Hello”);<br>    }</p><pre><code>public void sayHi() &#123;    this.sayHello(); // 调用当前对象的sayHello方法&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，在sayHi方法中使用了this关键字来调用当前对象的sayHello方法。</span><br><span class="line"></span><br><span class="line">3. 在构造函数中调用其他构造函数</span><br><span class="line"></span><br><span class="line">在一个类的构造函数中，可以使用this关键字来调用该类的其他构造函数。这种方式称为构造函数的重载。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Person {<br>    private String name;<br>    private int age;</p><pre><code>public Person() &#123;    this(&quot;&quot;, 0); // 调用另一个构造函数&#125;public Person(String name, int age) &#123;    this.name = name;    this.age = age;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，定义了两个构造函数。第一个构造函数不带参数，当创建Person对象时会自动调用该构造函数。在该构造函数中使用了this关键字来调用另一个构造函数。</span><br><span class="line"></span><br><span class="line">#### static关键字使用</span><br><span class="line"></span><br><span class="line">在Java中，static关键字用于定义静态变量、静态方法和静态代码块。被static修饰的成员属于类而非实例化对象，可以通过类名直接访问，不需要先创建对象。</span><br><span class="line"></span><br><span class="line">1. 静态变量</span><br><span class="line"></span><br><span class="line">静态变量是类级别的变量，被该类的所有对象所共享，通常用于记录某个类的全局状态。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Person {<br>    public static int count;</p><pre><code>public Person() &#123;    count++;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个静态变量count，它的初始值为0。每当创建Person对象时，会自动调用构造函数，并将count加1。</span><br><span class="line"></span><br><span class="line">2. 静态方法</span><br><span class="line"></span><br><span class="line">静态方法也是类级别的方法，可以直接通过类名来调用，不需要先创建实例化对象。静态方法不能访问非静态成员，因为非静态成员的存在依赖于具体的对象。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class MathUtil {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个静态方法add，用于计算两个整数的和。该方法可以直接通过类名来调用，例如MathUtil.add(1, 2)。</span><br><span class="line"></span><br><span class="line">3. 静态代码块</span><br><span class="line"></span><br><span class="line">静态代码块是在类加载时执行的一段代码块，用于初始化静态变量或其他操作。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class MyClass {<br>    private static int count;<br>    static {<br>        count &#x3D; 0;<br>    }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个静态变量count和一个静态代码块，用于将count的初始值设为0。</span><br><span class="line"></span><br><span class="line">#### 成员变量和局部变量的区别</span><br><span class="line"></span><br><span class="line">成员变量和局部变量是Java中两种不同的变量类型，它们有以下区别：</span><br><span class="line"></span><br><span class="line">1. 定义位置</span><br><span class="line"></span><br><span class="line">成员变量定义在类中，而局部变量定义在代码块、方法或构造函数中。</span><br><span class="line"></span><br><span class="line">2. 生命周期</span><br><span class="line"></span><br><span class="line">成员变量的生命周期与对象相同，即只有在创建对象时才会被初始化，并且在对象被销毁时才会被销毁。而局部变量的生命周期仅限于所在的代码块、方法或构造函数的执行过程中。</span><br><span class="line"></span><br><span class="line">3. 访问权限</span><br><span class="line"></span><br><span class="line">成员变量可以被类中的其他方法和对象访问，而局部变量只能在其所在的代码块、方法或构造函数中访问。</span><br><span class="line"></span><br><span class="line">4. 初始化</span><br><span class="line"></span><br><span class="line">成员变量可以自动初始化，如果没有显式地为其赋初始值，则会被赋予默认值（如int类型的默认值为0）。而局部变量必须显式地进行初始化，否则编译器会提示错误。</span><br><span class="line"></span><br><span class="line">5. 存储方式</span><br><span class="line"></span><br><span class="line">成员变量存储在堆内存中的对象中，而局部变量存储在栈内存中。</span><br><span class="line"></span><br><span class="line">总之，成员变量和局部变量在定义位置、生命周期、访问权限、初始化和存储方式等方面都存在一些差异，需要根据具体需求选用合适的变量类型。</span><br><span class="line"></span><br><span class="line">### 面向对象的特性</span><br><span class="line"></span><br><span class="line">#### 封装的概念</span><br><span class="line"></span><br><span class="line">封装是面向对象编程中的一个重要概念，指的是将一个对象的属性和行为都隐藏在对象内部，对外只提供必要的接口，从而保证数据的安全性和代码的稳定性。</span><br><span class="line"></span><br><span class="line">封装包括两个方面：访问控制和方法暴露。访问控制指的是控制对象属性的访问权限，可以使用private、protected、public等关键字进行修饰，使得只有需要访问该属性的方法才能够访问它，其他方法或类无法访问。方法暴露则指的是设计良好的公共方法，通过这些公共方法来访问对象的属性和行为，而不是直接访问属性或调用对象的方法。</span><br><span class="line"></span><br><span class="line">封装的好处：</span><br><span class="line"></span><br><span class="line">1. 提高安全性：封装可以隐藏数据的实现细节，防止外部破坏或者误操作导致数据错误或程序故障。</span><br><span class="line"></span><br><span class="line">2. 简化编程：封装可以简化编程，封装对象的功能，减少代码复杂度，降低了编程的难度。</span><br><span class="line"></span><br><span class="line">3. 提高重用性：封装使得实现细节不可见，对外只提供接口，可以降低代码之间的耦合度，提高代码的重用性。</span><br><span class="line"></span><br><span class="line">4. 方便修改和维护：封装可以将变化隔离，使得修改某一部分的实现不影响其他部分，利于程序的维护。</span><br><span class="line"></span><br><span class="line">总之，封装是面向对象编程中很重要的概念，能够提高代码的质量和可维护性，使得程序更加健壮和可靠</span><br><span class="line"></span><br><span class="line">#### 继承的概念</span><br><span class="line"></span><br><span class="line">继承是面向对象编程中的一个重要概念，指的是基于已有类创建新类的过程。子类（派生类）可以继承父类（基类、超类）的属性和方法，同时还可以在此基础上添加新的属性和方法。</span><br><span class="line"></span><br><span class="line">继承是一种代码复用的机制，通过继承可以避免重复编写代码，提高了代码的可维护性和重用性。同时，继承也是实现多态的基础，在继承关系中，子类可以替换掉父类，从而产生不同的行为。</span><br><span class="line"></span><br><span class="line">在Java中，使用extends关键字来实现继承，例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Person {<br>    private String name;<br>    private int age;</p><pre><code>// 构造函数public Person(String name, int age) &#123;    this.name = name;    this.age = age;&#125;// getter和setter方法public String getName() &#123;    return name;&#125;public void setName(String name) &#123;    this.name = name;&#125;public int getAge() &#123;    return age;&#125;public void setAge(int age) &#123;    this.age = age;&#125;</code></pre><p>}</p><p>&#x2F;&#x2F; Student类继承自Person类<br>public class Student extends Person {<br>    private String school;</p><pre><code>// Student类的构造函数public Student(String name, int age, String school) &#123;    super(name, age); // 调用父类的构造函数    this.school = school;&#125;// 新增的getter和setter方法public String getSchool() &#123;    return school;&#125;public void setSchool(String school) &#123;    this.school = school;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个Person类和一个Student类，Student类继承自Person类。在其中，Student类除了继承了Person类的所有属性和方法之外，还新增了一个school属性和相应的getter/setter方法。</span><br><span class="line"></span><br><span class="line">总之，继承是面向对象编程中很</span><br><span class="line"></span><br><span class="line">重要的概念，它可以帮助我们避免重复编写代码，提高代码的可维护性和重用性。在使用继承时，需要注意以下几点：</span><br><span class="line"></span><br><span class="line">1. 父类的属性和方法都是默认继承的，但是如果父类中有private属性或方法，则子类无法访问。</span><br><span class="line"></span><br><span class="line">2. 子类可以覆盖父类的方法，即在子类中重新定义与父类同名的方法，并改变其实现方式。如果子类没有覆盖父类的方法，则调用该方法时会优先调用父类的实现。</span><br><span class="line"></span><br><span class="line">3. 子类可以新增属性和方法，并且可以在父类的基础上进行拓展。但是，子类新增的属性和方法不能被父类所使用。</span><br><span class="line"></span><br><span class="line">4. 在Java中，一个子类只能继承一个父类，但是一个类可以被多个子类继承，形成多层继承关系。</span><br><span class="line"></span><br><span class="line">5. 可以使用super关键字来调用父类的构造函数、属性和方法。</span><br><span class="line"></span><br><span class="line">总之，继承是面向对象编程中很重要的概念，通过继承可以实现代码复用、拓展功能等目的，同时需要注意继承的规范和合理性。</span><br><span class="line"></span><br><span class="line">#### 多态的概念</span><br><span class="line"></span><br><span class="line">多态是面向对象编程中的一个重要概念，指的是同一种行为或操作，对不同的对象有不同的解释或实现方式。简单来说，多态就是同一个接口，不同的实现。</span><br><span class="line"></span><br><span class="line">在Java中，多态性通过继承和接口实现。当子类继承父类或者实现了某个接口时，可以使用父类或者接口的引用来引用子类对象，从而实现多态性。</span><br><span class="line"></span><br><span class="line">例如，定义了一个动物类Animal和两个子类Dog和Cat：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Animal {<br>    public void makeSound() {<br>        System.out.println(“动物发出声音”);<br>    }<br>}</p><p>public class Dog extends Animal {<br>    @Override<br>    public void makeSound() {<br>        System.out.println(“狗吠叫”);<br>    }<br>}</p><p>public class Cat extends Animal {<br>    @Override<br>    public void makeSound() {<br>        System.out.println(“猫喵喵叫”);<br>    }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，所有的动物都可以发出声音，但是不同的动物有不同的叫声。这里使用方法重写（Override）实现了多态性。</span><br><span class="line"></span><br><span class="line">然后定义了一个测试类Test：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Test {<br>    public static void main(String[] args) {<br>        Animal animal1 &#x3D; new Dog();<br>        Animal animal2 &#x3D; new Cat();</p><pre><code>    animal1.makeSound(); // 输出：狗吠叫    animal2.makeSound(); // 输出：猫喵喵叫&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了两个Animal类型的引用变量animal1和animal2，并分别引用了Dog和Cat对象。调用它们的makeSound方法时，会分别输出狗吠叫和猫喵喵叫，这就是多态性的体现。</span><br><span class="line"></span><br><span class="line">总之，多态是面向对象编程中很重要的概念，它可以提高代码的灵活性、可维护性和重用性。通过多态，我们可以以最小的代价完成代码的拓展和修改，同时也更容易实现代码的复用。在使用多态时需要注意以下几点：</span><br><span class="line"></span><br><span class="line">1. 多态是基于继承和重写实现的，子类必须重写父类的方法。</span><br><span class="line"></span><br><span class="line">2. 多态时，引用变量类型应该为父类或者接口类型，而不是具体的子类类型。</span><br><span class="line"></span><br><span class="line">3. 在运行时，由JVM动态地确定调用的方法，这就要求被调用的方法必须存在于对象的实际类型中。</span><br><span class="line"></span><br><span class="line">总之，多态是面向对象编程中很重要的概念，它可以提高代码的灵活性、可维护性和重用性，同时需要注意多态的规范和合理性。</span><br><span class="line"></span><br><span class="line">#### final关键字的使用</span><br><span class="line"></span><br><span class="line"> 在Java中，final是一个修饰符，可以用于修饰变量、方法和类。下面分别介绍final关键字的使用：</span><br><span class="line"></span><br><span class="line">1. final变量</span><br><span class="line"></span><br><span class="line">final变量是一种常量，即其值不能被修改。如果在声明时没有进行初始化，则必须在构造函数中对其赋值。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class MyClass {<br>    private final int MAX_VALUE &#x3D; 100;</p><pre><code>public MyClass() &#123;    // 此处可以对MAX_VALUE重新赋值，但是只能赋值一次&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个final变量MAX_VALUE，它的值为100，无法被修改。</span><br><span class="line"></span><br><span class="line">2. final方法</span><br><span class="line"></span><br><span class="line">final方法是一种不能被重写的方法，即该方法在子类中不能被重写或覆盖。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Person {<br>    public final void sayHello() {<br>        System.out.println(“你好！”);<br>    }<br>}</p><p>public class Student extends Person {<br>    &#x2F;&#x2F; 无法重写Person类的sayHello方法<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，Person类的sayHello方法被定义为final方法，在Student类中无法进行重写。</span><br><span class="line"></span><br><span class="line">3. final类</span><br><span class="line"></span><br><span class="line">final类是一种不能被继承的类，即该类不能有子类。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public final class MyFinalClass {<br>    &#x2F;&#x2F; 类的内容<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，MyFinalClass类被定义为final类，无法被其他类所继承。</span><br><span class="line"></span><br><span class="line">总之，final关键字可以用于修饰变量、方法和类，分别表示常量、不能被重写或覆盖、不能被继承等含义。使用final关键字可以提高代码的安全性和稳定性，防止意外的修改或错误。</span><br><span class="line"></span><br><span class="line">#### Lambda表示式的使用</span><br><span class="line"></span><br><span class="line">Lambda表达式是Java 8引入的新特性，提供了一种更加简洁、高效的方式来编写代码。Lambda表达式可以看作是一种匿名方法，它没有名称、返回类型和修饰符等属性，但是可以被赋值给一个变量，也可以作为参数传递给方法。</span><br><span class="line"></span><br><span class="line">下面是Lambda表达式的基本语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(parameter1, parameter2, …) -&gt; {<br>    &#x2F;&#x2F; Lambda表达式的代码块<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中，parameter1、parameter2等表示Lambda表达式的参数列表，可以根据实际情况进行定义。箭头“-&gt;”表示Lambda表达式的分隔符，其前面是参数列表，后面是Lambda表达式的执行体，通常是一个代码块。</span><br><span class="line"></span><br><span class="line">Lambda表达式的使用需要满足以下两个条件：</span><br><span class="line"></span><br><span class="line">1. 函数接口：Lambda表达式只能作用于函数接口（Functional Interface），即只有一个抽象方法的接口。例如，Java中的Runnable和Comparator接口就是函数接口。</span><br><span class="line"></span><br><span class="line">2. 上下文推导：Lambda表达式的参数类型和返回类型可以由上下文自动推导出来，不需要显式地指定。</span><br><span class="line"></span><br><span class="line">下面是Lambda表达式的几个示例：</span><br><span class="line"></span><br><span class="line">1. 使用Lambda表达式实现Runnable接口：</span><br><span class="line">2. ```</span><br><span class="line">   Runnable r = () -&gt; &#123;</span><br><span class="line">       System.out.println(&quot;Hello, Lambda!&quot;);</span><br><span class="line">   &#125;;</span><br><span class="line">   Thread t = new Thread(r);</span><br><span class="line">   t.start();</span><br></pre></td></tr></table></figure><p>在上面的例子中，使用Lambda表达式定义了一个Runnable对象r，并在其执行体中输出了一条信息。然后将该对象赋值给Thread类的构造方法，创建一个线程并启动。</p><ol start="2"><li><p>使用Lambda表达式实现Comparator接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);</span><br><span class="line">Collections.sort(list, (first, second) -&gt; first.length() - second.length());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ol><p>在上面的例子中，使用Lambda表达式实现了Comparator接口的compare方法，根据字符串长度进行排序。使用Collections类的sort方法对字符串列表进行排序，并输出结果。</p><ol start="3"><li>使用Lambda表达式作为参数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void process(Runnable r) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line">process(() -&gt; System.out.println(&quot;Hello, Lambda!&quot;));</span><br></pre></td></tr></table></figure><p>在上面的例子中，定义了一个process方法，该方法接收一个Runnable对象作为参数，并执行其run方法。然后使用Lambda表达式作为参数，输出一条信息。</p><p>总之，Lambda表达式是Java 8引入的新特性，可以提高代码的简洁度和可读性，适用于函数接口的简单实现、匿名内部类的替代等场景。在使用Lambda表达式时需要注意上下文推导和函数接口的限制。</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="抽象类和接口的使用"><a href="#抽象类和接口的使用" class="headerlink" title="抽象类和接口的使用"></a>抽象类和接口的使用</h4><p>抽象类和接口是Java中两种重要的概念，它们都可以用于实现多态性和代码复用。</p><ol><li>抽象类</li></ol><p>抽象类是一种不能被实例化的类，其主要作用是为子类提供一个模板或者共同的行为。抽象类通过abstract关键字进行定义，其中定义了至少一个抽象方法，即没有实现体的方法。子类必须实现这些抽象方法才能被实例化。</p><p>以下是抽象类的一个简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">    public abstract void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;狗在吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;狗在奔跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，定义了一个抽象类Animal，其中包含了两个抽象方法eat和move，表示动物的基本行为。然后定义了一个Dog类，并继承自Animal类，实现了eat和move方法。</p><ol start="2"><li>接口</li></ol><p>接口是一种定义行为的规范，它定义了一组方法（包括默认方法和静态方法），但是没有实现体。接口通过interface关键字进行定义，可以被多个类实现。一个类可以实现多个接口，从而获得不同的行为。</p><p>以下是接口的一个简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    double getArea();</span><br><span class="line">    double getPerimeter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    private double radius;</span><br><span class="line"></span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double getArea() &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double getPerimeter() &#123;</span><br><span class="line">        return 2 * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，定义了一个Shape接口，其中定义了两个方法getArea和getPerimeter，表示形状的基本属性。然后定义了一个Circle类，并实现了Shape接口，实现了getArea和getPerimeter方法。</p><p>总之，抽象类和接口都是Java中重要的概念，它们可以用于实现多态性和代码复用。使用抽象类和接口需要注意以下几点：</p><ol><li><p>抽象类和接口都不能被实例化，只能被子类或者实现类继承或实现。</p></li><li><p>抽象类可以包含非抽象方法，而接口只能包含抽象方法、默认方法和静态方法。</p></li><li><p>子类必须实现抽象类中的所有抽象方法，否则子类也必须被声明为抽象类。实现类必须实现接口中的所有方法。</p></li><li><p>一个类可以继承一个抽象类并实现多个接口。</p></li><li><p>接口中的方法默认是public和abstract修饰的，而抽象类中的方法可以有不同的访问控制符和非抽象方法。</p></li></ol><p>总之，抽象类和接口都是面向对象编程中很重要的概念，它们可以帮助我们实现多态和代码复用等目的，同时需要注意抽象类和接口的规范和合理性。</p><h4 id="Java中的内部类"><a href="#Java中的内部类" class="headerlink" title="Java中的内部类"></a>Java中的内部类</h4><p>1.成员内部类是Java中的一种内部类，它定义在外部类的内部，并与外部类的成员变量和方法具有相同的访问权限。一个成员内部类可以使用public、protected、private或默认修饰符。</p><p>成员内部类可以访问外部类的私有成员和方法，而外部类也可以通过创建成员内部类对象来访问内部类的成员。成员内部类不能定义static变量或方法，但可以包含静态final常量。</p><p>要创建成员内部类对象，必须先创建外部类对象，然后使用外部类对象来创建内部类对象。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private int outerVar;</span><br><span class="line"></span><br><span class="line">    public class InnerClass &#123;</span><br><span class="line">        private int innerVar;</span><br><span class="line"></span><br><span class="line">        public InnerClass(int var) &#123;</span><br><span class="line">            this.innerVar = var;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;Outer variable: &quot; + outerVar);</span><br><span class="line">            System.out.println(&quot;Inner variable: &quot; + this.innerVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        InnerClass inner = new InnerClass(10);</span><br><span class="line">        inner.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个OuterClass外部类和一个InnerClass成员内部类。在test方法中，我们创建了一个InnerClass对象inner，并调用了它的print方法来打印outerVar和innerVar。注意，在InnerClass类中，我们可以直接访问outerVar变量。</p><p>2.静态内部类是Java中的一种内部类，它定义在外部类的内部，但必须使用static关键字修饰。静态内部类只能访问外部类的静态成员和方法，不能访问非静态成员。</p><p>静态内部类可以包含静态变量、静态方法和非静态成员变量，但不能包含非静态方法。静态内部类可以使用public、protected、private或默认修饰符。</p><p>要创建静态内部类对象，不需要先创建外部类对象。可以直接使用”外部类名.内部类名”的形式来创建静态内部类对象，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static int outerVar;</span><br><span class="line"></span><br><span class="line">    public static class InnerClass &#123;</span><br><span class="line">        private int innerVar;</span><br><span class="line"></span><br><span class="line">        public InnerClass(int var) &#123;</span><br><span class="line">            this.innerVar = var;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;Outer variable: &quot; + outerVar);</span><br><span class="line">            System.out.println(&quot;Inner variable: &quot; + this.innerVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建静态内部类对象</span><br><span class="line">OuterClass.InnerClass inner = new OuterClass.InnerClass(10);</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个OuterClass外部类和一个InnerClass静态内部类。注意，在InnerClass类中，我们只能访问outerVar静态变量。我们可以直接使用”OuterClass.InnerClass”的形式来创建静态内部类对象，而不需要先创建OuterClass对象。</p><p>3.局部内部类是Java中的一种内部类，它定义在方法或作用域块内部的类，只在定义它的方法或代码块内可见。局部内部类不能使用public、protected、private或static修饰符。</p><p>局部内部类可以访问外部类和外部方法（或代码块）的局部变量，但这些局部变量必须声明为final类型或者隐式地被final修饰。</p><p>要创建局部内部类对象，需要先创建外部类对象，然后通过外部类对象来创建内部类对象。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        final int outerVar = 10;</span><br><span class="line"></span><br><span class="line">        class InnerClass &#123;</span><br><span class="line">            private int innerVar;</span><br><span class="line"></span><br><span class="line">            public InnerClass(int var) &#123;</span><br><span class="line">                this.innerVar = var;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(&quot;Outer variable: &quot; + outerVar);</span><br><span class="line">                System.out.println(&quot;Inner variable: &quot; + this.innerVar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InnerClass inner = new InnerClass(20);</span><br><span class="line">        inner.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个OuterClass外部类和一个InnerClass局部内部类。在test方法中，我们创建了一个InnerClass对象inner，并调用了它的print方法来打印outerVar和innerVar。注意，在InnerClass类中，我们可以直接访问outerVar变量，但必须将它声明为final类型。</p><p>4.匿名内部类是Java中的一种内部类，它没有类名，通常用于简化代码。匿名内部类可以直接继承一个父类或实现一个接口。</p><p>匿名内部类不能有构造方法，但可以在定义时直接实例化并重写其中的方法。匿名内部类只能使用一次，因为无法对它进行引用，所以通常用于创建临时对象。匿名内部类也可以访问外部类的成员变量和方法。</p><p>例如，我们可以通过继承Thread类来创建一个匿名内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个Thread类的匿名内部类，并实现了它的run方法。然后我们调用了start方法来启动线程。注意，在匿名内部类中，我们可以直接访问外部类的成员变量和方法。</p><h4 id="单例模式（了解）"><a href="#单例模式（了解）" class="headerlink" title="单例模式（了解）"></a>单例模式（了解）</h4><p>单例模式是一种常用的设计模式，它保证一个类只有一个实例，并提供一个全局访问点。</p><p>单例模式通常有两种实现方式：</p><ol><li><p>饿汉式单例模式：在类加载时就创建实例对象，并提供一个公共的静态方法来获取这个唯一的实例。这种方式实现简单，线程安全，但可能会浪费系统资源。</p></li><li><p>懒汉式单例模式：在第一次使用时才创建实例对象，并提供一个公共的静态方法来获取这个唯一的实例。这种方式可以节省系统资源，但需要考虑线程安全问题。<br>下面是饿汉式单例模式的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在上面的例子中，我们将构造函数设为私有的，然后在类加载时就创建了一个Singleton实例，并提供了一个公共的静态方法getInstance来获取这个唯一的实例。由于instance被定义为final类型，所以它只能被赋值一次，从而保证了单例模式的实现。需要注意的是，在多线程环境下，饿汉式单例模式的实现是线程安全的，因为在类加载时就已经创建了实例对象，不需要考虑线程同步问题。</p><p>下面是懒汉式单例模式的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们将构造函数设为私有的，然后在getInstance方法中判断是否已经创建了Singleton实例，如果没有则创建一个实例并返回。由于getInstance方法被定义为synchronized类型，所以它能保证在多线程环境下只有一个线程能够进入该方法，从而避免了多个线程同时创建实例的问题。</p><p>需要注意的是，在高并发场景下，懒汉式单例模式的性能可能会受到影响。可以考虑使用双重检查锁定（Double-Checked Locking）或静态内部类等方式来优化单例模式的性能</p><h4 id="模板设计方法（了解）"><a href="#模板设计方法（了解）" class="headerlink" title="模板设计方法（了解）"></a>模板设计方法（了解）</h4><p>模板方法设计模式（Template Method Design Pattern）是一种基于继承的设计模式，它定义了一个算法框架，把一些步骤的实现留给子类来完成。</p><p>模板方法设计模式通常由两部分组成：抽象父类和具体子类。抽象父类提供了一个算法框架，其中包含了若干个抽象方法，这些抽象方法由子类来实现。具体子类继承了抽象父类，并重写其中的抽象方法，从而完成了算法中的具体步骤。</p><p>下面是模板方法设计模式的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">    public void templateMethod() &#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        step3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void step1();</span><br><span class="line"></span><br><span class="line">    protected abstract void step2();</span><br><span class="line"></span><br><span class="line">    protected abstract void step3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass extends AbstractClass &#123;</span><br><span class="line">    protected void step1() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: step1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void step2() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: step2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void step3() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: step3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractClass obj = new ConcreteClass();</span><br><span class="line">        obj.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个抽象类AbstractClass和一个具体子类ConcreteClass。在AbstractClass中，我们提供了一个templateMethod方法作为算法框架，并定义了三个抽象方法step1、step2和step3，这些抽象方法由具体子类来实现。在具体子类ConcreteClass中，我们重写了其中的三个抽象方法，并实现了具体的算法步骤。最后，在Main函数中，我们创建了ConcreteClass对象，并调用了它的templateMethod方法来执行算法。</p><p>需要注意的是，在模板方法设计模式中，抽象父类控制算法的流程和逻辑，而具体子类负责实现具体的步骤。这样可以避免在具体子类中重复编写相同的代码，提高了代码的复用性。</p><h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><h4 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h4><p>在Java中，异常（Exception）是程序运行时发生的意外情况，如：数组下标越界、空指针引用、文件不存在等。如果不加处理，这些异常可能会导致程序崩溃。</p><p>为了更好地处理异常，Java提供了异常处理机制。当程序运行时遇到异常，它会抛出一个异常对象，如果没有对这个异常进行处理，程序就会终止执行。可以使用try-catch语句来捕获并处理异常。try块中放置可能会引发异常的代码，catch块用于处理异常，通常包含错误信息的输出或者异常的修复代码。finally块中放置无论是否发生异常都需要执行的代码。</p><p><img src="https://img-blog.csdnimg.cn/548f0ac51a2c413a9032552d8603ea0f.png" alt="548f0ac51a2c413a9032552d8603ea0f"></p><p>在Java中，异常分为两种：受检异常（Checked Exception）和非受检异常（Unchecked Exception）。受检异常必须在方法签名中显式地声明，并且必须被捕获或者抛出，否则编译器将会报错。非受检异常通常由程序员编写代码时犯的逻辑错误或者系统环境的问题导致，如NullPointerException、ArrayIndexOutOfBoundsException等，编译器不会强制要求进行处理。</p><p>例如，以下是一个简单的异常处理示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int num1 = Integer.parseInt(args[0]);</span><br><span class="line">            int num2 = Integer.parseInt(args[1]);</span><br><span class="line">            int result = num1 / num2;</span><br><span class="line">            System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;End of program&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们尝试将命令行参数转换为整数，并计算它们的商。如果遇到异常，就通过catch块输出错误信息。无论是否发生异常，finally块中的代码都会被执行。</p><h4 id="异常的处理机制"><a href="#异常的处理机制" class="headerlink" title="异常的处理机制"></a>异常的处理机制</h4><h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><p>Java中的异常处理机制可以通过 try-catch-finally 语句块来实现。try块用于放置可能会抛出异常的代码，catch块用于捕获并处理抛出的异常，finally块用于放置无论是否发生异常都需要执行的代码。</p><p>下面是一个使用try-catch-finally语句块处理异常的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 可能会抛出异常的代码</span><br><span class="line">            int result = divide(10, 0);</span><br><span class="line">            System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            // 捕获并处理异常</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 无论是否异常都会执行的代码</span><br><span class="line">            System.out.println(&quot;End of program&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int divide(int a, int b) &#123;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个divide方法来计算两个整数的商，这个方法可能会抛出ArithmeticException异常（例如，被除数为0）。在main函数中，我们调用divide方法，并通过try-catch-finally语句块来捕获并处理可能抛出的异常。无论是否发生异常，finally块中的代码都会被执行。</p><p>需要注意的是，异常分为受检异常（Checked Exception）和非受检异常（Unchecked Exception）。对于受检异常，在方法签名中必须显式地声明，并且必须被捕获或者抛出；对于非受检异常，编译器不会强制要求进行处理。</p><p>throws和throw都与Java中的异常处理有关，但用法略有不同。</p><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>throws是用于声明方法可能会抛出哪些异常。在Java中，当一个方法可能会抛出某些受检查异常时，应该在方法声明中使用throws关键字来<strong>声明这些异常</strong>，以便调用者知道需要捕获和处理哪些异常。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething() throws IOException, SQLException &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法声明表示doSomething()方法可能会抛出IOException或SQLException异常，调用者必须在调用该方法时进行异常捕获或继续声明这些异常。</p><h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>throw语句用于手动抛出一个异常。在Java中，当程序遇到某些错误或异常情况时，可以使用throw语句抛出相应的异常对象，以提示程序出现了错误。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (age &lt; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Age cannot be negative!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码表示如果年龄小于0，则抛出IllegalArgumentException异常，并附带一个错误信息。</p><p>需要注意的是，当使用throw抛出异常时，程序会立即停止执行当前方法，并从当前方法返回，而不会继续执行后面的代码。因此，在实际开发中，应该谨慎使用throw语句，确保只在必要的情况下才抛出异常。</p><p>throws和throw是两个在Java中用于异常处理的关键字，它们有以下区别：</p><ol><li>用法不同</li></ol><p>throws是用于方法声明中，用于声明该方法可能会抛出哪些受检查异常；而throw是用于方法体中，用于手动抛出一个异常对象。</p><ol start="2"><li>作用不同</li></ol><p>throws主要用于告知调用者可能会发生的异常情况，以便让调用者进行相应的异常处理；而throw则是在具体的方法实现中，用于手动抛出异常对象，并中断当前方法的执行流程。</p><ol start="3"><li>处理方式不同</li></ol><p>当方法使用throws声明了某些受检查异常时，调用该方法的代码必须对这些异常进行捕获或继续向上层抛出；而当方法在执行过程中使用throw抛出了某个异常时，程序会立即停止执行当前方法，并从当前方法返回，继续执行上层方法或结束程序运行。</p><p>需要注意的是，虽然throws和throw都与Java中的异常处理有关，但它们并不是完全互斥的。实际上，在处理异常时，我们通常会同时使用到它们，例如在一个方法中先使用try-catch语句捕获异常，然后再使用throw将异常抛出到更高层次的调用者，最终由这些调用者统一处理异常。</p><h4 id="自定义异常的使用"><a href="#自定义异常的使用" class="headerlink" title="自定义异常的使用"></a>自定义异常的使用</h4><p>在Java中，我们可以通过继承Exception或者RuntimeException类来创建自定义异常。自定义异常适用于需要捕获并处理特定类型的异常情况的场景。</p><p>下面是一个自定义异常的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CustomException extends Exception &#123;</span><br><span class="line">    public CustomException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CustomException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个CustomException类，它继承自Exception类。通过重写Exception类的构造函数，我们为CustomException类提供了两个构造函数，分别用于设置异常信息和异常原因（可选）。</p><p>下面是一个使用自定义异常的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 可能会抛出自定义异常的代码</span><br><span class="line">            int result = divide(10, 0);</span><br><span class="line">            System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">        &#125; catch (CustomException e) &#123;</span><br><span class="line">            // 捕获并处理自定义异常</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;End of program&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int divide(int a, int b) throws CustomException &#123;</span><br><span class="line">        if (b == 0) &#123;</span><br><span class="line">            throw new CustomException(&quot;除数不能为0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们通过throw关键字抛出了一个自定义异常CustomException，并在divide方法的声明中使用throws关键字将这个异常向上抛出。在main函数中，我们通过try-catch-finally语句块来捕获并处理可能抛出的CustomException异常。</p><p>需要注意的是，在自定义异常时，通常应该定义有意义的异常信息，并考虑继承现有的异常类型，以便更好地利用异常处理机制。</p><h3 id="java常用类"><a href="#java常用类" class="headerlink" title="java常用类"></a>java常用类</h3><h4 id="字符串相关类的使用"><a href="#字符串相关类的使用" class="headerlink" title="字符串相关类的使用"></a>字符串相关类的使用</h4><p>在Java中，字符串相关的类有很多，比较常用的包括String、StringBuilder和StringBuffer等。</p><ol><li>String类</li></ol><p>String类是Java中用于表示字符串的类，它是不可变的（immutable）类。这意味着一旦创建了一个String对象，就不能更改该对象的值。由于String对象的不可变性，每当对String对象进行修改时，都会创建一个新的String对象，并将修改后的字符串赋值给新的对象。</p><p>下面是一些常用的String类方法：</p><ul><li>length()：返回字符串的长度。</li><li>charAt(int index)：返回指定位置的字符。</li><li>substring(int beginIndex, int endIndex)：返回从beginIndex开始到endIndex-1结束的子字符串。</li><li>equals(Object obj)：判断字符串是否相等。</li><li>toUpperCase()：将字符串转换为大写字母。</li><li>toLowerCase()：将字符串转换为小写字母。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;Hello&quot;;</span><br><span class="line">String str2 = &quot;World&quot;;</span><br><span class="line">String str3 = str1 + str2; // 拼接字符串</span><br><span class="line">System.out.println(str3); // 输出 HelloWorld</span><br><span class="line">System.out.println(str3.substring(0, 5)); // 输出 Hello</span><br></pre></td></tr></table></figure><ol start="2"><li>StringBuilder类</li></ol><p>StringBuilder类是Java中用于处理字符串的可变类，它提供了许多修改字符串的方法，如添加、插入、删除、替换等操作。与String类不同，StringBuilder类的对象可以直接进行修改，而不需要创建新的对象。</p><p>下面是一些常用的StringBuilder类方法：</p><ul><li>append(String str)：向字符串末尾添加内容。</li><li>insert(int offset, String str)：在指定位置插入内容。</li><li>delete(int start, int end)：删除指定范围内的内容。</li><li>replace(int start, int end, String str)：替换指定范围内的内容。</li><li>reverse()：反转字符串。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = new StringBuilder(&quot;Hello&quot;);</span><br><span class="line">builder.append(&quot;, World!&quot;);</span><br><span class="line">builder.insert(5, &quot;Java &quot;);</span><br><span class="line">builder.delete(1, 4);</span><br><span class="line">builder.replace(6, 11, &quot;GPT&quot;);</span><br><span class="line">builder.reverse();</span><br><span class="line">System.out.println(builder.toString()); // 输出TPG avaj olleH,!</span><br></pre></td></tr></table></figure><ol start="3"><li>StringBuffer类</li></ol><p>StringBuffer类与StringBuilder类类似，也是可变的字符串类，提供了许多修改字符串的方法。与StringBuilder类不同的是，StringBuffer类是线程安全的，适用于多线程环境下的字符串操作。但是，在单线程环境下，StringBuilder类比StringBuffer类的性能更好。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">buffer.append(&quot;, World!&quot;);</span><br><span class="line">buffer.insert(5, &quot;Java &quot;);</span><br><span class="line">buffer.delete(1, 4);</span><br><span class="line">buffer.replace(6, 11, &quot;GPT&quot;);</span><br><span class="line">buffer.reverse();</span><br><span class="line">System.out.println(buffer.toString()); // 输出TPG avaj olleH,!</span><br></pre></td></tr></table></figure><p>需要注意的是，当需要频繁地对字符串进行修改时，应该使用StringBuilder或StringBuffer类，而不是String类。如果字符串不需要修改，那么可以使用String类来代替StringBuilder和StringBuffer，因为String类更加简洁、易读</p><h4 id="System类与Runtime类的使用；"><a href="#System类与Runtime类的使用；" class="headerlink" title="System类与Runtime类的使用；"></a>System类与Runtime类的使用；</h4><ol><li>System类</li></ol><p>System类提供了一些有用的类变量和方法，如：</p><ul><li>out：标准输出流。</li><li>err：标准错误流。</li><li>currentTimeMillis()：返回当前时间的毫秒数。</li><li>getProperty(String key)：获取指定系统属性的值。</li><li>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将一个数组中的一部分复制到另一个数组中。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 执行一些操作</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;耗时：&quot; + (end - start) + &quot; 毫秒&quot;);</span><br><span class="line"></span><br><span class="line">String osName = System.getProperty(&quot;os.name&quot;);</span><br><span class="line">System.out.println(&quot;操作系统：&quot; + osName);</span><br></pre></td></tr></table></figure><ol start="2"><li>Runtime类</li></ol><p>Runtime类提供了与Java虚拟机运行时环境相关的方法，如：</p><ul><li>exec(String cmd)：在单独的进程中执行命令。</li><li>totalMemory()：JVM总内存量。</li><li>freeMemory()：JVM空闲内存量。</li><li>maxMemory()：JVM最大可用内存量。</li><li>gc()：垃圾回收器。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line">try &#123;</span><br><span class="line">    // 在单独的进程中执行命令</span><br><span class="line">    Process process = runtime.exec(&quot;notepad.exe&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;JVM总内存量：&quot; + runtime.totalMemory());</span><br><span class="line">System.out.println(&quot;JVM空闲内存量：&quot; + runtime.freeMemory());</span><br><span class="line">System.out.println(&quot;JVM最大可用内存量：&quot; + runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">runtime.gc(); // 手动触发垃圾回收器</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用exec方法时，需要注意处理异常和流，以避免出现死锁或者内存泄漏等问题；在使用Runtime类的方法时，应该小心谨慎地管理内存，避免出现OutOfMemoryError等问题。</p><h4 id="Math类与Random类的使用"><a href="#Math类与Random类的使用" class="headerlink" title="Math类与Random类的使用"></a>Math类与Random类的使用</h4><p>在Java中，Math类和Random类都是Java标准库提供的数学相关类。它们可以用来执行一些数学计算、生成随机数等。</p><ol><li>Math类</li></ol><p>Math类提供了许多数学相关的静态方法，如：</p><ul><li>abs(int a)：返回一个整数的绝对值。</li><li>ceil(double a)：返回大于或等于指定 double 值的最小 double 值，等于一个整数。</li><li>floor(double a)：返回小于或等于指定 double 值的最大 double 值，等于一个整数。</li><li>max(int a, int b)：返回两个整数中较大的那个。</li><li>min(int a, int b)：返回两个整数中较小的那个。</li><li>pow(double a, double b)：返回第一个参数的第二个参数次幂的值。</li><li>random()：返回一个介于0.0和1.0之间的随机数。</li><li>round(float a)：将一个float值舍入为最接近的整数。</li><li>sqrt(double a)：返回平方根。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = -10;</span><br><span class="line">double b = 3.14;</span><br><span class="line">System.out.println(Math.abs(a)); // 输出 10</span><br><span class="line">System.out.println(Math.ceil(b)); // 输出 4.0</span><br><span class="line">System.out.println(Math.floor(b)); // 输出 3.0</span><br><span class="line">System.out.println(Math.max(2, 5)); // 输出 5</span><br><span class="line">System.out.println(Math.min(2, 5)); // 输出 2</span><br><span class="line">System.out.println(Math.pow(2, 3)); // 输出 8.0</span><br><span class="line">System.out.println(Math.random()); // 输出介于0.0和1.0之间的随机数</span><br><span class="line">System.out.println(Math.round(3.6f)); // 输出 4</span><br><span class="line">System.out.println(Math.sqrt(9)); // 输出 3.0</span><br></pre></td></tr></table></figure><ol start="2"><li>Random类</li></ol><p>Random类提供了生成伪随机数的方法，包括nextInt、nextLong、nextDouble等方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">System.out.println(random.nextInt(100)); // 输出小于100的随机整数</span><br><span class="line">System.out.println(random.nextDouble()); // 输出小于1.0的随机浮点数</span><br></pre></td></tr></table></figure><p>需要注意的是，在生成随机数时，应该使用真正的随机数生成器，而不是伪随机数生成器，以避免出现安全问题。例如，在密码生成、加密解密等场景下，应该使用更加安全的随机数生成器。</p><h4 id="日期类的使用"><a href="#日期类的使用" class="headerlink" title="日期类的使用"></a>日期类的使用</h4><p>在Java中，日期相关的类主要包括Date、Calendar和SimpleDateFormat等。其中，Date类是Java早期提供的日期类，已经过时，建议使用Calendar或者LocalDate代替。</p><ol><li>LocalDate类</li></ol><p>LocalDate类是Java 8之后提供的日期类，它提供了许多便捷的方法来操作日期，如：</p><ul><li>now()：获取当前日期。</li><li>of(int year, int month, int dayOfMonth)：创建指定年月日的日期。</li><li>plusDays(long daysToAdd)：增加几天。</li><li>minusDays(long daysToSubtract)：减少几天。</li><li>getYear()：获取年份。</li><li>getMonth()：获取月份。</li><li>getDayOfMonth()：获取日份。</li><li>format(DateTimeFormatter formatter)：将日期格式化为指定的字符串。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">System.out.println(date); // 输出当前日期</span><br><span class="line">date = LocalDate.of(2023, 3, 12);</span><br><span class="line">System.out.println(date); // 输出指定日期</span><br><span class="line">date = date.plusDays(1);</span><br><span class="line">System.out.println(date); // 输出增加一天后的日期</span><br><span class="line">date = date.minusDays(1);</span><br><span class="line">System.out.println(date); // 输出减少一天后的日期</span><br><span class="line">System.out.println(date.getYear()); // 输出年份</span><br><span class="line">System.out.println(date.getMonth()); // 输出月份</span><br><span class="line">System.out.println(date.getDayOfMonth()); // 输出日份</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">String strDate = date.format(formatter);</span><br><span class="line">System.out.println(strDate); // 输出格式化后的日期字符串</span><br></pre></td></tr></table></figure><ol start="2"><li>SimpleDateFormat类</li></ol><p>SimpleDateFormat类是Java提供的日期格式化工具类，可以根据指定的格式将日期转换为字符串或者将字符串转换为日期。其中，常用的格式符有：</p><ul><li>y：年份（4位数）。</li><li>M：月份（1~12）。</li><li>d：日期（1~31）。</li><li>H：小时（0~23）。</li><li>m：分钟（0~59）。</li><li>s：秒钟（0~59）。</li><li>S：毫秒（0~999）。</li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">String strDate = sdf.format(date);</span><br><span class="line">System.out.println(strDate); // 输出格式化后的日期字符串</span><br><span class="line"></span><br><span class="line">strDate = &quot;2023-03-12&quot;;</span><br><span class="line">sdf.applyPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">date = sdf.parse(strDate);</span><br><span class="line">System.out.println(date); // 输出解析后的日期对象</span><br></pre></td></tr></table></figure><p>需要注意的是，在处理日期时，应该尽可能使用新的日期类（如LocalDate）代替旧的日期类（如Date），以避免出现线程安全问题和易错问题。同时，在进行日期格式化时，应该使用正确的格式符，以避免出现异常。</p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><h4 id="List、Map、Set集合的使用"><a href="#List、Map、Set集合的使用" class="headerlink" title="List、Map、Set集合的使用"></a>List、Map、Set集合的使用</h4><ol><li>List类</li></ol><p>List是一种有序的集合，可以存储重复的元素。常用的List实现类有ArrayList和LinkedList。其中，ArrayList是基于动态数组实现的，支持随机访问，而LinkedList是基于双向链表实现的，支持高效的插入和删除操作。</p><p>用的List实现类有：</p><ul><li><p>ArrayList：基于数组实现的动态数组，支持快速随机访问和插入&#x2F;删除元素等操作，但在插入&#x2F;删除元素时需要移动后面的所有元素，因此效率较低。</p></li><li><p>LinkedList：基于链表实现的双向链表，支持快速在任意位置进行插入&#x2F;删除操作，但只能顺序访问元素，且每个节点需要额外存储指向前驱节点和后继节点的引用，因此比ArrayList更占用内存空间。</p></li><li><p>Vector：与ArrayList类似，也是基于数组实现的动态数组，但线程安全，具有同步锁，适合在多线程环境下使用，但效率较低。<br><img src="file:///C:/Users/26927/Pictures/Typedown/6dda1686-b38e-4a88-b7b9-cdf767405545.png" alt="6dda1686-b38e-4a88-b7b9-cdf767405545"></p></li></ul><p>除了上述实现类之外，还有一些其他的List实现类，如Stack、CopyOnWriteArrayList等，都继承自List接口，并提供了特定的功能。</p><p>List接口提供了很多常用的方法，例如：add()、remove()、get()、set()、indexOf()、size()等，它们都遵循了Java集合框架的规范。在使用List时，建议先根据具体需求选择合适的实现类，再根据需要选择合适的方法进行操作。</p><p><img src="file:///C:/Users/26927/Pictures/Typedown/519ae451-a421-4cb6-a575-ff46187487c4.png" alt="519ae451-a421-4cb6-a575-ff46187487c4"></p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line">System.out.println(list); // 输出 [apple, banana, orange]</span><br><span class="line"></span><br><span class="line">list.remove(1);</span><br><span class="line">System.out.println(list); // 输出 [apple, orange]</span><br><span class="line"></span><br><span class="line">System.out.println(list.get(1)); // 输出 orange</span><br></pre></td></tr></table></figure><p>2.Set类</p><p>Set是一种无序的集合，不允许重复元素。常用的Set实现类有HashSet和TreeSet。其中，HashSet是基于哈希表实现的，支持快速查找，而TreeSet是基于红黑树实现的，支持按元素排序和范围查询。</p><p>常用的Set实现类有：</p><ul><li>HashSet：基于哈希表实现的Set，支持快速的插入和查找操作，但不保证元素的顺序。<img src="file:///C:/Users/26927/Pictures/Typedown/2be7d61a-f513-4e5d-aa4b-ccf3c16e1cfd.png?msec=1681038201688" alt="2be7d61af5134e5daa4bccf3c16e1cfd"></li><li>TreeSet：基于红黑树实现的有序Set，支持按照元素进行排序，但插入和查询操作的效率较低。</li><li>LinkedHashSet：基于哈希表和双向链表实现的Set，可以按照插入顺序或者访问顺序进行迭代，其性能介于HashSet和TreeSet之间。</li></ul><p>除了上述实现类之外，还有一些其他的Set实现类，如EnumSet、CopyOnWriteArraySet等，它们都继承自Set接口，并提供了特定的功能。</p><p>Set接口提供了很多常用的方法，例如：add()、remove()、contains()、size()、isEmpty()等，它们都遵循了Java集合框架的规范。在使用Set时，建议先根据具体需求选择合适的实现类，再根据需要选择合适的方法进行操作。</p><p>示例代码：<br>    Set<String> set &#x3D; new HashSet&lt;&gt;();<br>    set.add(“apple”);<br>    set.add(“banana”);<br>    set.add(“orange”);<br>    System.out.println(set); &#x2F;&#x2F; 输出 [orange, apple, banana]<br>    set.remove(“banana”);<br>    System.out.println(set); &#x2F;&#x2F; 输出 [orange, apple]<br>    System.out.println(set.contains(“apple”)); &#x2F;&#x2F; 输出 true</p><p>需要注意的是，在使用集合类时，应该根据具体需求选择合适的实现类。同时，对于需要保证线程安全的场景，应该考虑使用线程安全的集合类（如ConcurrentHashMap和CopyOnWriteArrayList等）。</p><p>3.Map类</p><p>Map是一种键值对（key-value）映射的集合，每个键只能对应一个值。常用的Map实现类有HashMap和TreeMap。其中，HashMap是基于哈希表实现的，支持快速查找，而TreeMap是基于红黑树实现的，支持按键排序。</p><p>常用的Map实现类有：</p><ul><li>HashMap：基于哈希表实现的Map，支持快速的插入和查找操作，但不保证元素的顺序，且在处理冲突时需要进行重新哈希。</li><li>TreeMap：基于红黑树实现的有序Map，支持按照键进行排序，但插入和查询操作的效率较低。</li><li>LinkedHashMap：基于哈希表和双向链表实现的Map，可以按照插入顺序或者访问顺序进行迭代，其性能介于HashMap和TreeMap之间。</li></ul><p>除了上述实现类之外，还有一些其他的Map实现类，如HashTable、ConcurrentHashMap等，它们都继承自Map接口，并提供了特定的功能。</p><p>Map接口提供了很多常用的方法，例如：put()、get()、remove()、containsKey()、containsValue()、keySet()、values()等，它们都遵循了Java集合框架的规范。在使用Map时，建议先根据具体需求选择合适的实现类，再根据需要选择合适的方法进行操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;apple&quot;, 2);</span><br><span class="line">map.put(&quot;banana&quot;, 3);</span><br><span class="line">map.put(&quot;orange&quot;, 4);</span><br><span class="line">System.out.println(map); // 输出 &#123;orange=4, apple=2, banana=3&#125;</span><br><span class="line"></span><br><span class="line">map.remove(&quot;banana&quot;);</span><br><span class="line">System.out.println(map); // 输出 &#123;orange=4, apple=2&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(map.get(&quot;apple&quot;)); // 输出 2</span><br></pre></td></tr></table></figure><h4 id="集合遍历的方法"><a href="#集合遍历的方法" class="headerlink" title="集合遍历的方法"></a>集合遍历的方法</h4><p>在Java中，集合遍历有多种方法，下面介绍几种常用的方式。</p><ol><li>for循环</li></ol><p>通过for循环可以遍历List、数组等有序集合。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>增强型for循环</li></ol><p>增强型for循环（也称为foreach）是一种简化版的for循环，用于遍历数组或Iterable类型的集合。它可以方便地遍历集合元素，但无法获取当前元素的索引。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">for (String fruit : list) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br></pre></td></tr></table></figure><ol start="3"><li>迭代器</li></ol><p>迭代器可以通过next()方法逐个获取集合中的元素，并且支持删除操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String fruit = iterator.next();</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>lambda表达式</li></ol><p>lambda表达式可以使用Stream API来遍历集合。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">list.stream().forEach(fruit -&gt; System.out.println(fruit));</span><br></pre></td></tr></table></figure><p>需要注意的是，在遍历集合时，应该根据具体需求选择合适的方式。同时，对于需要保证线程安全的集合类（如ConcurrentHashMap和CopyOnWriteArrayList等），应该采用线程安全的方式进行遍历。</p><h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><p>泛型是Java中的一个重要特性，它可以将数据类型作为参数传递给类、接口和方法。使用泛型可以提高代码的可重用性和安全性。</p><ol><li>泛型类</li></ol><p>定义一个泛型类时，需要在类名后面加上尖括号&lt;&gt;，并在其中指定泛型的类型。在类的属性、方法和构造方法中，可以使用泛型类型作为变量类型。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public Box(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>泛型接口</li></ol><p>定义一个泛型接口时，需要在接口名后面加上尖括号&lt;&gt;，并在其中指定泛型的类型。在接口的方法中，可以使用泛型类型作为参数类型或返回值类型。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">    boolean add(E element);</span><br><span class="line">    E get(int index);</span><br><span class="line">    int size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>泛型方法</li></ol><p>定义一个泛型方法时，需要在方法名前面加上尖括号&lt;&gt;，并在其中指定泛型的类型。在方法的参数、返回值和局部变量中，可以使用泛型类型。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void printArray(T[] array) &#123;</span><br><span class="line">    for (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用泛型时，应该根据具体情况选择合适的泛型类型。同时，对于需要保证类型安全的场景，应该采用泛型的方式进行编程。</p><h4 id="集合工具类的使用"><a href="#集合工具类的使用" class="headerlink" title="集合工具类的使用"></a>集合工具类的使用</h4><p>Java中提供了一些集合工具类，可以方便地对集合进行操作，下面介绍几个常用的工具类。</p><ol><li>Collections类</li></ol><p>Collections类是Java提供的集合工具类，其中包含了许多静态方法，用于对集合进行排序、查找、替换、打乱等操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line"></span><br><span class="line">Collections.sort(list); // 对集合进行排序</span><br><span class="line">System.out.println(list); // 输出 [1, 2, 3]</span><br><span class="line"></span><br><span class="line">int index = Collections.binarySearch(list, 2); // 在集合中查找元素</span><br><span class="line">System.out.println(index); // 输出 1</span><br><span class="line"></span><br><span class="line">Collections.replaceAll(list, 2, 4); // 将集合中的元素替换为指定值</span><br><span class="line">System.out.println(list); // 输出 [1, 4, 3]</span><br><span class="line"></span><br><span class="line">Collections.shuffle(list); // 随机打乱集合中的元素</span><br><span class="line">System.out.println(list); // 输出 [3, 1, 4]</span><br></pre></td></tr></table></figure><ol start="2"><li>Arrays类</li></ol><p>Arrays类是Java提供的数组工具类，其中包含了一些静态方法，用于对数组进行排序、查找、比较等操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] array = &#123;3, 1, 2&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.sort(array); // 对数组进行排序</span><br><span class="line">System.out.println(Arrays.toString(array)); // 输出 [1, 2, 3]</span><br><span class="line"></span><br><span class="line">int index = Arrays.binarySearch(array, 2); // 在数组中查找元素</span><br><span class="line">System.out.println(index); // 输出 1</span><br><span class="line"></span><br><span class="line">boolean isEqual = Arrays.equals(array, new int[]&#123;1, 2, 3&#125;); // 比较两个数组是否相等</span><br><span class="line">System.out.println(isEqual); // 输出 true</span><br></pre></td></tr></table></figure><ol start="3"><li>StringUtils类</li></ol><p>StringUtils类是Apache Commons Lang库提供的字符串工具类，其中包含了一些静态方法，用于对字符串进行处理，如判断是否为空、去除空格、拼接字符串等操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;  hello world! &quot;;</span><br><span class="line"></span><br><span class="line">boolean isBlank = StringUtils.isBlank(str); // 判断字符串是否为空或者只包含空格</span><br><span class="line">System.out.println(isBlank); // 输出 false</span><br><span class="line"></span><br><span class="line">String trimmedStr = StringUtils.trim(str); // 去除字符串前后的空格</span><br><span class="line">System.out.println(trimmedStr); // 输出 &quot;hello world!&quot;</span><br><span class="line"></span><br><span class="line">String joinedStr = StringUtils.join(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;, &quot;, &quot;); // 将数组中的元素以指定分隔符拼接成字符串</span><br><span class="line">System.out.println(joinedStr); // 输出 &quot;hello, world&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用集合工具类时，应该根据具体需求选择合适的工具类和方法。同时，对于需要保证线程安全的场景，应该考虑使用线程安全的集合工具类（如ConcurrentHashMap和CopyOnWriteArrayList等）。</p><h4 id="Stream-API的使用"><a href="#Stream-API的使用" class="headerlink" title="Stream API的使用"></a>Stream API的使用</h4><p>Stream API是Java 8中新增的一个功能，它提供了一种流式处理数据的方式，可以方便地对集合、数组和I&#x2F;O等数据源进行操作。</p><p>使用Stream API可以大幅度减少代码量，并且提高程序的可读性和可维护性。</p><p>下面介绍Stream API的常用方法。</p><ol><li>filter()</li></ol><p>filter()方法用于过滤集合中不符合条件的元素。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; filteredList = list.stream()</span><br><span class="line">        .filter(i -&gt; i % 2 == 0)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filteredList); // 输出 [2, 4]</span><br></pre></td></tr></table></figure><ol start="2"><li>map()</li></ol><p>map()方法用于将集合中的每个元素映射为另外一个值。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; mappedList = list.stream()</span><br><span class="line">        .map(s -&gt; s.length())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(mappedList); // 输出 [5, 6, 6]</span><br></pre></td></tr></table></figure><ol start="3"><li>reduce()</li></ol><p>reduce()方法用于对集合中的元素进行归约操作，生成一个新的值。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">int sum = list.stream()</span><br><span class="line">        .reduce(0, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">System.out.println(sum); // 输出 15</span><br></pre></td></tr></table></figure><ol start="4"><li>sorted()</li></ol><p>sorted()方法用于对集合中的元素进行排序。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(5, 3, 1, 2, 4);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; sortedList = list.stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(sortedList); // 输出 [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用Stream API时，应该根据具体情况选择合适的方法。同时，Stream API中的方法都是惰性求值的，只有在最后调用终止操作（如collect()、forEach()）时才会执行。</p><h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><h4 id="File类及其用法"><a href="#File类及其用法" class="headerlink" title="File类及其用法"></a>File类及其用法</h4><p>File类是Java中用来表示文件或目录的类，它提供了一系列操作文件和目录的方法。</p><p>下面介绍File类的常用方法。</p><p><img src="https://img-blog.csdnimg.cn/20210616175436943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70"></p><ol><li>构造方法</li></ol><p>File类提供了多个构造方法，可以根据给定的路径创建一个File对象。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file1 = new File(&quot;D:/demo/file.txt&quot;); // 绝对路径</span><br><span class="line">File file2 = new File(&quot;src/main/java/com/example/demo/FileDemo.java&quot;); // 相对路径</span><br><span class="line">File file3 = new File(&quot;D:/demo&quot;, &quot;file.txt&quot;); // 父目录和子文件名</span><br></pre></td></tr></table></figure><ol start="2"><li>创建和删除文件与目录</li></ol><p>File类提供了多个方法，可以创建和删除文件和目录。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">boolean isSuccess = file.createNewFile(); // 创建新文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">isSuccess = file.delete(); // 删除文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">File directory = new File(&quot;D:/demo/newdir&quot;);</span><br><span class="line">isSuccess = directory.mkdir(); // 创建新目录</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">isSuccess = directory.delete(); // 删除目录</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br></pre></td></tr></table></figure><ol start="3"><li>文件信息查询</li></ol><p>File类提供了多个方法，可以查询文件的属性和状态。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:/demo/file.txt&quot;);</span><br><span class="line"></span><br><span class="line">String absolutePath = file.getAbsolutePath(); // 获取文件的绝对路径</span><br><span class="line">System.out.println(absolutePath); // 输出 D:\demo\file.txt</span><br><span class="line"></span><br><span class="line">long length = file.length(); // 获取文件的长度（字节数）</span><br><span class="line">System.out.println(length); // 输出 0</span><br><span class="line"></span><br><span class="line">boolean isDirectory = file.isDirectory(); // 判断是否为目录</span><br><span class="line">System.out.println(isDirectory); // 输出 false</span><br><span class="line"></span><br><span class="line">boolean isFile = file.isFile(); // 判断是否为文件</span><br><span class="line">System.out.println(isFile); // 输出 true</span><br><span class="line"></span><br><span class="line">boolean exists = file.exists(); // 判断文件是否存在</span><br><span class="line">System.out.println(exists); // 输出 true</span><br></pre></td></tr></table></figure><ol start="4"><li>文件操作</li></ol><p>File类提供了多个方法，可以对文件进行复制、移动、重命名等操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">File file1 = new File(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">File file2 = new File(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line"></span><br><span class="line">boolean isSuccess = file1.renameTo(file2); // 重命名文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">isSuccess = file1.createNewFile(); // 创建新文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">InputStream in = new FileInputStream(file1);</span><br><span class="line">OutputStream out = new FileOutputStream(file2);</span><br><span class="line"></span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = in.read(buffer)) &gt; 0) &#123; // 复制文件</span><br><span class="line">    out.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">isSuccess = file1.delete(); // 删除文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用File类时，应该根据具体情况选择合适的方法。同时，对于需要保证线程安全的场景，应该考虑使用线程安全的文件操作类（如Apache Commons IO库提供的工具类）</p><h4 id="操作字节流和字符流读写文件"><a href="#操作字节流和字符流读写文件" class="headerlink" title="操作字节流和字符流读写文件"></a>操作字节流和字符流读写文件</h4><p><img src="file:///C:/Users/26927/Pictures/Typedown/b31caab1-f83b-49a4-a25d-cd74f0631ffe.png" alt="b31caab1-f83b-49a4-a25d-cd74f0631ffe"></p><p>Java中提供了字节流和字符流两种方式来读写文件。</p><ol><li>操作字节流读写文件</li></ol><p>使用字节流读写文件需要使用InputStream和OutputStream类。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件内容</span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = in.read(buffer)) != -1) &#123;</span><br><span class="line">    System.out.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">// 写入文件内容</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">out.write(&quot;Hello, world!&quot;.getBytes());</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><p>上面的示例代码中，InputStream的read()方法会读取文件输入流中的字节到缓冲区中，并返回读取的字节数。当读取到文件末尾时，该方法会返回-1。</p><ol start="2"><li>操作字符流读写文件</li></ol><p>使用字符流读写文件需要使用Reader和Writer类。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件内容</span><br><span class="line">Reader reader = new FileReader(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">char[] buffer = new char[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = reader.read(buffer)) != -1) &#123;</span><br><span class="line">    System.out.print(new String(buffer, 0, len));</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"></span><br><span class="line">// 写入文件内容</span><br><span class="line">Writer writer = new FileWriter(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">writer.write(&quot;Hello, world!&quot;);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>上面的示例代码中，Reader的read()方法会读取文件输入流中的字符到缓冲区中，并返回读取的字符数。当读取到文件末尾时，该方法会返回-1。</p><p>需要注意的是，在读写文件时，应该根据文件的编码格式选择合适的字节流或字符流。另外，为避免资源泄漏，应该使用try-with-resources语句来自动关闭输入输出流。</p><p><img src="file:///C:/Users/26927/Pictures/Typedown/7ae67b77-245e-4b50-8f22-3872be2cf7d9.png" alt="7ae67b77-245e-4b50-8f22-3872be2cf7d9"></p><h4 id="其他IO流（了解）"><a href="#其他IO流（了解）" class="headerlink" title="其他IO流（了解）"></a>其他IO流（了解）</h4><p>除了字节流和字符流之外，Java中还提供了其他多种类型的IO流，包括：</p><ol><li>缓冲流</li></ol><p>缓冲流是一种性能更好的字节流或字符流，它可以减少访问底层资源的次数，提高读写效率。Java中提供了BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter等缓冲流类。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 使用缓冲字节流复制文件内容</span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(in);</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(out);</span><br><span class="line"></span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = bis.read(buffer)) != -1) &#123;</span><br><span class="line">    bos.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br><span class="line"></span><br><span class="line">// 使用缓冲字符流读取文件内容</span><br><span class="line">Reader reader = new FileReader(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">Writer writer = new FileWriter(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">BufferedReader br = new BufferedReader(reader);</span><br><span class="line">BufferedWriter bw = new BufferedWriter(writer);</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line">while ((line = br.readLine()) != null) &#123;</span><br><span class="line">    bw.write(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure><ol start="2"><li>数据流</li></ol><p>数据流可以用来读写Java中的基本数据类型和对象，在读写时会将数据转换为二进制格式。Java中提供了DataInputStream和DataOutputStream两个数据流类。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用数据流写入和读取基本数据类型</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/data.bin&quot;);</span><br><span class="line">DataOutputStream dos = new DataOutputStream(out);</span><br><span class="line"></span><br><span class="line">dos.writeInt(123);</span><br><span class="line">dos.writeDouble(3.14);</span><br><span class="line">dos.writeBoolean(true);</span><br><span class="line"></span><br><span class="line">dos.close();</span><br><span class="line"></span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/data.bin&quot;);</span><br><span class="line">DataInputStream dis = new DataInputStream(in);</span><br><span class="line"></span><br><span class="line">int intValue = dis.readInt();</span><br><span class="line">double doubleValue = dis.readDouble();</span><br><span class="line">boolean booleanValue = dis.readBoolean();</span><br><span class="line"></span><br><span class="line">dis.close();</span><br><span class="line"></span><br><span class="line">System.out.println(intValue); // 输出 123</span><br><span class="line">System.out.println(doubleValue); // 输出 3.14</span><br><span class="line">System.out.println(booleanValue); // 输出 true</span><br></pre></td></tr></table></figure><ol start="3"><li>对象流</li></ol><p>对象流可以用来读写Java中的对象，在读写时会将对象序列化为二进制格式。Java中提供了ObjectInputStream和ObjectOutputStream两个对象流类。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用对象流写入和读取对象</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/person.obj&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(out);</span><br><span class="line">Person person = new Person(&quot;张三&quot;, 20);</span><br><span class="line">oos.writeObject(person);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/person.obj&quot;);</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(in);</span><br><span class="line">person = (Person) ois.readObject();</span><br><span class="line">ois.close();</span><br><span class="line"></span><br><span class="line">System.out.println(person.getName()); // 输出 张三</span><br><span class="line">System.out.println(person.getAge()); // 输出 20</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/26927/Pictures/Typedown/d6e042ae-9eba-412c-a522-a2840c05601f.png" alt="d6e042ae-9eba-412c-a522-a2840c05601f"></p><p>需要注意的是，在使用IO流时，应该根据具体情况选择合适的流类型，并在读写完毕后及时关闭流以释放资源。</p><h4 id="NIO的概念及其用法（了解）"><a href="#NIO的概念及其用法（了解）" class="headerlink" title="NIO的概念及其用法（了解）"></a>NIO的概念及其用法（了解）</h4><p>NIO（New IO）是Java中提供的一种新的IO处理方式，它相对于传统的IO方式具有更高的效率和灵活性。</p><ol><li>NIO的概念</li></ol><p>在传统IO中，数据的读写是通过流（InputStream&#x2F;OutputStream）进行的。而在NIO中，数据的读写是通过缓冲区（Buffer）进行的。NIO中的核心类包括ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、DoubleBuffer等缓冲区类，以及Channel、Selector等类。</p><ol start="2"><li>NIO的用法</li></ol><p>使用NIO进行数据读写需要以下几个步骤：</p><p>2.1 打开Channel</p><p>首先需要打开一个Channel，可以是FileChannel、DatagramChannel、SocketChannel或ServerSocketChannel等类型的通道。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开文件通道</span><br><span class="line">FileChannel channel = FileChannel.open(Paths.get(&quot;D:/demo/file.txt&quot;), StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><p>2.2 创建Buffer</p><p>创建一个Buffer来存储数据。在NIO中，所有数据都是通过Buffer来处理的，因此需要根据实际需要创建合适类型的Buffer。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">// 创建字节缓冲区</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br></pre></td></tr></table></figure><p>2.3 从Channel中读取数据</p><p>使用Channel的read()方法从Channel中读取数据到Buffer中。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从文件通道读取数据到缓冲区</span><br><span class="line">int bytesRead = channel.read(buffer);</span><br></pre></td></tr></table></figure><p>2.4 写入数据到Channel中</p><p>使用Channel的write()方法将数据从Buffer中写入到Channel中。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将缓冲区中的数据写入到文件通道中</span><br><span class="line">buffer.flip(); // 切换读模式到写模式</span><br><span class="line">channel.write(buffer);</span><br></pre></td></tr></table></figure><p>2.5 关闭Channel</p><p>使用完Channel后应该手动关闭它以释放资源。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 关闭文件通道</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure><ol start="3"><li>NIO Selector的用法</li></ol><p>NIO中的Selector可以用来监听多个Channel的事件，并在有事件发生时进行处理。Selector主要包括以下几个方法：</p><ul><li><p>Selector.open()：打开一个Selector。</p></li><li><p>select()：阻塞并等待至少一个Channel有就绪事件产生。</p></li><li><p>selectedKeys()：获取所有就绪的SelectionKey集合。</p></li><li><p>Selector.close()：关闭Selecto<br>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 打开Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">// 向通道注册Selector及所关心的事件</span><br><span class="line">SelectableChannel channel = SocketChannel.open();</span><br><span class="line">channel.configureBlocking(false); // 设置为非阻塞IO</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">// 阻塞并等待就绪事件的产生</span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">// 处理就绪事件</span><br><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey selectionKey = iterator.next();</span><br><span class="line">    if (selectionKey.isReadable()) &#123;</span><br><span class="line">        // Channel可读事件处理</span><br><span class="line">    &#125; else if (selectionKey.isWritable()) &#123;</span><br><span class="line">        // Channel可写事件处理</span><br><span class="line">    &#125;</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭Selector</span><br><span class="line">selector.close();</span><br></pre></td></tr></table></figure></li></ul><p>需要注意的是，在使用NIO进行数据读写时，应该根据实际需求选择使用哪种类型的Channel和Buffer，并保证线程安全。同时，在使用Selector时也应该避免过度使用，以免造成系统资源浪费。</p><h4 id="常见字符编码（了解）"><a href="#常见字符编码（了解）" class="headerlink" title="常见字符编码（了解）"></a>常见字符编码（了解）</h4><p>在计算机中，字符编码是用来表示字符的数值代码的一种系统。常见的字符编码包括以下几种：</p><ol><li>ASCII</li></ol><p>ASCII（American Standard Code for Information Interchange）是最早的字符编码标准之一，使用7位二进制数来表示128个不同的字符，包括英文字母、数字、标点符号等。</p><ol start="2"><li>ISO-8859</li></ol><p>ISO-8859是一系列字符编码标准，其中最常用的是ISO-8859-1，也称为Latin-1。ISO-8859-1使用8位二进制数来表示256个不同的字符，包括ASCII中的所有字符以及欧洲各国语言中出现的字符。</p><ol start="3"><li>Unicode</li></ol><p>Unicode是一种全球化字符编码标准，它使用32位二进制数来表示超过100,000个字符，包括各种语言的字符、符号、表情等。Unicode的两种主要实现方式是UTF-8和UTF-16。</p><ol start="4"><li>UTF-8</li></ol><p>UTF-8（Unicode Transformation Format 8-bit）是一种变长编码方式，它使用1~4个字节来表示不同的字符。UTF-8可以表示Unicode中的任意字符，并且向下兼容ASCII编码。</p><ol start="5"><li>UTF-16</li></ol><p>UTF-16（Unicode Transformation Format 16-bit）是一种定长编码方式，它使用2个字节来表示大部分常用字符，使用4个字节来表示较少使用的字符。UTF-16可以表示Unicode中的任意字符，但是它不向下兼容ASCII编码。</p><p>需要注意的是，在进行文本处理时应该根据具体情况选择合适的字符编码，避免因编码不匹配而导致乱码等问题。同时，在进行字符编码转换时也应该谨慎处理，以免产生意外的结果。</p><h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><h3 id="AWT组件和Swing组件的联系和区别（了解）"><a href="#AWT组件和Swing组件的联系和区别（了解）" class="headerlink" title="AWT组件和Swing组件的联系和区别（了解）"></a>AWT组件和Swing组件的联系和区别（了解）</h3><p>AWT（Abstract Window Toolkit）和Swing都是Java GUI编程中常用的组件库，它们有很多相似之处，但也存在一些区别。</p><ol><li>AWT组件和Swing组件的联系</li></ol><p>AWT和Swing都提供了大量的GUI组件，例如按钮、文本框、标签、列表框、下拉框等。这些组件都可以使用Java代码进行创建、配置和布局，并且可以添加事件监听器来处理交互事件。</p><p>同时，AWT和Swing都使用轻量级组件模型，即将所有GUI组件封装在一个统一的容器中，并由容器自行管理和绘制组件。</p><ol start="2"><li>AWT组件和Swing组件的区别</li></ol><p>虽然AWT和Swing都是GUI组件库，但是它们也存在着一些不同之处：</p><ul><li>组件外观：AWT使用本地系统窗口来呈现组件，因此它的外观会随操作系统的不同而有所差异；而Swing则采用了一套独立的外观设计，称为“Pluggable Look and Feel”，使得Swing组件在不同平台上具有一致的外观。</li><li>组件性能：由于AWT使用了本地系统窗口，因此在跨平台时可能会出现性能问题；而Swing则更加轻量级，可以在不同平台上获得更好的性能表现。</li><li>组件数量：AWT提供的组件数量相对较少，而Swing则提供了更丰富的组件库，例如JTable、JTree、JFileChooser等。</li><li>组件功能：AWT的组件功能相对简单，适合于开发基础的GUI应用程序；而Swing的组件功能更加强大，可以用于开发复杂的GUI应用程序。</li></ul><p>总的来说，如果需要开发简单的GUI应用程序，可以选择使用AWT，它更加稳定并且易于学习；而如果需要开发复杂的GUI应用程序，可以选择Swing，它更加灵活、强大并且具有良好的跨平台性能。</p><h3 id="常用的Swing组件的使用"><a href="#常用的Swing组件的使用" class="headerlink" title="常用的Swing组件的使用"></a>常用的Swing组件的使用</h3><p>Swing是Java中常用的GUI组件库，提供了大量的组件和布局管理器，可以用于开发丰富的GUI应用程序。以下是一些常用的Swing组件及其使用方法：</p><ol><li>JFrame</li></ol><p>JFrame是Swing中最基本的顶层容器，它可以作为窗口来显示Swing中的其他组件。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = new JFrame(&quot;My Frame&quot;);</span><br><span class="line">frame.setSize(400, 300);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置关闭行为</span><br><span class="line">frame.setVisible(true); // 显示窗口</span><br></pre></td></tr></table></figure><ol start="2"><li>JPanel</li></ol><p>JPanel是一个面板容器，可以将其他组件添加进来，并使用布局管理器进行管理。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JPanel panel = new JPanel(new BorderLayout());</span><br><span class="line">panel.add(new JButton(&quot;Button&quot;), BorderLayout.CENTER);</span><br><span class="line">panel.add(new JLabel(&quot;Label&quot;), BorderLayout.NORTH);</span><br></pre></td></tr></table></figure><ol start="3"><li>JButton</li></ol><p>JButton是一个按钮组件，可以响应用户的单击事件。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JButton button = new JButton(&quot;Click me&quot;);</span><br><span class="line">button.addActionListener(e -&gt; &#123;</span><br><span class="line">    // 处理按钮单击事件</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>JTextField</li></ol><p>JTextField是一个文本框组件，可以让用户输入和编辑文本。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JTextField textField = new JTextField(&quot;default text&quot;, 20);</span><br><span class="line">String text = textField.getText(); // 获取文本框中的文本</span><br><span class="line">textField.setText(&quot;new text&quot;); // 设置文本框中的文本JCheckBox</span><br></pre></td></tr></table></figure><ol start="5"><li>JCheckBox</li></ol><p>JCheckBox是一个复选框组件，可以让用户进行多选操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JCheckBox checkBox = new JCheckBox(&quot;Check me&quot;);</span><br><span class="line">boolean checked = checkBox.isSelected(); // 判断复选框是否被选中</span><br><span class="line">checkBox.setSelected(true); // 设置复选框为选中状态</span><br></pre></td></tr></table></figure><ol start="6"><li>JRadioButton</li></ol><p>JRadioButton是一个单选按钮组件，与JCheckBox不同的是，只允许用户进行单选操作。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JRadioButton radioButton1 = new JRadioButton(&quot;Option 1&quot;);</span><br><span class="line">JRadioButton radioButton2 = new JRadioButton(&quot;Option 2&quot;);</span><br><span class="line">ButtonGroup group = new ButtonGroup();</span><br><span class="line">group.add(radioButton1);</span><br><span class="line">group.add(radioButton2);</span><br></pre></td></tr></table></figure><ol start="7"><li>JComboBox</li></ol><p>JComboBox是一个下拉框组件，可以提供多个选项供用户选择。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JComboBox&lt;String&gt; comboBox = new JComboBox&lt;&gt;(new String[]&#123;&quot;Option 1&quot;, &quot;Option 2&quot;, &quot;Option 3&quot;&#125;);</span><br><span class="line">String selected = comboBox.getSelectedItem().toString(); // 获取当前选中的选项</span><br><span class="line">comboBox.setSelectedIndex(1); // 设置选中指定索引位置的选项</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用Swing组件时应该根据实际需求选择合适的组件、布局管理器以及事件处理方式，以便实现所需的功能并提升用户体验。</p><h4 id="常用的窗体和布局管理器"><a href="#常用的窗体和布局管理器" class="headerlink" title="常用的窗体和布局管理器"></a>常用的窗体和布局管理器</h4><p>在Java Swing中，窗体和布局管理器是常用的GUI开发工具。以下是一些常用的窗体和布局管理器：</p><ol><li>JFrame</li></ol><p>JFrame是Swing中最基本的顶层容器，可以作为窗口来显示Swing中的其他组件。使用setDefaultCloseOperation()方法设置关闭窗口时的行为，使用setSize()、setLocation()等方法设置窗口大小和位置。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = new JFrame(&quot;My Frame&quot;);</span><br><span class="line">frame.setSize(400, 300);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置关闭行为</span><br><span class="line">frame.setVisible(true); // 显示窗口</span><br></pre></td></tr></table></figure><ol start="2"><li>JPanel</li></ol><p>JPanel是一个面板容器，可以将其他组件添加进来，并使用布局管理器进行管理。使用setLayout()方法设置面板的布局管理器，使用add()方法将其他组件添加到面板中。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JPanel panel = new JPanel(new BorderLayout());</span><br><span class="line">panel.add(new JButton(&quot;Button&quot;), BorderLayout.CENTER);</span><br><span class="line">panel.add(new JLabel(&quot;Label&quot;), BorderLayout.NORTH);</span><br></pre></td></tr></table></figure><h4 id="1-1-边框布局管理器-BorderLayout"><a href="#1-1-边框布局管理器-BorderLayout" class="headerlink" title="1.1 边框布局管理器(BorderLayout)"></a>1.1 边框布局管理器(BorderLayout)</h4><blockquote><p>BorderLayout（边框布局管理器）是 Window、JFrame 和 JDialog 的默认布局管理器。边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。其中，North 表示北，将占据面板的上方；Soufe 表示南，将占据面板的下方；East表示东，将占据面板的右侧；West 表示西，将占据面板的左侧；中间区域 Center 是在东、南、西、北都填满后剩下的区域，如图 所示：<br><img src="https://img-blog.csdnimg.cn/20190305000445812.png" alt="在这里插入图片描述"><br><code>提示：边框布局管理器并不要求所有区域都必须有组件，如果四周的区域（North、South、East 和 West 区域）没有组件，则由 Center 区域去补充。如果单个区域中添加的不只一个组件，那么后来添加的组件将覆盖原来的组件，所以，区域中只显示最后添加的一个组件。</code></p></blockquote><h5 id="1-2-BorderLayout-布局管理器的构造方法"><a href="#1-2-BorderLayout-布局管理器的构造方法" class="headerlink" title="1.2 BorderLayout 布局管理器的构造方法"></a>1.2 BorderLayout 布局管理器的构造方法</h5><pre><code>BorderLayout()创建一个 Border 布局，组件之间没有间隙。BorderLayout(int hgap,int vgap)创建一个 Border 布局，其中 hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</code></pre><h5 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h5><blockquote><p>使用 BorderLayout 将窗口分割为 5 个区域，并在每个区域添加一个标签按钮。实现代码如下：</p></blockquote><pre><code>import javax.swing.*;import java.awt.*;public class BorderLayoutDemo &#123;    public static void main(String[] agrs) &#123;        JFrame frame=new JFrame(&quot;BorderLayoutDemo&quot;);    //创建Frame窗口        frame.setSize(400,200);        frame.setLayout(new BorderLayout());    //为Frame窗口设置布局为BorderLayout        JButton button1=new JButton (&quot;上&quot;);        JButton button2=new JButton(&quot;左&quot;);        JButton button3=new JButton(&quot;中&quot;);        JButton button4=new JButton(&quot;右&quot;);        JButton button5=new JButton(&quot;下&quot;);        frame.add(button1,BorderLayout.NORTH);        frame.add(button2,BorderLayout.WEST);        frame.add(button3,BorderLayout.CENTER);        frame.add(button4,BorderLayout.EAST);        frame.add(button5,BorderLayout.SOUTH);        frame.setBounds(300,200,600,300);        frame.setVisible(true);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    &#125;&#125;</code></pre><blockquote><p><code>运行效果如下：</code><br><img src="https://img-blog.csdnimg.cn/20190305001135544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h4 id="二、流式布局管理器-FlowLayout"><a href="#二、流式布局管理器-FlowLayout" class="headerlink" title="二、流式布局管理器(FlowLayout)"></a><code>二、流式布局管理器(FlowLayout)</code></h4><h5 id="2-1-FlowLayout"><a href="#2-1-FlowLayout" class="headerlink" title="2.1 FlowLayout"></a>2.1 FlowLayout</h5><blockquote><p>FlowLayout（流式布局管理器）是 JPanel 和 JApplet 的默认布局管理器。<code>FlowLayout 会将组件按照从从左到右、上到下的放置规律逐行进行定位。与其他布局管理器不同的是，FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。</code></p></blockquote><h5 id="2-2-FlowLayout-布局管理器的构造方法"><a href="#2-2-FlowLayout-布局管理器的构造方法" class="headerlink" title="2.2 FlowLayout 布局管理器的构造方法"></a>2.2 FlowLayout 布局管理器的构造方法</h5><pre><code>FlowLayout()：创建一个布局管理器，使用默认的居中对齐方式和默认 5 像素的水平和垂直间隔。FlowLayout(int align)：创建一个布局管理器，使用默认 5 像素的水平和垂直间隔。其中，align 表示组件的对齐方式，对齐的值必须是 FlowLayout.LEFT、FlowLayout.RIGHT 和 FlowLayout.CENTER，指定组件在这一行的位置是居左对齐、居右对齐或居中对齐。FlowLayout(int align, int hgap,int vgap)：创建一个布局管理器，其中 align 表示组件的对齐方式；hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</code></pre><h5 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h5><blockquote><p>使用 FlowLayout 类对窗口进行布局，向容器内添加 9 个按钮，并设置横向和纵向的间隔都为 20 像素。具体实现代码如下：</p></blockquote><pre><code>import javax.swing.*;import java.awt.*;public class FlowLayoutDemo &#123;    public static void main(String[] agrs)  &#123;        JFrame jFrame=new JFrame(&quot;FlowLayoutDemo&quot;);    //创建Frame窗口        JPanel jPanel=new JPanel();    //创建面板        JButton btn1=new JButton(&quot;1&quot;);    //创建按钮        JButton btn2=new JButton(&quot;2&quot;);        JButton btn3=new JButton(&quot;3&quot;);        JButton btn4=new JButton(&quot;4&quot;);        JButton btn5=new JButton(&quot;5&quot;);        JButton btn6=new JButton(&quot;6&quot;);        JButton btn7=new JButton(&quot;7&quot;);        JButton btn8=new JButton(&quot;8&quot;);        JButton btn9=new JButton(&quot;9&quot;);        jPanel.add(btn1);    //面板中添加按钮        jPanel.add(btn2);        jPanel.add(btn3);        jPanel.add(btn4);        jPanel.add(btn5);        jPanel.add(btn6);        jPanel.add(btn7);        jPanel.add(btn8);        jPanel.add(btn9);        //向JPanel添加FlowLayout布局管理器，将组件间的横向和纵向间隙都设置为20像素        jPanel.setLayout(new FlowLayout(FlowLayout.LEADING,20,20));        jPanel.setBackground(Color.gray);    //设置背景色        jFrame.add(jPanel);    //添加面板到容器        jFrame.setBounds(300,200,300,150);    //设置容器的大小        jFrame.setVisible(true);        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    &#125;&#125;</code></pre><blockquote><p>上述程序向 JPanel 面板中添加了 9 个按钮，并使用 FlowLayout 布局管理器使 9 个按钮间的横向和纵向间隙都为 20 像素。此时这些按钮将在容器上按照从上到下、从左到右的顺序排列，如果一行剩余空间不足容纳组件将会换行显示，最终运行结果如图 所示：<br><img src="https://img-blog.csdnimg.cn/20190305002233296.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190305002306124.png" alt="在这里插入图片描述"></p></blockquote><h4 id="三、卡片布局管理器-CardLayout"><a href="#三、卡片布局管理器-CardLayout" class="headerlink" title="三、卡片布局管理器(CardLayout)"></a><code>三、卡片布局管理器(CardLayout)</code></h4><h5 id="3-1-CardLayout"><a href="#3-1-CardLayout" class="headerlink" title="3.1 CardLayout"></a>3.1 CardLayout</h5><blockquote><p>CardLayout（卡片布局管理器）能够帮助用户实现多个成员共享同一个显示空间，并且一次只显示一个容器组件的内容。<br><code>CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。</code></p></blockquote><h5 id="3-2-CardLayout-的构造方法"><a href="#3-2-CardLayout-的构造方法" class="headerlink" title="3.2 CardLayout 的构造方法"></a>3.2 CardLayout 的构造方法</h5><pre><code>CardLayout()：构造一个新布局，默认间隔为 0。CardLayout(int hgap, int vgap)：创建布局管理器，并指定组件间的水平间隔（hgap）和垂直间隔（vgap）。</code></pre><h5 id="3-3-示例"><a href="#3-3-示例" class="headerlink" title="3.3 示例"></a>3.3 示例</h5><blockquote><p>使用 CardLayout 类对容器内的两个面板进行布局。其中第一个面板上包括三个按钮，第二个面板上包括三个文本框。最后调用 CardLayout 类的 show() 方法显示指定面板的内容，代码如下：</p></blockquote><pre><code>import javax.swing.*;import java.awt.*;public class CardLayoutDemo &#123;    public static void main(String[] agrs) &#123;        JFrame frame=new JFrame(&quot;CardLayoutDemo&quot;);    //创建Frame窗口        JPanel p1=new JPanel();    //面板1        JPanel p2=new JPanel();    //面板2        JPanel cards=new JPanel(new CardLayout());    //卡片式布局的面板        p1.add(new JButton(&quot;登录按钮&quot;));        p1.add(new JButton(&quot;注册按钮&quot;));        p1.add(new JButton(&quot;找回密码按钮&quot;));        p2.add(new JTextField(&quot;用户名文本框&quot;,20));        p2.add(new JTextField(&quot;密码文本框&quot;,20));        p2.add(new JTextField(&quot;验证码文本框&quot;,20));        cards.add(p1,&quot;card1&quot;);    //向卡片式布局面板中添加面板1        cards.add(p2,&quot;card2&quot;);    //向卡片式布局面板中添加面板2        CardLayout cl=(CardLayout)(cards.getLayout());        cl.show(cards,&quot;card1&quot;);    //调用show()方法显示面板2        frame.add(cards);        frame.setBounds(300,200,400,200);        frame.setVisible(true);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    &#125;&#125;</code></pre><blockquote><p>上述代码创建了一个卡片式布局的面板 cards，该面板包含两个大小相同的子面板 p1 和 p2。需要注意的是，在将 p1 和 p2 添加到 cards 面板中时使用了含有两个参数的 add() 方法，该方法的第二个参数用来标识子面板。当需要显示某一个面板时，只需要调用卡片式布局管理器的 show() 方法，并在参数中指定子面板所对应的字符串即可，这里显示的是 p1 面板，运行效果如图 所示：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190305003304870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>如果将“cl.show(cards,“card1”)”语句中的 card1 换成 card2，将显示 p2 面板的内容，此时运行结果如图 所示：<br><img src="https://img-blog.csdnimg.cn/20190305003408605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h4 id="四、网格布局管理器-GridLayout"><a href="#四、网格布局管理器-GridLayout" class="headerlink" title="四、网格布局管理器(GridLayout)"></a><code>四、网格布局管理器(GridLayout)</code></h4><h5 id="4-1-GridLayout"><a href="#4-1-GridLayout" class="headerlink" title="4.1 GridLayout"></a>4.1 GridLayout</h5><blockquote><p>GridLayout（网格布局管理器）为组件的放置位置提供了更大的灵活性。<code>它将区域分割成行数（rows）和列数（columns）的网格状布局，组件按照由左至右、由上而下的次序排列填充到各个单元格中。</code><br><code>提示：GridLayout 布局管理器总是忽略组件的最佳大小，而是根据提供的行和列进行平分。该布局管理的所有单元格的宽度和高度都是一样的。</code></p></blockquote><h5 id="4-2-GridLayout-的构造方法"><a href="#4-2-GridLayout-的构造方法" class="headerlink" title="4.2 GridLayout 的构造方法"></a>4.2 GridLayout 的构造方法</h5><pre><code>GridLayout(int rows,int cols)：创建一个指定行（rows）和列（cols）的网格布局。布局中所有组件的大小一样，组件之间没有间隔。GridLayout(int rows,int cols,int hgap,int vgap)：创建一个指定行（rows）和列（cols）的网格布局，并且可以指定组件之间横向（hgap）和纵向（vgap）的间隔，单位是像素。</code></pre><h5 id="4-3-示例"><a href="#4-3-示例" class="headerlink" title="4.3 示例"></a>4.3 示例</h5><blockquote><p>使用 GridLayout 类的网格布局设计一个简单计算器。代码的实现如下：</p></blockquote><pre><code>import javax.swing.*;import java.awt.*;public class GridLayoutDemo &#123;    public static void main(String[] args) &#123;        JFrame frame=new JFrame(&quot;GridLayou布局计算器&quot;);        JPanel panel=new JPanel();    //创建面板        //指定面板的布局为GridLayout，4行4列，间隙为5        panel.setLayout(new GridLayout(4,4,5,5));        panel.add(new JButton(&quot;7&quot;));    //添加按钮        panel.add(new JButton(&quot;8&quot;));        panel.add(new JButton(&quot;9&quot;));        panel.add(new JButton(&quot;/&quot;));        panel.add(new JButton(&quot;4&quot;));        panel.add(new JButton(&quot;5&quot;));        panel.add(new JButton(&quot;6&quot;));        panel.add(new JButton(&quot;*&quot;));        panel.add(new JButton(&quot;1&quot;));        panel.add(new JButton(&quot;2&quot;));        panel.add(new JButton(&quot;3&quot;));        panel.add(new JButton(&quot;-&quot;));        panel.add(new JButton(&quot;0&quot;));        panel.add(new JButton(&quot;.&quot;));        panel.add(new JButton(&quot;=&quot;));        panel.add(new JButton(&quot;+&quot;));        frame.add(panel);    //添加面板到容器        frame.setBounds(300,200,200,150);        frame.setVisible(true);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    &#125;&#125;</code></pre><blockquote><p>上述程序设置面板为 4 行 4 列、间隙都为 5 像素的网格布局，在该面板上包含 16 个按钮，其横向和纵向的间隙都为 5。该程序的运行结果如图所示：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190305004128646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="五、网格包布局管理器-GridBagLayout"><a href="#五、网格包布局管理器-GridBagLayout" class="headerlink" title="五、网格包布局管理器(GridBagLayout)"></a><code>五、网格包布局管理器(GridBagLayout)</code></h4><h5 id="5-1-GridBagLayout"><a href="#5-1-GridBagLayout" class="headerlink" title="5.1 GridBagLayout"></a>5.1 GridBagLayout</h5><blockquote><p>GridBagLayout（网格包布局管理器）是在网格基础上提供复杂的布局，是最灵活、 最复杂的布局管理器。<code>GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。</code>每个 GridBagLayout 对象都维护了一组动态的矩形网格单元，每个组件占一个或多个单元，所占有的网格单元称为组件的显示区域。<br>GridBagLayout 所管理的每个组件都与一个 GridBagConstraints 约束类的对象相关。这个约束类对象指定了组件的显示区域在网格中的位置，以及在其显示区域中应该如何摆放组件。除了组件的约束对象，GridBagLayout 还要考虑每个组件的最小和首选尺寸，以确定组件的大小。</p></blockquote><h5 id="5-2-GridBagLayout属性设置"><a href="#5-2-GridBagLayout属性设置" class="headerlink" title="5.2 GridBagLayout属性设置"></a>5.2 GridBagLayout属性设置</h5><blockquote><p>为了有效地利用网格包布局管理器，在向容器中添加组件时，必须定制某些组件的相关约束对象。GridBagConstraints 对象的定制是通过下列变量实现的。</p></blockquote><ul><li>1.gridx 和 gridy</li></ul><blockquote><p>用来指定组件左上角在网格中的行和列。<code>容器中最左边列的 gridx 为 0，最上边行的 gridy 为 0。</code>这两个变量的默认值是GridBagConstraints.RELATIVE，表示对应的组件将放在前一个组件的右边或下面。</p></blockquote><ul><li>2.gridwidth 和 gridheight</li></ul><blockquote><p><code>用来指定组件显示区域所占的列数和行数，以网格单元而不是像素为单位，默认值为 1。</code></p></blockquote><ul><li>3.fill</li></ul><blockquote><p><code>指定组件填充网格的方式</code>，可以是如下值：GridBagConstraints.NONE（默认值）、GridBagConstraints.HORIZONTAL（组件横向充满显示区域，但是不改变组件高度）、GridBagConstraints.VERTICAL（组件纵向充满显示区域，但是不改变组件宽度）以及 GridBagConstraints.BOTH（组件横向、纵向充满其显示区域）。</p></blockquote><ul><li>4.ipadx 和 ipady</li></ul><blockquote><p><code>指定组件显示区域的内部填充，</code>即在组件最小尺寸之外需要附加的像素数，<code>默认值为 0。</code></p></blockquote><ul><li>5.insets</li></ul><blockquote><p><code>指定组件显示区域的外部填充，</code>即组件与其显示区域边缘之间的空间， <code>默认组件没有外部填充。</code></p></blockquote><ul><li>6.anchor</li></ul><blockquote><p><code>指定组件在显示区域中的摆放位置。</code>可选值有 GridBagConstraints.CENTER（默认值）、GridBagConstraints.NORTH、GridBagConstraints.NORTHEAST、GridBagConstraints.EAST、GridBagConstraints.SOUTH、GridBagConstraints.SOUTHEAST、GridBagConstraints.WEST、GridBagConstraints.SOUTHWEST 以及 GridBagConstraints.NORTHWEST。</p></blockquote><ul><li>7.weightx 和 weighty</li></ul><blockquote><p><code>用来指定在容器大小改变时，增加或减少的空间如何在组件间分配，默认值为 0，</code>即所有的组件将聚拢在容器的中心，多余的空间将放在容器边缘与网格单元之间。weightx 和 weighty 的取值一般在 0.0 与 1.0 之间，数值大表明组件所在的行或者列将获得更多的空间。</p></blockquote><h5 id="5-3-示例"><a href="#5-3-示例" class="headerlink" title="5.3 示例"></a>5.3 示例</h5><blockquote><p>创建一个窗口，使用 GridBagLayout 进行布局，实现一个简易的手机拨号盘。这里要注意如何控制行内组件的显示方式以及使用 GridBagConstraints.REMAINDER 来控制一行的结束。代码的实现如下：</p></blockquote><pre><code>import javax.swing.*;import java.awt.*;public class GridBagLayoutDemo &#123;    //向JFrame中添加JButton按钮    public static void makeButton(String title,JFrame frame,GridBagLayout gridBagLayout,GridBagConstraints constraints) &#123;        JButton button=new JButton(title);    //创建Button对象        gridBagLayout.setConstraints(button,constraints);        frame.add(button);    &#125;    public static void main(String[] agrs) &#123;        JFrame frame=new JFrame(&quot;拨号盘&quot;);        GridBagLayout gbaglayout=new GridBagLayout();    //创建GridBagLayout布局管理器        GridBagConstraints constraints=new GridBagConstraints();        frame.setLayout(gbaglayout);    //使用GridBagLayout布局管理器        constraints.fill = GridBagConstraints.BOTH;    //组件填充显示区域        constraints.weightx=0.0;    //恢复默认值        constraints.gridwidth = GridBagConstraints.REMAINDER;    //结束行        JTextField tf=new JTextField(&quot;13612345678&quot;);        gbaglayout.setConstraints(tf, constraints);        frame.add(tf);        constraints.weightx=0.5;    // 指定组件的分配区域        constraints.weighty=0.2;        constraints.gridwidth=1;        makeButton(&quot;7&quot;,frame,gbaglayout,constraints);    //调用方法，添加按钮组件        makeButton(&quot;8&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=GridBagConstraints.REMAINDER;    //结束行        makeButton(&quot;9&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=1;    //重新设置gridwidth的值        makeButton(&quot;4&quot;,frame,gbaglayout,constraints);        makeButton(&quot;5&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=GridBagConstraints.REMAINDER;        makeButton(&quot;6&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=1;        makeButton(&quot;1&quot;,frame,gbaglayout,constraints);        makeButton(&quot;2&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=GridBagConstraints.REMAINDER;        makeButton(&quot;3&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=1;        makeButton(&quot;返回&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=GridBagConstraints.REMAINDER;        makeButton(&quot;拨号&quot;,frame,gbaglayout,constraints);        constraints.gridwidth=1;        frame.setBounds(400,400,400,400);    //设置容器大小        frame.setVisible(true);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    &#125;&#125;</code></pre><blockquote><p>在上述程序中创建了一个 makeButton() 方法，用来将 JButton 组件添加到 JFrame 窗口中。在 main() 方法中分别创建了 GridBagLayout 对象和 GridBagConstraints 对象，然后设置 JFrame 窗口的布局为 GridBagLayout，并设置了 GridBagConstraints 的一些属性。接着将 JTextField 组件添加至窗口中，并通知布局管理器的 GridBagConstraints 信息。<br>在接下来的代码中，调用 makeButton() 方法向 JFrame 窗口填充按钮，并使用 GridBagConstraints. REMAINDER 来控制结束行。当一行结束后，重新设置 GridBagConstraints 对象的 gridwidth 为 1。最后设置 JFrame 窗口为可见状态，程序运行后的拨号盘效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20190305005713575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h4 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h4><p>在Java中，事件处理机制是一种常用的编程模式，它允许程序响应用户操作、系统事件等各种不同类型的事件。以下是Java中的事件处理机制：</p><ol><li>事件源</li></ol><p>事件源是指能够产生事件的对象，例如按钮、文本框、菜单等。</p><ol start="2"><li>事件监听器</li></ol><p>事件监听器是一个接口，定义了用于监听特定事件的方法。通常情况下，每个事件都有自己对应的事件监听器。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ActionListener &#123;</span><br><span class="line">    public void actionPerformed(ActionEvent e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>注册事件监听器</li></ol><p>将事件监听器注册到事件源上，以便在事件发生时能够被及时捕捉和处理。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JButton button = new JButton(&quot;Click me&quot;);</span><br><span class="line">button.addActionListener(new ActionListener() &#123; // 注册事件监听器</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        // 处理按钮单击事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>事件分发机制</li></ol><p>当事件发生时，事件源会创建一个相应的事件对象，并将其传递给已注册的所有事件监听器。事件监听器根据具体的事件类型来响应事件。</p><ol start="5"><li>处理事件</li></ol><p>在事件监听器中实现事件响应的具体逻辑，例如弹出对话框、更新界面等。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JButton button = new JButton(&quot;Click me&quot;);</span><br><span class="line">button.addActionListener(new ActionListener() &#123; // 注册事件监听器</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        JOptionPane.showMessageDialog(null, &quot;Button clicked&quot;); // 弹出对话框</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用事件处理机制时应该选择合适的事件源和事件监听器，并遵循事件驱动的编程模式来开发程序，以便实现良好的交互效果和用户体验。</p><h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><h4 id="进程和线程的区别（了解）"><a href="#进程和线程的区别（了解）" class="headerlink" title="进程和线程的区别（了解）"></a>进程和线程的区别（了解）</h4><p>进程和线程都是操作系统中用于实现多任务的概念，但它们有以下区别：</p><ol><li>调度对象</li></ol><p>进程是操作系统中资源分配的基本单位，一个进程可以包含多个线程，每个进程拥有独立的内存空间和系统资源。线程是进程的一个执行单元，线程共享进程的内存空间和系统资源。</p><ol start="2"><li>系统开销</li></ol><p>创建和撤销进程需要较大的系统开销，包括内存空间、系统资源等的分配和回收。而创建和撤销线程的系统开销很小，因为它们共享进程的资源。</p><ol start="3"><li>并发性能</li></ol><p>由于进程拥有独立的内存空间和系统资源，因此在多核CPU上能够实现真正的并发执行，但进程切换的代价较高。而线程共享进程的资源，因此在线程之间的切换代价较小，但在多核CPU上并不能实现真正的并发执行。</p><ol start="4"><li>通信方式</li></ol><p>由于进程之间拥有独立的内存空间，因此它们必须通过IPC（进程间通信）机制进行通信。而线程之间共享进程的内存空间，因此它们可以直接访问共享的数据结构来进行通信。</p><p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p><h4 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h4><ol><li>继承Thread类</li></ol><p>继承Thread类并重写run()方法来定义线程的执行逻辑。使用start()方法启动线程。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread thread = new MyThread();</span><br><span class="line">thread.start(); // 启动线程</span><br></pre></td></tr></table></figure><ol start="2"><li>实现Runnable接口</li></ol><p>实现Runnable接口并重写run()方法来定义线程的执行逻辑。将Runnable对象作为参数传递给Thread类的构造方法以创建线程，并使用start()方法启动线程。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyRunnable runnable = new MyRunnable();</span><br><span class="line">Thread thread = new Thread(runnable);</span><br><span class="line">thread.start(); // 启动线程</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p><p>3.在Java中，有两种创建多线程的方式：继承 <code>Thread</code> 类和实现 <code>Runnable</code> 接口。但是，这两种方式都只能返回 <code>void</code> 类型的结果，如果要求线程执行完毕后返回一个结果，可以使用 <code>Callable</code> 接口。</p><p><code>Callable</code> 是类似于 <code>Runnable</code> 的接口，它们都是为那些其实例可能被另一个线程执行的类设计的。一个关键的区别是 <code>Callable</code> 支持泛型的返回值，而在 <code>Runnable</code> 中的 <code>run()</code> 方法则不能有任何返回值。</p><p>下面是使用 <code>Callable</code> 接口创建多线程的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(new MyCallable());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例代码中，我们定义了一个实现了 <code>Callable</code> 接口的类 <code>MyCallable</code>，其中 <code>call()</code> 方法返回一个 <code>Integer</code> 类型的值，表示对 1 到 100 求和的结果。然后，在 <code>main()</code> 方法中，我们通过 <code>ExecutorService</code> 接口创建了一个单一线程池，并通过 <code>submit()</code> 方法提交了一个 <code>MyCallable</code> 类的实例。最后，通过 <code>Future</code> 接口的 <code>get()</code> 方法获取线程执行的结果。</p><p>需要注意的是，在使用 <code>Callable</code> 创建多线程时，我们需要使用 <code>ExecutorService</code> 接口来管理线程池。并且，<code>Future</code> 接口的 <code>get()</code> 方法会阻塞当前线程，直到任务完成并返回结果。 </p><h4 id="线程的生命周期及其状态转换"><a href="#线程的生命周期及其状态转换" class="headerlink" title="线程的生命周期及其状态转换"></a>线程的生命周期及其状态转换</h4><p>在Java中，线程的生命周期可以描述为以下五个状态：</p><ol><li>新建状态（New）</li></ol><p>当线程对象被创建时，它处于新建状态。此时还没有开始执行线程的run()方法。</p><ol start="2"><li>就绪状态（Runnable）</li></ol><p>当线程调用start()方法后，它进入就绪状态。此时线程已经获得了除CPU以外的所有资源，只等待系统为其分配CPU资源。</p><ol start="3"><li>运行状态（Running）</li></ol><p>当线程获得CPU资源后，它进入运行状态。此时线程开始执行run()方法中的逻辑代码。</p><ol start="4"><li>阻塞状态（Blocked）</li></ol><p>当线程因为某些原因无法继续执行时，例如线程调用sleep()方法、等待I&#x2F;O操作完成等，它进入阻塞状态。此时线程不会占用CPU时间，也不会参与竞争CPU资源。</p><ol start="5"><li>终止状态（Terminated）</li></ol><p>当线程执行完run()方法或者发生异常而导致线程中断时，它进入终止状态。此时线程已经完成了它的使命，不再具有可执行性。</p><p>线程之间可以相互转换状态，主要包括以下三种状态转换：</p><ol><li><p>就绪状态 -&gt; 运行状态：当线程获得CPU资源时，它从就绪状态转换到运行状态。</p></li><li><p>运行状态 -&gt; 阻塞状态：当线程调用sleep()方法、wait()方法等导致它无法继续执行时，它从运行状态转换到阻塞状态。</p></li><li><p>阻塞状态 -&gt; 就绪状态：当线程调用sleep()方法、wait()方法等过程结束后，它从阻塞状态转换回就绪状态。</p></li></ol><p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p><p><img src="file:///C:/Users/26927/Pictures/Typedown/3385e99f-6fa8-42ec-a24b-a48134c68fa9.png" alt="3385e99f-6fa8-42ec-a24b-a48134c68fa9"></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="java-thread"></p><h4 id="多线程的同步"><a href="#多线程的同步" class="headerlink" title="多线程的同步"></a>多线程的同步</h4><p>在多线程编程中，由于多个线程可能会同时访问和修改共享的资源，因此需要采取措施来保证线程之间的安全性和正确性。常用的同步方法有以下几种：</p><ol><li>synchronized关键字</li></ol><p>synchronized关键字可以修饰方法或代码块，它可以保证同一时间只有一个线程访问被synchronized修饰的代码区域。当线程进入synchronized代码块时，会自动获取相应对象的锁，其他线程必须等待该线程执行完毕后才能继续执行。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increment() &#123;</span><br><span class="line">    // 对共享资源进行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Lock接口</li></ol><p>Lock接口提供了比synchronized更加灵活和高级的锁机制，它支持更多的锁类型、多个条件变量等功能。使用Lock接口时需要手动获取和释放锁，以保证同一时间只有一个线程访问关键代码区域。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock(); // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    // 对共享资源进行操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock(); // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>volatile关键字</li></ol><p>volatile关键字用于修饰共享变量，它可以保证所有线程都能够看到最新的变量值，从而避免出现重排序等问题。但是volatile并不能保证多个线程之间对共享变量进行复合操作的原子性，因此在这种情况下还需要采用其他同步方式。</p><p>在Java中，volatile是一种轻量级的同步机制，它可以保证多个线程访问共享变量时能够看到最新的值。具体来说，使用volatile关键字修饰的变量具有以下特性：</p><ol><li>可见性</li></ol><p>当一个线程修改了volatile变量的值时，其他线程都能够立即看到最新的值，而不会出现数据脏读等问题。</p><ol start="2"><li>原子性</li></ol><p>对于单次读&#x2F;写操作的变量，volatile关键字保证了其原子性（即操作不可被拆分），但是对于复合操作（例如i++）依然无法保证其原子性。</p><ol start="3"><li>禁止指令重排</li></ol><p>编译器和处理器在执行程序时为了提高效率，可能会对指令进行重排序，但这种重排序可能会导致程序出错。使用volatile关键字可以禁止指令重排，从而确保程序的正确性和安全性。</p><p>需要注意的是，虽然volatile可以保证可见性和禁止指令重排，但是它并不能替代锁机制，因此在需要保证原子性的操作中仍然需要采用锁或其他同步机制。</p><p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p><h4 id="多线程之间的通信"><a href="#多线程之间的通信" class="headerlink" title="多线程之间的通信"></a>多线程之间的通信</h4><p>在线程之间进行通信是多线程编程中非常重要的一部分，这可以帮助不同的线程协调工作并共享数据。常用的多线程通信方式有以下几种：</p><ol><li>wait()和notify()&#x2F;notifyAll()</li></ol><p>wait()和notify()&#x2F;notifyAll()方法是Object类中定义的方法，它们用于实现线程之间的等待和唤醒。当一个线程调用wait()方法时，它会释放对象的锁并进入等待状态，直到其他线程调用notify()&#x2F;notifyAll()方法来唤醒它；而当一个线程调用notify()&#x2F;notifyAll()方法时，它会唤醒一个或所有正在等待该对象的线程。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.wait(); // 等待被唤醒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            // 执行相应操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyThread() &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            lock.notify(); // 唤醒等待线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>CountDownLatch类</li></ol><p>CountDownLatch类是Java提供的一种多线程同步工具，它可以让一个或多个线程等待其他线程完成操作后再继续执行。在初始化CountDownLatch时需要指定计数器的初始值，每当一个线程完成相应操作时，计数器的值就会减1；当计数器的值减为0时，等待线程就会被唤醒。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public MyRunnable(CountDownLatch latch) &#123;</span><br><span class="line">        this.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 执行相应操作</span><br><span class="line">        latch.countDown(); // 计数器减1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CountDownLatch latch = new CountDownLatch(10);</span><br><span class="line">for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(new MyRunnable(latch)).start();</span><br><span class="line">&#125;</span><br><span class="line">latch.await(); // 等待所有线程完成操作</span><br></pre></td></tr></table></figure><ol start="3"><li>CyclicBarrier类</li></ol><p>CyclicBarrier类也是Java提供的一种多线程同步工具，它可以让多个线程在某个屏障处等待，并在所有线程都到达屏障时继续执行。在初始化CyclicBarrier时需要指定参与线程的数量，每当一个线程到达屏障时，它就会调用await()方法等待其他线程；当所有线程都到达屏障时，它们就可以继续执行。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    public MyRunnable(CyclicBarrier barrier) &#123;</span><br><span class="line">        this.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 执行相应操作</span><br><span class="line">        barrier.await(); // 等待其他线程到达屏障</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CyclicBarrier barrier = new CyclicBarrier(10);</span><br><span class="line">for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(new MyRunnable(barrier)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p><h4 id="线程池的使用（了解）"><a href="#线程池的使用（了解）" class="headerlink" title="线程池的使用（了解）"></a>线程池的使用（了解）</h4><p>线程池可以有效地管理和复用线程，从而提高程序的运行效率和性能。Java中提供了ThreadPoolExecutor类来实现线程池的功能，其使用方法如下：</p><ol><li>创建线程池</li></ol><p>可以通过ThreadPoolExecutor类的构造函数来创建一个线程池，其中需要指定核心线程数、最大线程数、线程空闲时间等参数。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="line">    5, // 核心线程数</span><br><span class="line">    10, // 最大线程数</span><br><span class="line">    60, // 线程空闲时间（秒）</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    new ArrayBlockingQueue&lt;Runnable&gt;(100)); // 任务队列</span><br></pre></td></tr></table></figure><ol start="2"><li>提交任务</li></ol><p>可以通过executor.submit()或executor.execute()方法来向线程池提交任务，其中submit()方法返回一个Future对象，可以用于获取任务执行结果。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 执行相应任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭线程池</li></ol><p>可以通过executor.shutdown()或executor.shutdownNow()方法来关闭线程池，其中shutdown()方法是平滑关闭线程池，会等待所有任务执行完毕后再关闭；而shutdownNow()方法是强制关闭线程池，会立即终止所有正在执行的任务。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.shutdown(); // 平滑关闭线程池</span><br><span class="line">// 或者</span><br><span class="line">executor.shutdownNow(); // 强制关闭线程池</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用线程池时应该合理地设置核心线程数、最大线程数和任务队列大小，以避免因线程过多或任务过多导致系统资源不足或死锁等问题。同时，也应该遵循线程安全的原则来编写并发程序，以保证程序的正确性和稳定性。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h3><h4 id="网络通信协议-了解"><a href="#网络通信协议-了解" class="headerlink" title="网络通信协议(了解)"></a>网络通信协议(了解)</h4><p>网络通信协议是计算机网络中用于规定数据传输格式和传输方式的约定，是保证网络通信正确、高效、安全的基础。常见的网络通信协议有以下几种：</p><ol><li>TCP&#x2F;IP协议</li></ol><p>TCP&#x2F;IP协议是Internet网络使用的最基本的协议，它包括两个部分：传输控制协议（TCP）和互联网协议（IP）。TCP负责可靠地传输数据，确保数据的正确性和完整性；而IP负责将数据包从源主机传输到目标主机。</p><ol start="2"><li>HTTP协议</li></ol><p>HTTP协议是超文本传输协议，它是一种基于请求-响应模式的协议，常用于Web应用中进行客户端和服务器之间的通信。HTTP使用TCP作为其传输层协议，支持三种请求方法：GET、POST和HEAD。</p><ol start="3"><li>FTP协议</li></ol><p>FTP协议是文件传输协议，用于在客户端和服务器之间传输文件。FTP使用TCP作为其传输层协议，支持文件上传、下载、重命名等操作。</p><ol start="4"><li>SMTP协议</li></ol><p>SMTP协议是简单邮件传输协议，用于在不同的邮件系统之间传送邮件。SMTP使用TCP作为其传输层协议，支持邮件发送、接收、转发等操作。</p><ol start="5"><li>DNS协议</li></ol><p>DNS协议是域名系统协议，用于将域名转换成IP地址或反向解析。DNS使用UDP作为其传输层协议，支持域名解析、缓存查询等操作。</p><ol start="6"><li>SSL&#x2F;TLS协议</li></ol><p>SSL&#x2F;TLS协议是安全套接字层&#x2F;传输层安全协议，用于保护网络通信的安全性。SSL&#x2F;TLS使用TCP作为其传输层协议，在数据传输过程中使用加密技术和数字证书来确保数据的保密性和完整性。</p><p>需要注意的是，不同的网络通信协议具有不同的特点和适用范围，应根据具体需求选择合适的协议，并遵守相应的协议规范来编写程序。同时，也应该关注网络安全问题，采取相应措施保障数据的安全性和隐私性。</p><h6 id="TCP-x2F-IP参考模型"><a href="#TCP-x2F-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h6><p><img src="file:///C:/Users/26927/Pictures/Typedown/207be562-0a32-4f5c-8b85-8563a8c56db7.png" alt="207be562-0a32-4f5c-8b85-8563a8c56db7"></p><p>TCP&#x2F;IP参考模型分为四层，从下往上依次是：网络接口层、网络层、传输层和应用层。每个层次都有其特定功能，并且使用不同的协议来实现这些功能。具体地：</p><ol><li><p><strong>网络接口层</strong>：该层负责处理与物理媒介（如网线、光纤等）相关的所有问题，包括数据在媒介上传输的方式、流控制、错误检测和物理寻址等。在TCP&#x2F;IP模型中，这一层对应OSI模型中的物理层和数据链路层。常见的协议有Ethernet、Wi-Fi、PPP等。</p></li><li><p><strong>网络层</strong>：该层主要是解决数据在网络中的传输问题，包括数据包的路由选择和转发、IP地址的管理和分配等。在TCP&#x2F;IP模型中，这一层对应OSI模型中的网络层。常见的协议有IP、ICMP、ARP等。</p></li><li><p><strong>传输层</strong>：该层负责数据的可靠传输，包括建立连接、流量控制、数据重传等功能。在TCP&#x2F;IP模型中，这一层对应OSI模型中的传输层和会话层。常见的协议有TCP、UDP等。</p></li><li><p><strong>应用层</strong>：该层提供网络应用程序与用户之间的接口，负责实现具体的应用功能，如电子邮件、文件传输、网页浏览等。在TCP&#x2F;IP模型中，这一层对应OSI模型中的表示层和应用层。常见的协议有HTTP、FTP、SMTP等。</p></li></ol><h4 id="UDP通信-了解"><a href="#UDP通信-了解" class="headerlink" title="UDP通信(了解)"></a>UDP通信(了解)</h4><p>UDP通信是一种基于用户数据报协议（User Datagram Protocol，简称UDP）的无连接网络通信方式，它不需要像TCP一样先建立连接再进行数据传输，因此在网络上的实时性和效率比较高。</p><p>UDP通信的特点如下：</p><ol><li>无连接</li></ol><p>UDP通信不需要像TCP一样先建立连接，可以直接发送数据包。因此，UDP的开销比TCP要小，适用于一些实时性要求高的场合。</p><ol start="2"><li>不可靠</li></ol><p>由于UDP没有连接的概念，所以不会保证数据传输的可靠性，可能会出现数据丢失、重复、乱序等问题。</p><ol start="3"><li>简单</li></ol><p>相对于TCP而言，UDP的实现比较简单，代码量也比较少，因此在实现一些简单的网络应用时，可以考虑使用UDP。</p><p>UDP通信的使用步骤如下：</p><ol><li>创建DatagramSocket对象，并指定客户端的IP地址和端口号。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket = new DatagramSocket();</span><br><span class="line">InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">int port = 8888;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建DatagramPacket对象，用于封装数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = &quot;Hello, UDP!&quot;.getBytes();</span><br><span class="line">DatagramPacket packet = new DatagramPacket(data, data.length, address, port);</span><br></pre></td></tr></table></figure></li><li><p>发送数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(packet);</span><br></pre></td></tr></table></figure></li><li><p>接收数据包。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);</span><br><span class="line">socket.receive(receivePacket);</span><br><span class="line">String message = new String(receivePacket.getData(), 0, receivePacket.getLength());</span><br></pre></td></tr></table></figure><ol start="5"><li><p>关闭DatagramSocket对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，在使用UDP通信时需要处理好数据传输的可靠性和安全性问题。例如，可以采用分组确认、校验码等技术来提高数据传输的可靠性；同时，也可以采用加密技术和数字签名等手段来保证数据的安全性和完整性</p><h4 id="TCP通信（了解）"><a href="#TCP通信（了解）" class="headerlink" title="TCP通信（了解）"></a>TCP通信（了解）</h4><p>TCP通信是一种基于传输控制协议（Transmission Control Protocol，简称TCP）的面向连接的网络通信方式，它可以保证数据传输的可靠性和完整性，被广泛应用于互联网上的各种应用中。</p><p>TCP通信的特点如下：</p><ol><li>面向连接</li></ol><p>TCP通信需要先建立连接，然后才能进行数据传输。在连接建立过程中会进行一系列的握手过程，以确保连接的可靠性和正确性。</p><ol start="2"><li>可靠性高</li></ol><p>由于TCP采用了一系列的流量控制、拥塞控制以及确认机制等技术，因此可以保证数据传输的可靠性和完整性，不容易出现数据丢失、重复、乱序等问题。</p><ol start="3"><li>稳定性好</li></ol><p>TCP通信具有较好的稳定性，即使在网络状况较差的情况下也可以保持较高的传输效率和速度。</p><p>TCP通信的使用步骤如下：</p><ol><li>创建Socket对象，并指定服务器的IP地址和端口号。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);</span><br></pre></td></tr></table></figure><ol start="2"><li>获取输入输出流，进行数据的读写操作。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">// 读取数据</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int length = inputStream.read(buffer);</span><br><span class="line">String message = new String(buffer, 0, length);</span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">String data = &quot;Hello, TCP!&quot;;</span><br><span class="line">outputStream.write(data.getBytes());</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭Socket对象。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用TCP通信时需要处理好连接建立和断开的过程，以及数据传输的可靠性和安全性问题。例如，可以采用连接池和连接复用技术来提高连接的利用率；同时，也可以采用加密技术和数字签名等手段来保证数据的安全性和完整性。</p><h4 id="网络程序的开发"><a href="#网络程序的开发" class="headerlink" title="网络程序的开发"></a>网络程序的开发</h4><p>网络程序的开发一般需要遵循以下步骤：</p><ol><li>设计网络协议</li></ol><p>在进行网络程序开发之前，需要首先设计好通信协议，即规定数据传输格式和传输方式的约定。这是保证网络通信正确、高效、安全的基础。常见的网络通信协议有TCP&#x2F;IP、HTTP、FTP、SMTP等，应根据具体需求选择合适的协议，并遵守相应的协议规范来编写程序。</p><ol start="2"><li>编写服务器端程序</li></ol><p>服务器端程序一般用于监听客户端的请求，并进行相应的处理。在编写服务器端程序时，需要使用相应的网络库或框架，例如Java中的Socket、ServerSocket、Netty、Spring Boot等，根据设计好的协议进行数据处理和响应。</p><ol start="3"><li>编写客户端程序</li></ol><p>客户端程序一般用于向服务器端发送请求，并接收服务器端的响应。在编写客户端程序时，也需要使用相应的网络库或框架，例如Java中的Socket、URLConnection、HttpClient、OkHttp等，根据设计好的协议进行数据的读写。</p><ol start="4"><li>测试和调试</li></ol><p>完成程序的编写后，需要进行测试和调试，以确保程序的正确性和稳定性。可以采用各种工具和技术，例如Junit、Mockito、Postman、Wireshark等，对程序进行单元测试、集成测试、接口测试、网络流量分析等，及时发现并修复问题。</p><ol start="5"><li>部署和运维</li></ol><p>当程序测试通过后，就可以进行部署和运维了。需要将程序发布到相应的服务器上，配置好环境和参数，并设置相应的监控和日志系统，以便及时发现和解决问题。同时，也需要对程序进行维护和更新，以满足不断变化的业务需求和安全风险。</p><p>在Java中，可以使用多种方式来开发网络程序，常用的包括Socket、ServerSocket、URLConnection、HttpClient、Netty等。</p><p>使用Socket和ServerSocket：</p><p>Socket和ServerSocket是Java中最基本的网络编程类，它们提供了TCP&#x2F;IP协议的支持，可以实现客户端和服务器之间的通信。其中，Socket用于建立连接并进行数据传输，而ServerSocket用于监听客户端的请求和接受连接。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">while (true) &#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    InputStream inputStream = socket.getInputStream();</span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">    // 读取客户端发送的数据</span><br><span class="line">    byte[] buffer = new byte[1024];</span><br><span class="line">    int length = inputStream.read(buffer);</span><br><span class="line">    String message = new String(buffer, 0, length);</span><br><span class="line"></span><br><span class="line">    // 处理数据</span><br><span class="line">    String response = &quot;Hello, &quot; + message;</span><br><span class="line"></span><br><span class="line">    // 发送响应数据</span><br><span class="line">    outputStream.write(response.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);</span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">String data = &quot;World!&quot;;</span><br><span class="line">outputStream.write(data.getBytes());</span><br><span class="line"></span><br><span class="line">// 接收响应数据</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int length = inputStream.read(buffer);</span><br><span class="line">String response = new String(buffer, 0, length);</span><br></pre></td></tr></table></figure><p> 使用URLConnection和HttpClient：</p><p>除了使用Socket和ServerSocket外，还可以使用Java内置的URLConnection和第三方库HttpClient来进行网络编程。URLConnection支持HTTP协议，可以实现简单的HTTP请求和响应。而HttpClient则是一个功能强大的HTTP客户端库，可以实现各种HTTP请求和响应。以下是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 使用URLConnection发送GET请求</span><br><span class="line">URL url = new URL(&quot;http://example.com&quot;);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">connection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line"></span><br><span class="line">InputStream inputStream = connection.getInputStream();</span><br><span class="line">BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">StringBuilder response = new StringBuilder();</span><br><span class="line">String line;</span><br><span class="line">while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">    response.append(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用HttpClient发送POST请求</span><br><span class="line">CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">HttpPost httpPost = new HttpPost(&quot;http://example.com&quot;);</span><br><span class="line">httpPost.setEntity(new StringEntity(&quot;&#123;\&quot;key\&quot;:\&quot;value\&quot;&#125;&quot;));</span><br><span class="line"></span><br><span class="line">CloseableHttpResponse httpResponse = httpClient.execute(httpPost);</span><br><span class="line">HttpEntity entity = httpResponse.getEntity();</span><br><span class="line">String response = EntityUtils.toString(entity);</span><br></pre></td></tr></table></figure><p>使用Netty：</p><p>Netty是一个基于NIO的高性能网络编程框架，可以快速开发复杂的网络应用。它提供了丰富、灵活的API和事件模型，支持各种协议和编解码器。以下是一个简单的Netty案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">try &#123;</span><br><span class="line">    ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">    bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                     ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                     pipeline.addLast(new StringDecoder());</span><br><span class="line">                     pipeline.addLast(new StringEncoder());</span><br><span class="line">                     pipeline.addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                         @Override</span><br><span class="line">                         protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;</span><br><span class="line">                             String response = &quot;Hello, &quot; + msg;</span><br><span class="line">                             ctx.channel().writeAndFlush(response);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    ChannelFuture future = bootstrap.bind(8888).sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">try &#123;</span><br><span class="line">    Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">    bootstrap.group(group)</span><br><span class="line">             .channel(NioSocketChannel.class)</span><br><span class="line">             .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                     ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                     pipeline.addLast(new StringDecoder());</span><br><span class="line">                     pipeline.addLast(new StringEncoder());</span><br><span class="line">                     pipeline.addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                         @Override</span><br><span class="line">                         protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;</span><br><span class="line">                             System.out.println(msg);</span><br><span class="line">                             ctx.channel().close();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">    ChannelFuture future = bootstrap.connect(&quot;127.0.0.1&quot;, 8888).sync();</span><br><span class="line">    future.channel().writeAndFlush(&quot;World!&quot;).sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在进行网络程序开发时，需要处理好数据传输的可靠性和安全性问题。例如，可以采用分组确认、校验码、加密技术和数字签名等技术来提高数据传输的可靠性和安全性；同时，也应该关注网络攻击和安全漏洞等问题，采取相应措施保障网络的安全性。 </p><h3 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h3><h4 id="JDBC原理（了解）"><a href="#JDBC原理（了解）" class="headerlink" title="JDBC原理（了解）"></a>JDBC原理（了解）</h4><p><img src="file:///C:/Users/26927/Pictures/Typedown/53456b23-3d52-44f5-95db-3e65db0e04dc.png" alt="53456b23-3d52-44f5-95db-3e65db0e04dc"></p><p>JDBC是Java数据库连接的标准接口，它定义了一组用于访问和操作数据库的API。在使用JDBC时，可以通过DriverManager类来获取数据库连接，并使用Connection、Statement、PreparedStatement、ResultSet等接口来进行数据库操作。</p><p>JDBC的工作原理如下：</p><p><img src="file:///C:/Users/26927/Pictures/Typedown/56ad66ce-a912-4aaa-a2c7-577052c7e9f9.png" alt="56ad66ce-a912-4aaa-a2c7-577052c7e9f9"></p><ol><li>加载并注册数据库驱动</li></ol><p>要想连接数据库，首先需要加载并注册数据库驱动。可以通过Class.forName()方法或DriverManager.registerDriver()方法来完成这一步骤。</p><ol start="2"><li>建立数据库连接</li></ol><p>在注册完数据库驱动后，就可以使用DriverManager.getConnection()方法来获取数据库连接。该方法需要传入数据库URL、用户名和密码等参数。如果连接成功，则返回一个Connection对象，否则抛出SQLException异常。</p><ol start="3"><li>创建和执行SQL语句</li></ol><p>在获取到Connection对象后，就可以使用Statement、PreparedStatement等接口来创建和执行SQL语句。其中，Statement适用于静态SQL语句，而PreparedStatement适用于动态SQL语句。调用executeUpdate()方法可以执行更新操作，调用executeQuery()方法可以执行查询操作，并返回一个ResultSet对象。</p><ol start="4"><li>处理查询结果</li></ol><p>对于执行查询操作返回的ResultSet对象，可以使用其提供的方法来遍历结果集、获取数据、关闭资源等操作。例如，可以使用next()方法来将游标移动到下一行，并返回一个布尔值表示是否还有更多的行；也可以使用getString()、getInt()等方法来获取指定列的数据。</p><ol start="5"><li>关闭连接和资源</li></ol><p>当最终完成数据库操作后，应该及时关闭数据库连接和相关资源，以释放资源并避免内存泄漏。可以分别调用Connection、Statement和ResultSet对象的close()方法来实现关闭。</p><p>需要注意的是，在使用JDBC进行数据库编程时，应该遵循事务管理、连接池复用、预编译SQL语句等最佳实践，以提高程序的性能和可靠性。同时，也应该注意处理SQL注入等安全问题，采取相应措施保障数据的安全性。</p><h4 id="Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；"><a href="#Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；" class="headerlink" title="Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；"></a>Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；</h4><p>在JDBC中，Connection、Statement、ResultSet和PreparedStatement是常用的接口，用于进行数据库操作。</p><ol><li>Connection接口<br><img src="file:///C:/Users/26927/Pictures/Typedown/e456d783-f2f2-41c8-b426-2b0d1f6988d6.png" alt="e456d783-f2f2-41c8-b426-2b0d1f6988d6"><br><img src="file:///C:/Users/26927/Pictures/Typedown/82810560-a2f7-468d-a0bf-cc0cd2a366f5.png" alt="82810560-a2f7-468d-a0bf-cc0cd2a366f5"></li></ol><p>Connection接口代表一个与数据库的物理连接。使用该接口可以创建Statement、PreparedStatement等对象，也可以控制事务提交、回滚等操作。以下是使用Connection接口建立与MySQL数据库的连接的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/mydatabase&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure><ol start="2"><li>Statement接口<br><img src="file:///C:/Users/26927/Pictures/Typedown/49f5e2f0-9b02-4080-93b2-24803483ef17.png" alt="49f5e2f0-9b02-4080-93b2-24803483ef17"></li></ol><p>Statement接口用于执行静态SQL语句（即在编译期就已经确定的SQL语句）。它提供了executeQuery()、executeUpdate()、execute()等方法来执行SQL语句，并返回ResultSet或int类型的结果。以下是使用Statement执行查询操作的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>ResultSet接口</li><li><img src="file:///C:/Users/26927/Pictures/Typedown/256c026c-3def-47f9-8410-35f67b6bd683.png" alt="256c026c-3def-47f9-8410-35f67b6bd683"></li></ol><p>ResultSet接口代表一个结果集，其中包含查询到的数据。它提供了各种获取数据的方法，例如getInt()、getString()、getDouble()等方法。以下是使用ResultSet获取数据的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>PreparedStatement接口<br><img src="file:///C:/Users/26927/Pictures/Typedown/01bd44fd-44ca-4101-a9a6-edd48f5f3bfc.png" alt="01bd44fd-44ca-4101-a9a6-edd48f5f3bfc"></p></li><li><p><img src="file:///C:/Users/26927/Pictures/Typedown/92a78951-33e1-4e67-b96b-0a9c00075090.png" alt="92a78951-33e1-4e67-b96b-0a9c00075090"></p></li></ol><p>PreparedStatement接口用于执行动态SQL语句（即在运行期通过变量拼接而成的SQL语句）。相比Statement接口，PreparedStatement可以预编译SQL语句，在多次执行同一条SQL语句时可以提高性能，并且可以避免SQL注入攻击。以下是使用PreparedStatement执行插入操作的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pstmt = conn.prepareStatement(&quot;INSERT INTO users(name, age) VALUES (?, ?)&quot;);</span><br><span class="line">pstmt.setString(1, &quot;Tom&quot;);</span><br><span class="line">pstmt.setInt(2, 18);</span><br><span class="line">int rowsAffected = pstmt.executeUpdate();</span><br></pre></td></tr></table></figure><p>以上是这四个接口的简单使用示例，实际开发中需要根据具体情况使用不同的接口来完成不同的数据库操作，同时注意处理异常、释放资源等问题</p><h4 id="使用JDBC操作数据库"><a href="#使用JDBC操作数据库" class="headerlink" title="使用JDBC操作数据库"></a>使用JDBC操作数据库</h4><p>使用JDBC操作数据库通常需要以下步骤：</p><ol><li>加载驱动程序</li></ol><p>在JDBC中，每个数据库驱动都由一个类实现。因此，首先需要通过Class.forName()方法加载相应的驱动程序类。例如，在MySQL中，可以使用以下代码来加载MySQL驱动程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>建立连接</li></ol><p>在加载完驱动程序后，就可以使用DriverManager.getConnection()方法建立与数据库的连接。该方法需要传入数据库URL、用户名和密码等参数。例如，在MySQL中，可以使用以下代码来建立数据库连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/mydatabase&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建Statement或PreparedStatement对象</li></ol><p>在建立连接之后，就可以创建Statement或PreparedStatement对象，用于执行SQL语句。其中，Statement适用于静态SQL语句，而PreparedStatement适用于动态SQL语句。例如，在MySQL中，可以使用以下代码来创建Statement对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br></pre></td></tr></table></figure><p>或者创建PreparedStatement对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pstmt = conn.prepareStatement(&quot;INSERT INTO users(name, age) VALUES (?, ?)&quot;);</span><br></pre></td></tr></table></figure><ol start="4"><li>执行SQL语句并处理结果</li></ol><p>在创建好Statement或PreparedStatement对象后，就可以调用其executeQuery()、executeUpdate()等方法执行SQL语句，并获取执行结果。例如，在MySQL中，可以使用以下代码来执行查询操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者执行插入操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pstmt.setString(1, &quot;Tom&quot;);</span><br><span class="line">pstmt.setInt(2, 18);</span><br><span class="line">int rowsAffected = pstmt.executeUpdate();</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭连接和相关资源</li></ol><p>在完成数据库操作后，应该及时关闭数据库连接和相关资源，以释放资源并避免内存泄漏。可以分别调用Connection、Statement和ResultSet对象的close()方法来实现关闭。</p><p>以上是使用JDBC操作数据库的基本流程，需要注意的是，实际开发中还需要考虑事务管理、异常处理、数据类型转换等问题，以保障程序的性能和可靠性。</p>]]></content>
    
    
    <summary type="html">java自用学习笔记，比较简陋，欢迎学习与交流</summary>
    
    
    
    <category term="java" scheme="https://bennettgao.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>黑马Python学习笔记</title>
    <link href="https://bennettgao.github.io/2023/08/15/%E9%BB%91%E9%A9%ACPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://bennettgao.github.io/2023/08/15/%E9%BB%91%E9%A9%ACPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-15T00:12:28.000Z</published>
    <updated>2023-09-12T12:08:21.161Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><ol><li><p>Pthon语言基础入门 </p></li><li><p>&amp;nbsp;Pthon语言高阶加强 </p></li><li><p>大数据分析PySpark</p></li><li><p>你好Python程序</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello World!!&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;Hello World!!</span><br></pre></td></tr></table></figure><p>！输入的双引号和括号为英文字符</p><h2 id="（一）-字面量"><a href="#（一）-字面量" class="headerlink" title="（一） 字面量"></a>（一） 字面量</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1. 定义：在代码中，被写下来的固定的值，称之为字面量。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2. 常用的6种值的类型</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3. 字符串</p><p>！Python中，字符串需要用双引号包围；</p><p>！被双引号包围的都是字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">666</span></span><br><span class="line"><span class="number">13.14</span></span><br><span class="line"><span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line"></span><br><span class="line">print( <span class="number">666</span> )</span><br><span class="line">print( <span class="number">13.14</span> )</span><br><span class="line">print( <span class="string">&quot;黑马程序员&quot;</span> )</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="number">666</span></span><br><span class="line">&gt;&gt;<span class="number">13.14</span></span><br><span class="line">&gt;&gt;<span class="string">&quot;黑马程序员&quot;</span></span><br></pre></td></tr></table></figure><h2 id="（二）-注释"><a href="#（二）-注释" class="headerlink" title="（二） 注释"></a>（二） 注释</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1. 单行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 我是单行注释</span><br><span class="line">print( <span class="string">&quot;黑马程序员&quot;</span> )</span><br></pre></td></tr></table></figure><p>！规范：#号和注释内容一般建议以一个空格隔开</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2. 多行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">         我是多行注释    </span></span><br><span class="line"><span class="string">         666</span></span><br><span class="line"><span class="string">         13.14</span></span><br><span class="line"><span class="string">         &quot;黑马程序员&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">print( <span class="number">666</span> )</span><br><span class="line">print( <span class="number">13.14</span> )</span><br><span class="line">print( <span class="string">&quot;黑马程序员&quot;</span> )</span><br></pre></td></tr></table></figure><h2 id="（三）-变量"><a href="#（三）-变量" class="headerlink" title="（三） 变量"></a>（三） 变量</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1. 定义：程序运行时，能储存计算结果或表示值的抽象概念。</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 简单的说，变量就是在程序运行时，记录数据用的</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2.定义格式：</p><p>变量名称 &#x3D; 变量的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 定义变量</span><br><span class="line">money = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"># print输出变量</span><br><span class="line">print( <span class="string">&quot; 钱包还有：&quot;</span> , money )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 钱包还有： <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"># 买了东西，花费<span class="number">10</span>元</span><br><span class="line">money = money - <span class="number">10</span></span><br><span class="line">print( <span class="string">&quot;买了冰淇淋花费10元，还剩余：&quot;</span> , money , <span class="string">&quot;元&quot;</span> )</span><br><span class="line"></span><br><span class="line">&gt;&gt;买了冰淇淋花费<span class="number">10</span>元，还剩余： <span class="number">4990</span> 元</span><br></pre></td></tr></table></figure><p>！变量值可变</p><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/95b19ca5662844c3ab314002927b9563.png" alt="img"></p><h2 id="（四）-数据类型"><a href="#（四）-数据类型" class="headerlink" title="（四） 数据类型"></a>（四） 数据类型</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1. type()语句【具有返回值】</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1）语法：</p><p>type(被查看类型的数据)</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2）使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = type( <span class="number">666</span> )</span><br><span class="line">print( a )</span><br><span class="line"></span><br><span class="line">print( type( <span class="number">13.14</span> ) )</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line">name_type = type( name )</span><br><span class="line">print( name_type )</span><br><span class="line"></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2. 变量无类型，查看变量的类型实际上查看的是变量存储数据的类型</p><p>！字符串变量：不是字符串是变量，而是变量存储了字符串</p><h2 id="（五）-数据类型转换"><a href="#（五）-数据类型转换" class="headerlink" title="（五） 数据类型转换"></a>（五） 数据类型转换</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1.&amp;nbsp; 常见的转换语句</p><p>！此三种语句具有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将数字类型  -&gt;  字符串类型</span><br><span class="line">num_str = str( <span class="number">11</span> )</span><br><span class="line">print( type( num_str ) , num_str )</span><br><span class="line"></span><br><span class="line">float_str = str( <span class="number">13.14</span> )</span><br><span class="line">print( type( float_str ) , float_str )</span><br><span class="line"></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;str&#x27;</span>&gt; <span class="number">11</span></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;str&#x27;</span>&gt; <span class="number">13.14</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将字符串类型   -&gt;  数字类型</span><br><span class="line">num = <span class="type">int</span>( <span class="string">&quot;11&quot;</span> )</span><br><span class="line">print( type( num ) , num )</span><br><span class="line"></span><br><span class="line">num2 = <span class="type">float</span>( <span class="string">&quot;13.14&quot;</span> )</span><br><span class="line">print( type( <span class="type">float</span> ) , num2 )</span><br><span class="line"></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;int&#x27;</span>&gt; <span class="number">11</span></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;float&#x27;</span>&gt; <span class="number">13.14</span></span><br></pre></td></tr></table></figure><p>！想要将字符串转换成数字，必须要求字符串内的内容都是数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num3 = <span class="type">int</span> ( <span class="string">&quot;黑马程序员&quot;</span> )</span><br><span class="line">print( type( num3 ) , num3 )</span><br><span class="line"></span><br><span class="line">&gt;&gt; ValueError: invalid literal <span class="keyword">for</span> <span class="title function_">int</span><span class="params">()</span> with base <span class="number">10</span>: <span class="string">&#x27;黑马程序员&#x27;</span></span><br></pre></td></tr></table></figure><p>！浮点数转整数会丢失精度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 整数 -&gt; 浮点数</span><br><span class="line">float_num = <span class="type">float</span>( <span class="number">11</span> )</span><br><span class="line">print( type( float_num ) , float_num )</span><br><span class="line"></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;float&#x27;</span>&gt; <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line"># 浮点数 -&gt; 整数</span><br><span class="line">int_num = <span class="type">int</span>( <span class="number">13.14</span> )</span><br><span class="line">print( type( int_num ) , int_num )</span><br><span class="line"></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;int&#x27;</span>&gt; <span class="number">13</span></span><br></pre></td></tr></table></figure><h2 id="（六）标识符"><a href="#（六）标识符" class="headerlink" title="（六）标识符"></a>（六）标识符</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1. 定义：用户在编程时所用的一系列名字，用于给变量、类、方法等命名。&amp;nbsp;</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2. 命名规则：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 内容限定（英文，中文，数字，下划线_）</p><p>！数字不可开头</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; 大小写敏感</p><p>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; 不可使用关键字 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3. 命名规范：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 见名知义</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 下划线命名法</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 英文字母全小写</p><h2 id="（七）-远算符"><a href="#（七）-远算符" class="headerlink" title="（七） 远算符"></a>（七） 远算符</h2><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1. 算术运算符：+、-、*、&#x2F;、&#x2F;&#x2F;、%、**（指数）</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2. 赋值运算符：&#x3D;</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3. 复合赋值运算符：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、&#x2F;&#x2F;&#x3D;、%&#x3D;、**&#x3D;</p><h2 id="（八）-字符串扩展"><a href="#（八）-字符串扩展" class="headerlink" title="（八） 字符串扩展"></a>（八） 字符串扩展</h2><h3 id="1-3种定义方式"><a href="#1-3种定义方式" class="headerlink" title="1. 3种定义方式"></a>1. 3种定义方式</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 1）定义形式：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ① 单引号定义法：</p><p>name &#x3D; ‘黑马程序员’</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ②双引号定义法：</p><p>name &#x3D; “黑马程序员”</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ③三引号定义法：</p><p>name &#x3D; “””黑马程序员”””</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; *支持换行操作，使用变量接收它，则为字符串；不使用变量接收，则为多行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 单引号定义法，使用单引号进行包围</span><br><span class="line">name = <span class="string">&#x27;黑马程序员&#x27;</span></span><br><span class="line">print( type(name) )</span><br><span class="line"></span><br><span class="line"># 双引号定义法，写法和多行注释是一样的</span><br><span class="line">name = <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line">print( type(name) )</span><br><span class="line"></span><br><span class="line"># 三引号定义法，写法和多行注释是一样的</span><br><span class="line">name = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我是</span></span><br><span class="line"><span class="string">黑马</span></span><br><span class="line"><span class="string">程序员</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">print( type(name) )</span><br><span class="line"></span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; &lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 2）字符串的引号嵌套</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ①单引号法，可以内含双引号；</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ②双引号定义法，可以内含单引号；</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ②可以使用转义字符（\）来将引号解除效用，变成普通字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 字符串内，包含双引号</span><br><span class="line">name = <span class="string">&#x27;&quot;黑马程序员&quot;&#x27;</span></span><br><span class="line">print( name )</span><br><span class="line"></span><br><span class="line"># 字符串内，包含单引号</span><br><span class="line">name = <span class="string">&quot;&#x27;黑马程序员&#x27;&quot;</span></span><br><span class="line">print( name )</span><br><span class="line"></span><br><span class="line"># 使用转义字符（\）解除引号的效用</span><br><span class="line">name = <span class="string">&quot;\&quot;黑马程序员\&quot;&quot;</span></span><br><span class="line">print( name )</span><br><span class="line">name = <span class="string">&#x27;\&#x27;黑马程序员\&#x27;&#x27;</span></span><br><span class="line">print( name )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line">&gt;&gt; <span class="string">&#x27;黑马程序员&#x27;</span></span><br><span class="line">&gt;&gt; <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line">&gt;&gt; <span class="string">&#x27;黑马程序员&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2. 字符串拼接"></a>2. 字符串拼接</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1）通过+号进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;黑马程序员&quot;</span></span><br><span class="line">print( <span class="string">&quot;我的名字是：&quot;</span> + name + <span class="string">&quot;我可以教大家IT技能&quot;</span> )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 我的名字是：黑马程序员我可以教大家IT技能</span><br></pre></td></tr></table></figure><p>！无法和非字符串类型进行拼接</p><h3 id="3-字符串格式化"><a href="#3-字符串格式化" class="headerlink" title="3. 字符串格式化"></a>3. 字符串格式化</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 1）“%占位符”%变量</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 2）常用占位符</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 字符串：%s</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 整数：&amp;nbsp;&amp;nbsp; %d</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 浮点数：%f</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 3）数字精度控制</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 辅助符号“m.n”来控制数据的宽度和精度</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; m ：控制宽度，要求是数字（很少使用），设置的宽度小于数字本身，不生效</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; .n：控制小数点精度，要求是数字，会进行小数的四舍五入</p><blockquote><p>%5d：表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成：[空格][空格][空格]11，用三个空格补足宽度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">11</span></span><br><span class="line">num2 = <span class="number">11.345</span></span><br><span class="line">print( <span class="string">&quot;数字11宽度限制5，结果：%5d&quot;</span> % num1 )</span><br><span class="line">print( <span class="string">&quot;数字11宽度限制1，结果：%1d&quot;</span> % num1 )</span><br><span class="line">print( <span class="string">&quot;数字11.345宽度限制7，小数精度2，结果：%7.2f&quot;</span> % num2 )</span><br><span class="line">print( <span class="string">&quot;数字11.345不限制宽度，小数精度2，结果：%.2f&quot;</span> % num2 )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 数字<span class="number">11</span>宽度限制<span class="number">5</span>，结果：   <span class="number">11</span>                             # 宽度<span class="number">5</span>，补了<span class="number">3</span>个空格</span><br><span class="line">&gt;&gt; 数字<span class="number">11</span>宽度限制<span class="number">1</span>，结果：<span class="number">11</span>                                # 宽度小于数字本身，无影响</span><br><span class="line">&gt;&gt; 数字<span class="number">11.345</span>宽度限制<span class="number">7</span>，小数精度<span class="number">2</span>，结果：  <span class="number">11.35</span> </span><br><span class="line">   # 宽度<span class="number">7</span>，补了<span class="number">2</span>个空格，小数精度<span class="number">2</span>，四舍五入后为<span class="number">.35</span></span><br><span class="line">&gt;&gt; 数字<span class="number">11.345</span>不限制宽度，小数精度<span class="number">2</span>，结果：<span class="number">11.35</span>              </span><br><span class="line">   # 不限制宽度，小数点后四舍五入后为<span class="number">.35</span></span><br></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4）快速写法</p><p>语法：</p><p>f”内容{变量}”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;传智播客&quot;</span></span><br><span class="line">set_up_year = <span class="number">2006</span></span><br><span class="line">stock_price = <span class="number">19.99</span></span><br><span class="line">print( f<span class="string">&quot;我是&#123;name&#125;，我成立于&#123;set_up_year&#125;。我今天的股票价格是：&#123;stock_price&#125;&quot;</span> )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 我是传智播客，我成立于<span class="number">2006</span>。我今天的股票价格是：<span class="number">19.99</span></span><br><span class="line"># 不做精度控制，原样输出</span><br></pre></td></tr></table></figure><p>！以上字符串格式化均可用于表达式格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print( <span class="string">&quot;1 * 1的结果是：%d&quot;</span> % ( <span class="number">1</span> * <span class="number">1</span> ) )</span><br><span class="line">print( f<span class="string">&quot;1 * 1的结果是：&#123;1 * 1&#125;&quot;</span>)</span><br><span class="line">print( <span class="string">&quot;字符串在Python中的类型是：%s&quot;</span> % type(<span class="string">&#x27;字符串&#x27;</span>) )</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">1</span> * <span class="number">1</span>的结果是：<span class="number">1</span></span><br><span class="line">&gt;&gt; <span class="number">1</span> * <span class="number">1</span>的结果是：<span class="number">1</span></span><br><span class="line">&gt;&gt; 字符串在Python中的类型是：&lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/81292ae9fabb4a0db9d522cd12e9506d.png" alt="img"></p><h2 id="（九）数据输入"><a href="#（九）数据输入" class="headerlink" title="（九）数据输入"></a>（九）数据输入</h2><ol><li>语法</li></ol><p>input();</p><ol start="2"><li>使用：</li></ol><p>使用input()语句可以从键盘获取输入</p><p>使用一个变量接收（存储）input语句获取的键盘输入数据即可</p><p>数据输出：print</p><p>数据输入：input</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print( <span class="string">&quot;请告诉我你是谁？&quot;</span> )</span><br><span class="line">name = input()</span><br><span class="line">print( <span class="string">&quot;GET！！你是：%s&quot;</span>  % name )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; 请告诉我你是谁？</span><br><span class="line">&gt;&gt; XUANseyo</span><br><span class="line">&gt;&gt; GET！！你是：XUANseyo</span><br></pre></td></tr></table></figure><p>! input()语句可以在要求使用者输入内容之前，输出提示内容的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = input( <span class="string">&quot;你是谁？&quot;</span> )</span><br><span class="line">print( <span class="string">&quot;GET！！你是：%s&quot;</span> % name )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; 你是谁？XUANseyo</span><br><span class="line">&gt;&gt; GET！！你是：XUANseyo</span><br></pre></td></tr></table></figure><p>！无论input()输入什么，其都会自动转为字符串类型，我们要自行进行数据类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = input( <span class="string">&quot;你的银行卡密码是：&quot;</span> )</span><br><span class="line">print( <span class="string">&quot;你的银行卡密码的类型是：&quot;</span> , type( num ) )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 你的银行卡密码是：<span class="number">123456</span></span><br><span class="line">&gt;&gt; 你的银行卡密码的类型是： &lt;class <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>$练习：&amp;nbsp;</p><p><img src="https://img-blog.csdnimg.cn/3fbf7acdaa8a48fbb4a4464767b05a70.png" alt="img"></p><h2 id="（一）-布尔类型和比较运算符"><a href="#（一）-布尔类型和比较运算符" class="headerlink" title="（一） 布尔类型和比较运算符"></a>（一） 布尔类型和比较运算符</h2><ol><li>布尔类型：判断结果</li></ol><p>&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; True：表示真（是、肯定）</p><p>&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp; False：表示假（否、否定）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 定义变量存储布尔类型的数据</span><br><span class="line">bool_1 = <span class="type">True</span></span><br><span class="line"><span class="variable">bool_2</span> <span class="operator">=</span> False</span><br><span class="line"><span class="title function_">print</span><span class="params">( f<span class="string">&quot;bool_1变量的内容是：&#123; bool_1 &#125;，类型为：&#123; type( bool_1 ) &#125;&quot;</span> )</span></span><br><span class="line">print( f<span class="string">&quot;bool_2变量的内容是：&#123; bool_2 &#125;，类型为：&#123; type( bool_2 ) &#125;&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; bool_1变量的内容是：True，类型为：&lt;class <span class="string">&#x27;bool&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; bool_2变量的内容是：False，类型为：&lt;class <span class="string">&#x27;bool&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>比较运算和比较运算符：</li></ol><p>&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;</p><h2 id="（二）-if语句的基本格式"><a href="#（二）-if语句的基本格式" class="headerlink" title="（二） if语句的基本格式"></a>（二） if语句的基本格式</h2><ol><li>if语句基本格式：</li></ol><p>if 要判断的条件：</p><p>&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 条件成立时，要做的事情</p><p>！首行缩进确定代码块归属</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print( <span class="string">&quot;我已经成年了。&quot;</span> )</span><br><span class="line">    print( f<span class="string">&quot;已经&#123; age &#125;岁了啊！&quot;</span> )</span><br><span class="line">print( <span class="string">&quot;时间过得真快啊！&quot;</span> )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 我已经成年了。</span><br><span class="line">&gt;&gt; 已经<span class="number">30</span>岁了啊！</span><br><span class="line">&gt;&gt; 时间过得真快啊！</span><br></pre></td></tr></table></figure><h1 id="判断语句的结果必须为布尔类型的True或False"><a href="#判断语句的结果必须为布尔类型的True或False" class="headerlink" title="判断语句的结果必须为布尔类型的True或False"></a>判断语句的结果必须为布尔类型的True或False</h1><p>True会执行if内的代码语句</p><p>False则不会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print( <span class="string">&quot;我已经成年了。&quot;</span> )</span><br><span class="line">    print( f<span class="string">&quot;已经&#123; age &#125;岁了啊！&quot;</span> )</span><br><span class="line">print( <span class="string">&quot;时间过得真快啊！&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; 时间过得真快啊！</span><br></pre></td></tr></table></figure><p>&amp;nbsp;$练习：&amp;nbsp;</p><p><img src="https://img-blog.csdnimg.cn/62d886c01d9344cb9a846446140f8f5e.png" alt="img"></p><h2 id="（三）-if-else-语句"><a href="#（三）-if-else-语句" class="headerlink" title="（三） if else 语句"></a>（三） if else 语句</h2><ol><li>基本格式：</li></ol><p>if 条件 ：</p><p>满足条件时要完成的事1</p><p>满足条件时要完成的事2</p><p>……</p><p>else：</p><p>不满足条件时要完成的事1</p><p>不满足条件时要完成的事2</p><p>……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print( <span class="string">&quot;欢迎来到黑马儿童游乐场，儿童免费，成人收费！&quot;</span> )</span><br><span class="line">age =  input( <span class="string">&quot;请输入您的年龄：&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="title function_">int</span><span class="params">(age)</span> &gt;= <span class="number">18</span> :</span><br><span class="line">    print( <span class="string">&quot;您已成年，游玩需补票10元&quot;</span> )</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print( <span class="string">&quot;您未成年，无需补票&quot;</span> )</span><br><span class="line"></span><br><span class="line">print( <span class="string">&quot;祝您游玩愉快！！！&quot;</span> )</span><br><span class="line"></span><br><span class="line">&gt;&gt; 欢迎来到黑马儿童游乐场，儿童免费，成人收费！</span><br><span class="line">&gt;&gt; 请输入您的年龄：<span class="number">17</span></span><br><span class="line">&gt;&gt; 您未成年，无需补票</span><br><span class="line">&gt;&gt; 祝您游玩愉快！！！</span><br></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;$练习：&amp;nbsp;<img src="https://img-blog.csdnimg.cn/ea67107c6fcd45f8b687b20b1aaa172c.png" alt="img"></p><h2 id="（四）-if-elif-else-语句"><a href="#（四）-if-elif-else-语句" class="headerlink" title="（四） if elif else 语句"></a>（四） if elif else 语句</h2><ol><li>基本格式：</li></ol><p>if 条件1 :</p><p>条件1满足时要完成的事</p><p>条件1满足时要完成的事</p><p>……</p><p>elif 条件2::</p><p>条件2满足时要完成的事</p><p>条件2满足时要完成的事</p><p>……</p><p>elif 条件n:</p><p>条件n满足时要完成的事</p><p>条件n满足时要完成的事</p><p>……</p><p>else:</p><p>所有条件不满足时要完成的事</p><p>所有条件不满足时要完成的事</p><p>……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;欢迎来到黑马动物园！！&quot;</span>)</span><br><span class="line"></span><br><span class="line">height = <span class="type">int</span>(input(<span class="string">&quot;请输入你的身高：&quot;</span>))</span><br><span class="line">vip_level = <span class="type">int</span>(input(<span class="string">&quot;请输入您的vip级别（1~5）：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> height &lt; <span class="number">120</span> :</span><br><span class="line">    print(<span class="string">&quot;您的身高小于120cm，可以免费游玩&quot;</span>)</span><br><span class="line"></span><br><span class="line">elif vip_level &gt; <span class="number">3</span> :</span><br><span class="line">    print(<span class="string">&quot;您的vip级别大于3，可以免费游玩&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&quot;不好意思，所有条件均不符合，需要购票10元&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;祝您游玩愉快&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; 欢迎来到黑马动物园！！</span><br><span class="line">&gt;&gt; 请输入你的身高：<span class="number">150</span></span><br><span class="line">&gt;&gt; 请输入您的vip级别（<span class="number">1</span>~<span class="number">5</span>）：<span class="number">5</span></span><br><span class="line">&gt;&gt; 您的vip级别大于<span class="number">3</span>，可以免费游玩</span><br><span class="line">&gt;&gt; 祝您游玩愉快</span><br></pre></td></tr></table></figure><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/99ae1621687545c2b63a5792d317706e.png" alt="img"></p><h2 id="（五）-判断语句的嵌套"><a href="#（五）-判断语句的嵌套" class="headerlink" title="（五） 判断语句的嵌套"></a>（五） 判断语句的嵌套</h2><ol><li>基本格式</li></ol><p>if 条件1 ：</p><p>满足条件1时要完成的事1</p><p>满足条件1时要完成的事2</p><p>……</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if条件2：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 满足条件2做的事情1</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 满足条件2做的事情2</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;……</p><ol start="2"><li>嵌套的关键点：空格缩进</li></ol><p>&amp;nbsp;&amp;nbsp; 通过空格缩进，来决定语句之间的：层次关系</p><h2 id="（六）-实战案例"><a href="#（六）-实战案例" class="headerlink" title="（六） 实战案例"></a>（六） 实战案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">random</span></span><br><span class="line"><span class="variable">num</span> <span class="operator">=</span> random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">m = <span class="type">int</span>(input(<span class="string">&quot;第一次才得数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num == m :</span><br><span class="line">    print (<span class="string">&quot;猜对啦！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="keyword">if</span> num &gt; m:</span><br><span class="line">        print(<span class="string">&quot;猜小了！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        print(<span class="string">&quot;猜大了！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    m2 = <span class="type">int</span>(input(<span class="string">&quot;第二次猜测的数字：&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> m2 == num:</span><br><span class="line">        print(<span class="string">&quot;第二次猜对了！&quot;</span>)</span><br><span class="line">    elif num &gt; m2:</span><br><span class="line">        print(<span class="string">&quot;第二次猜小了！&quot;</span>)</span><br><span class="line">    elif num &lt; m2:</span><br><span class="line">        print(<span class="string">&quot;第二次猜大了&quot;</span>)</span><br><span class="line">    guess_num = <span class="type">int</span>(input(<span class="string">&quot;第三次输入你要猜测的数字：&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess_num == num:</span><br><span class="line">        print(<span class="string">&quot;第三次猜中了&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;三次机会用完了，没有猜中。&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="（一）-while循环的基本语法"><a href="#（一）-while循环的基本语法" class="headerlink" title="（一） while循环的基本语法"></a>（一） while循环的基本语法</h2><p>1.&amp;nbsp; 基本格式</p><p>while 条件：</p><p>条件满足时，做的事情1</p><p>条件满足时，做的事情2</p><p>…（省略）…</p><ul><li>只要条件满足，会无限循环执行 </li><li>条件需要布尔类型结果</li></ul><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/abca4452420d4be4945468c868e20228.png" alt="img"></p><h2 id="（二）-while循环的基础案例"><a href="#（二）-while循环的基础案例" class="headerlink" title="（二） while循环的基础案例"></a>（二） while循环的基础案例</h2><p>&amp;nbsp;<img src="https://img-blog.csdnimg.cn/109a728803fc4a1d9609bed9eadeb99d.png" alt="img"></p><h2 id="（三）-while循环的嵌套应用"><a href="#（三）-while循环的嵌套应用" class="headerlink" title="（三） while循环的嵌套应用"></a>（三） while循环的嵌套应用</h2><p>&amp;nbsp;1. 基本格式：</p><p>while 条件1：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;条件1满足时，做的事情1</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;条件1满足时，做的事情2</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;…（省略）…</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while 条件2：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;条件2满足时，做的事情1</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;条件2满足时，做的事情2</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;…（省略）…</p><h2 id="（四）-while循环的嵌套应用"><a href="#（四）-while循环的嵌套应用" class="headerlink" title="（四） while循环的嵌套应用"></a>（四） while循环的嵌套应用</h2><p>补充：</p><ol><li>print输出不换行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Hello&quot;</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;World!&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; Hello World!</span><br></pre></td></tr></table></figure><ol start="2"><li>制表符&#x2F;t</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;学号\t姓名\t语文\t数学\t英语&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;2022001\t小王\t99\t\t88\t\t0&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;2022002\t小周\t92\t\t45\t\t93&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;2022008\t小黄\t77\t\t82\t\t100&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/788bb66ebe264cd19c8417b05dd0cdd0.png" alt="img"></p><h2 id="（五）-for循环的基础语法"><a href="#（五）-for循环的基础语法" class="headerlink" title="（五） for循环的基础语法"></a>（五） for循环的基础语法</h2><ol><li>基础语法</li></ol><p>for循环就是将“待办事项”逐个完成的循环机制</p><ul><li>while循环的循环条件是自定义，自行控制循环条件 </li><li>for循环是一种“轮询”机制，是对一批内容进行逐个处理</li></ul><p>！for循环无法定义循环条件，只能从被处理的数据集中，依次取出内容进行处理</p><p>1） 基本格式：</p><p>for 临时变量 in 待处理的数据集：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 循环满足条件时执行的语句</p><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/f544c630f57f42faae61d801c2fc5b52.png" alt="img"></p><ol start="2"><li>range语句</li></ol><p>1） 功能：获得一个数字序列（可迭代类型的一种）</p><p>2） 语法格式：</p><blockquote><p>range（num）</p></blockquote><p>获取一个从0开始，到num结束的数字序列</p><blockquote><p>range（num1，num2）</p></blockquote><p>获取一个从num1开始，到num2结束的数字序列（不含num2本身）</p><blockquote><p>range（num1，num2，step）</p></blockquote><p>&amp;nbsp;获得一个从num1开始，到num2结束的数字序列（不含num2本身）</p><p>数字之间的步长，以step为准（step默认为1）</p><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/c9eae398caca4b388d980bba69a5403a.png" alt="img"></p><ol start="3"><li>变量作用域</li></ol><h2 id="（六）for循环的嵌套应用"><a href="#（六）for循环的嵌套应用" class="headerlink" title="（六）for循环的嵌套应用"></a>（六）for循环的嵌套应用</h2><ol><li>基本格式：</li></ol><p>for 临时变量 in 待处理的数据集：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 循环满足条件时执行的语句1</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 循环满足条件时执行的语句2</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ……</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; for 临时变量 in 待处理的数据集：</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 循环满足条件时执行的语句1</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 循环满足条件时执行的语句1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</p><p>$练习：</p><p><img src="https://img-blog.csdnimg.cn/addae357bbd9419ca8f2f75405c7cdd0.png" alt="img"></p><h2 id="（七）-循环中断：break和continue"><a href="#（七）-循环中断：break和continue" class="headerlink" title="（七） 循环中断：break和continue"></a>（七） 循环中断：break和continue</h2><ol><li><p>continue关键字作用：中断本次循环，直接进入下一次循环【for循环和while循环即可使用】</p></li><li><p>break关键字作用：所在循环永久中断【for循环和while循环即可使用】</p></li></ol><h2 id="（八）-综合案例"><a href="#（八）-综合案例" class="headerlink" title="（八） 综合案例"></a>（八） 综合案例</h2><p><img src="https://img-blog.csdnimg.cn/dd7198185ed542aeaf91d44b64a0948e.png" alt="img"></p><h2 id="（一）-函数介绍"><a href="#（一）-函数介绍" class="headerlink" title="（一） 函数介绍"></a>（一） 函数介绍</h2><ol><li>函数：是组织好的，可重复使用的，用来实现特定功能的代码段。</li></ol><p>eg. len()：实现统计长度这一特定功能的代码段。</p><ol start="2"><li>函数好处：</li></ol><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; * 将功能封装在函数内，可随时随地重复利用</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; * 提高代码的复用性，减少重复代码，提高开发效率</p><h2 id="（二）-函数定义"><a href="#（二）-函数定义" class="headerlink" title="（二） 函数定义"></a>（二） 函数定义</h2><ol><li>基本语法：</li></ol><p>（1） 函数定义</p><p>def 函数名 （传入函数）：</p><p>函数体</p><p>return 返回值</p><p>（2） 函数调用</p><p>函数名（参数）</p><p>！参数可省略</p><p>！返回值可省略</p><p>！函数必须先定义后使用</p><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">printWelcome</span> <span class="params">()</span>:</span><br><span class="line">    print(<span class="string">&quot;欢迎来到黑马程序员！&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;请出示48小时核酸检测证明！&quot;</span>)</span><br><span class="line"></span><br><span class="line">printWelcome()</span><br></pre></td></tr></table></figure><h2 id="（三）-函数参数"><a href="#（三）-函数参数" class="headerlink" title="（三） 函数参数"></a>（三） 函数参数</h2><ol><li>传入参数的功能：在函数调用时，接受外部提供的数据</li></ol><p>！参数之间按顺序传入；使用，进行分隔</p><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">printWelcome</span><span class="params">(x)</span>:</span><br><span class="line">    print(<span class="string">&quot;欢迎来到黑马程序员！请出示48小时核酸检测证明！&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> x &lt;= <span class="number">37.5</span>:</span><br><span class="line">        print(f<span class="string">&quot;体温测量中，您的体温是：&#123;x&#125;，体温正常，请进！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(f<span class="string">&quot;体温测量中，您的体温是&#123;x&#125;，需要隔离！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y = <span class="type">int</span>(input(<span class="string">&quot;请输入您的体温：&quot;</span>))</span><br><span class="line">printWelcome(y)</span><br></pre></td></tr></table></figure><h2 id="（四）-函数返回值"><a href="#（四）-函数返回值" class="headerlink" title="（四） 函数返回值"></a>（四） 函数返回值</h2><ol><li>通过return关键字，可向调用者返回数据</li></ol><p>2.. None类型：</p><p>（1） None，其类型是&lt;class ’NoneType’&gt;</p><p>（2） 无返回值的函数，实际上是返回了None这个字面量</p><p>（3） 使用：</p><ul><li>用于函数返回值中【空】 </li><li>用于if判断【None等同于False】 </li><li>用于声明无内容的变量上</li></ul><h2 id="（五）-函数说明文档"><a href="#（五）-函数说明文档" class="headerlink" title="（五） 函数说明文档"></a>（五） 函数说明文档</h2><ol><li>函数说明文档：对函数进行说明解释，帮助更好地理解函数</li></ol><p>2.. 定义语法：</p><p>def func（x，y）</p><p>“””</p><p>函数说明</p><p>：param x：参数x的说明</p><p>：param x：参数x的说明</p><p>：return：返回值的说明</p><p>“””</p><p>函数体</p><p>return 返回值</p><h2 id="（六）-函数嵌套使用"><a href="#（六）-函数嵌套使用" class="headerlink" title="（六） 函数嵌套使用"></a>（六） 函数嵌套使用</h2><ol><li><p>函数嵌套：在一个函数中，调用另一个函数。</p></li><li><p>执行流程：</p></li></ol><p>函数a中执行到调用函数b的语句，会将b全部执行；完成后，继续执行函数a的剩余内容</p><h2 id="（七）-变量的作用域"><a href="#（七）-变量的作用域" class="headerlink" title="（七） 变量的作用域"></a>（七） 变量的作用域</h2><ol><li>变量作用域：变量的作用范围</li></ol><p>2.. 局部变量：定义在函数体内部的变量，只在函数体内部生效</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp; 局部变量作用：在函数体内部，临时保存数据，即当函数调用完成后，销毁局部变量</p><ol start="3"><li><p>全局变量：在函数体内外都能生效的变量</p></li><li><p>global关键字：可使函数内部声明变量为全局变量</p></li></ol><h2 id="（八）-综合案例-1"><a href="#（八）-综合案例-1" class="headerlink" title="（八） 综合案例"></a>（八） 综合案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">money = <span class="number">5000000</span></span><br><span class="line">name = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">menu</span><span class="params">()</span>:</span><br><span class="line">    name = input(<span class="string">&quot;您好！请输入客户姓名：&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;您好，请问您需要什么服务呢？&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;输入1：查询余额&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;输入2：存款&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;输入3：取款&quot;</span>)</span><br><span class="line">    n = <span class="type">int</span>(input(<span class="string">&quot;请输入功能号：&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        check(money)</span><br><span class="line">    elif n == <span class="number">2</span>:</span><br><span class="line">        x = <span class="type">int</span>(input(<span class="string">&quot;请输入您想存入的金额：&quot;</span>))</span><br><span class="line">        deposit(x, money)</span><br><span class="line">    elif n == <span class="number">3</span>:</span><br><span class="line">        y = <span class="type">int</span>(input(<span class="string">&quot;请输入您想取出的金额：&quot;</span>))</span><br><span class="line">        withdraw(y, money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">check</span><span class="params">(money)</span>:</span><br><span class="line">    print(f<span class="string">&quot;您好！您的余额为：&#123;money&#125;&quot;</span>)</span><br><span class="line">    menu()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">deposit</span><span class="params">(x, money)</span>:</span><br><span class="line">    money1 = x + money</span><br><span class="line">    <span class="title function_">print</span><span class="params">(f<span class="string">&quot;您好，存款成功后，您的余额为：&#123;money1&#125;&quot;</span>)</span></span><br><span class="line">    menu()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_">withdraw</span><span class="params">(x, money)</span>:</span><br><span class="line">    money2 = money - x</span><br><span class="line">    <span class="title function_">print</span><span class="params">(f<span class="string">&quot;您好，取款成功后，您的余额为：&#123;money2&#125;&quot;</span>)</span></span><br><span class="line">    menu()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">menu()</span><br></pre></td></tr></table></figure><h2 id="（一）-数据容器入门"><a href="#（一）-数据容器入门" class="headerlink" title="（一） 数据容器入门"></a>（一） 数据容器入门</h2><ol><li>数据容器：一种可以容纳多份数据的数据类型，容纳的每一份数据称之为一个元素。每一个元素，可以是任意类型的数据，如字符串、数字、布尔等。</li></ol><p>2.. 种类：list（列表）、tuple（元组）、str（字符串）、set（集合）、dict（字典）</p><h2 id="（二）-数据容器：list（列表）"><a href="#（二）-数据容器：list（列表）" class="headerlink" title="（二） 数据容器：list（列表）"></a>（二） 数据容器：list（列表）</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>（1） 基本语法：</p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>[元素1 ，元素2 ，元素3，……]</p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p>变量名称 &#x3D; [元素1 ，元素2 ，元素3，……]</p><h1 id="定义空列表"><a href="#定义空列表" class="headerlink" title="定义空列表"></a>定义空列表</h1><p>变量名称 &#x3D; []</p><p>变量名称 &#x3D; list（）</p><p>（2） 元素：列表中的每个数据</p><p>！ 列表可以一次存储多个数据，且可以为不同类型，支持嵌套</p><h3 id="2-列表的下标索引"><a href="#2-列表的下标索引" class="headerlink" title="2. 列表的下标索引"></a>2. 列表的下标索引</h3><p>（1） 类型：正向：从前向后，从0开始，依次递增</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 反向：从后向前，从-1开始，依次递减</p><p>（2） 使用：</p><p>列表[下标]</p><p>！ 下标超出范围，则无法取出元素，并且会报错</p><h3 id="3-列表的常用操作（方法）"><a href="#3-列表的常用操作（方法）" class="headerlink" title="3. 列表的常用操作（方法）"></a>3. 列表的常用操作（方法）</h3><ul><li>函数：封装的代码单元，可提供特定功能。</li></ul><p>如将函数定义为class（类）的成员，则称函数为方法。</p><h3 id="4-列表的特点"><a href="#4-列表的特点" class="headerlink" title="4. 列表的特点"></a>4. 列表的特点</h3><ul><li>可容纳多个元素 </li><li>可容纳不同类型的元素 </li><li>数据是有序存储的 </li><li>允许重复数据存在 </li><li>可进行增删查改</li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">age = [<span class="number">21</span>, <span class="number">25</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">age.append(<span class="number">31</span>)</span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line">age.extend([<span class="number">29</span>, <span class="number">33</span>, <span class="number">30</span>])</span><br><span class="line">print(age)</span><br><span class="line"></span><br><span class="line">x = age[<span class="number">0</span>]</span><br><span class="line">y = age[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print(x, y)</span><br><span class="line"></span><br><span class="line">a = age.index(<span class="number">31</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h2 id="（三）-list（列表）的遍历"><a href="#（三）-list（列表）的遍历" class="headerlink" title="（三） list（列表）的遍历"></a>（三） list（列表）的遍历</h2><ul><li>遍历：将容器内的元素依次取出，并处理</li></ul><h3 id="1-使用while遍历"><a href="#1-使用while遍历" class="headerlink" title="1. 使用while遍历"></a>1. 使用while遍历</h3><ul><li>可以指定循环条件，自行控制 </li><li>可以通过条件控制做到无限循环 </li><li>适用于任何想要循环的场景</li></ul><h3 id="2-使用for遍历"><a href="#2-使用for遍历" class="headerlink" title="2. 使用for遍历"></a>2. 使用for遍历</h3><ul><li>不可以指定循环条件，只可以一个个从容器内取出数据 </li><li>理论上不可以无限循环，因为被遍历的容器容量不是无限的 </li><li>适用于遍历数据容器的场景或简单的固定次数循环场景</li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">l1 = list()</span><br><span class="line">l2 = list()</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 取出偶数</span><br><span class="line"><span class="keyword">while</span> i &lt; len(L):</span><br><span class="line">    <span class="keyword">if</span> L[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        l1 . append(L[i])</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">print(f<span class="string">&quot;通过while循环，从列表：&#123;L&#125;，中取出偶数，组成新列表&#123;l1&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j in L:</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        l2 . append(j)</span><br><span class="line">print(f<span class="string">&quot;通过for循环，从列表：&#123;L&#125;，中取出偶数，组成新列表&#123;l2&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="（四）-数据容器：tuple（元组）"><a href="#（四）-数据容器：tuple（元组）" class="headerlink" title="（四） 数据容器：tuple（元组）"></a>（四） 数据容器：tuple（元组）</h2><ul><li>元组一旦定义，不可进行修改</li></ul><h3 id="1-元组的定义"><a href="#1-元组的定义" class="headerlink" title="1. 元组的定义"></a>1. 元组的定义</h3><p>（1） 基本语法：</p><h1 id="字面量-1"><a href="#字面量-1" class="headerlink" title="字面量"></a>字面量</h1><p>（元素1 ，元素2 ，元素3，……）</p><h1 id="定义变量-1"><a href="#定义变量-1" class="headerlink" title="定义变量"></a>定义变量</h1><p>变量名称 &#x3D;（元素1 ，元素2 ，元素3，……）</p><h1 id="定义空列表-1"><a href="#定义空列表-1" class="headerlink" title="定义空列表"></a>定义空列表</h1><p>变量名称 &#x3D; （）</p><p>变量名称 &#x3D;tuple（）</p><p>！ 元组即使只含有一个数据，这个数据后也要添加，也可进行嵌套</p><h3 id="2-元组的操作（方法）"><a href="#2-元组的操作（方法）" class="headerlink" title="2. 元组的操作（方法）"></a>2. 元组的操作（方法）</h3><p>！ 不可修改元组内容，否则直接报错</p><p>！ 可修改元组内list的内容</p><p>！ 不可以替换元组内list为其他list或其他类型</p><h3 id="3-元组的特点"><a href="#3-元组的特点" class="headerlink" title="3. 元组的特点"></a>3. 元组的特点</h3><ul><li>可容纳多个元素 </li><li>可容纳不同类型的元素 </li><li>数据是有序存储的 </li><li>允许重复数据存在 </li><li>可进行增删查改 </li><li>可进行循环 </li><li>不可修改</li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T = (<span class="string">&#x27;周杰伦&#x27;</span>, <span class="number">11</span>, [<span class="string">&#x27;football&#x27;</span>, <span class="string">&#x27;music&#x27;</span>])</span><br><span class="line"></span><br><span class="line">a = T.index(<span class="number">11</span>)</span><br><span class="line">n = T[<span class="number">0</span>]</span><br><span class="line">print(a,n)</span><br><span class="line"></span><br><span class="line">del T[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">T[<span class="number">2</span>].append(<span class="string">&#x27;coding&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(T)</span><br></pre></td></tr></table></figure><h2 id="（五）-数据容器：str（字符串）"><a href="#（五）-数据容器：str（字符串）" class="headerlink" title="（五） 数据容器：str（字符串）"></a>（五） 数据容器：str（字符串）</h2><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h3><p>字符的容器，一个字符串可以存放任意数量的字符。</p><h3 id="2-字符串的下标（索引）"><a href="#2-字符串的下标（索引）" class="headerlink" title="2. 字符串的下标（索引）"></a>2. 字符串的下标（索引）</h3><ul><li>从前向后，下标从0开始 </li><li>从后向前，下标从-1开始</li></ul><p>！ 字符串是一个无法修改的数据容器</p><p>！ 如果要修改，则会得到一个新的字符串，旧的字符串是无法修改的</p><h3 id="3-字符串的常用操作"><a href="#3-字符串的常用操作" class="headerlink" title="3. 字符串的常用操作"></a>3. 字符串的常用操作</h3><h3 id="4-字符串的特点"><a href="#4-字符串的特点" class="headerlink" title="4. 字符串的特点"></a>4. 字符串的特点</h3><ul><li>只可以存储字符串 </li><li>长度任意 </li><li>支持下标索引 </li><li>允许重复的字符串出现 </li><li>不可以修改 </li><li>支持循环</li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot;itheima itcast boxuegu&quot;</span></span><br><span class="line"></span><br><span class="line">n = S.count(<span class="string">&quot;it&quot;</span>)</span><br><span class="line">print(f<span class="string">&quot;字符串&#123;S&#125;中有&#123;n&#125;个it字符&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">S1 = S.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;|&quot;</span>)</span><br><span class="line">print(f<span class="string">&quot;字符串&#123;S&#125;，被替换空格后，结果&#123;S1&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L = S1.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">print(f<span class="string">&quot;字符串&#123;S&#125;，按照“|”分割后，得到&#123;L&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="（六）-数据容器的切片"><a href="#（六）-数据容器的切片" class="headerlink" title="（六） 数据容器的切片"></a>（六） 数据容器的切片</h2><h3 id="1-序列"><a href="#1-序列" class="headerlink" title="1. 序列"></a>1. 序列</h3><p>内容连续、有序、可使用下标索引的一类数据容器。（如列表、元组、字符串等）</p><h3 id="2-切片"><a href="#2-切片" class="headerlink" title="2. 切片"></a>2. 切片</h3><p>（序列的常用操作）从一个序列中，取出一个子序列</p><h3 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3. 基本语法"></a>3. 基本语法</h3><p>序列[起始下标：结束下标：步长]</p><ul><li><p>表示从序列中，从指定位置开始，依次取出指定元素，到指定位置结束，得到一个新序列</p></li><li><p>起始下标表示从何处开始，可以留空，留空视作从头开始</p></li><li><p>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾</p></li><li><p>步长表示，依次取元素的间隔</p></li></ul><ul><li><p>步长1表示，一个个取元素 </p></li><li><p>步长2表示，每次跳过1个元素取 </p></li><li><p>步长N表示，每次跳过N-1个元素取 </p></li><li><p>步长为负数表示，反向取（注意，起始下标和结束下标也要反向标记）</p></li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&quot;万过薪月，员序程马黑来，nohtyP学&quot;</span></span><br><span class="line"></span><br><span class="line"># 使用“切片”</span><br><span class="line">new_S = S[<span class="number">9</span>:<span class="number">4</span>:-<span class="number">1</span>]</span><br><span class="line">print(new_S)</span><br><span class="line"></span><br><span class="line"># 使用字符串常用操作</span><br><span class="line">i = -<span class="number">9</span></span><br><span class="line">S1 = S.replace(<span class="string">&quot;来&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">S2 = S1.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">print(S2)</span><br><span class="line">new_S1 = S2[<span class="number">0</span>][<span class="number">9</span>:<span class="number">4</span>:-<span class="number">1</span>]</span><br><span class="line">print(new_S1)</span><br></pre></td></tr></table></figure><h2 id="（七）-数据容器：set（集合）"><a href="#（七）-数据容器：set（集合）" class="headerlink" title="（七） 数据容器：set（集合）"></a>（七） 数据容器：set（集合）</h2><h3 id="1-集合的基本语法"><a href="#1-集合的基本语法" class="headerlink" title="1. 集合的基本语法"></a>1. 集合的基本语法</h3><h1 id="定义集合字面量"><a href="#定义集合字面量" class="headerlink" title="定义集合字面量"></a>定义集合字面量</h1><p>（元素，元素，……，元素）</p><h1 id="定义集合变量"><a href="#定义集合变量" class="headerlink" title="定义集合变量"></a>定义集合变量</h1><p>变量名称 &#x3D; {元素，元素，……，元素}</p><h1 id="定义空集合"><a href="#定义空集合" class="headerlink" title="定义空集合"></a>定义空集合</h1><p>变量名称 &#x3D; set（）</p><p><strong>！ 去重且无序，无法保证顺序与创建的时候一致</strong></p><p><strong>！ 不支持：下标索引访问，因此不支持while循环</strong></p><p>补充：</p><p>定义：</p><p>列表[]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 可修改、支持重复元素且有序</p><p>元组（）&amp;nbsp;&amp;nbsp;&amp;nbsp; 不可修改、支持重复元素且有序</p><p>字符串“”&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 不可修改、支持重复元素且有序</p><p>集合{}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 可修改、不支持重复元素、无序</p><h3 id="2-集合的常用功能"><a href="#2-集合的常用功能" class="headerlink" title="2. 集合的常用功能"></a>2. 集合的常用功能</h3><h3 id="3-集合的特点"><a href="#3-集合的特点" class="headerlink" title="3. 集合的特点"></a>3. 集合的特点</h3><ul><li>可以容纳多个数据 </li><li>可以容纳不同类型的数据（混装） </li><li>数据是无序存储的（不支持下标存储） </li><li>不允许重复数据存在 </li><li>可以修改 </li><li>支持for循环，不支持while循环</li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;best&#x27;</span>]</span><br><span class="line"></span><br><span class="line">S = set()</span><br><span class="line"><span class="keyword">for</span> i in my_list:</span><br><span class="line">    S.add(i)</span><br><span class="line"></span><br><span class="line">print(f<span class="string">&quot;有列表：&#123;my_list&#125;&quot;</span>)</span><br><span class="line">print(f<span class="string">&quot;存入集合后结果：&#123;S&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="（八）-数据容器：dict（字典、映射）"><a href="#（八）-数据容器：dict（字典、映射）" class="headerlink" title="（八） 数据容器：dict（字典、映射）"></a>（八） 数据容器：dict（字典、映射）</h2><h3 id="1-字典的基本语法"><a href="#1-字典的基本语法" class="headerlink" title="1. 字典的基本语法"></a>1. 字典的基本语法</h3><h1 id="定义字典字面量"><a href="#定义字典字面量" class="headerlink" title="定义字典字面量"></a>定义字典字面量</h1><p>{key：value，key：value，……，key：value}</p><h1 id="定义字面变量"><a href="#定义字面变量" class="headerlink" title="定义字面变量"></a>定义字面变量</h1><p>my_dict &#x3D; {key：value，key：value，……，key：value}</p><h1 id="定义空字典"><a href="#定义空字典" class="headerlink" title="定义空字典"></a>定义空字典</h1><p>my_dict &#x3D; {}</p><p>my_dict &#x3D; dict{}</p><p>！ 每个元素均为键值对，key和value可以为任意类型数据（key不可为字典）</p><p>！ key不可重复，重复会对原有数据覆盖</p><p>！ 不可以使用下标索引，但可通过key值取得对应的value，不可使用while循环</p><p>！ 字典可嵌套</p><h3 id="2-字典的常用操作"><a href="#2-字典的常用操作" class="headerlink" title="2. 字典的常用操作"></a>2. 字典的常用操作</h3><h3 id="3-字典的特点"><a href="#3-字典的特点" class="headerlink" title="3. 字典的特点"></a>3. 字典的特点</h3><ul><li>可以容纳多个数据 </li><li>可以容纳不同类型的数据（混装） </li><li>不支持下标索引 </li><li>可以修改 </li><li>支持for循环，不支持while循环</li></ul><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D = &#123;</span><br><span class="line">    <span class="string">&quot;王力鸿&quot;</span>:&#123;<span class="string">&quot;部门&quot;</span>:<span class="string">&quot;科技部&quot;</span>,<span class="string">&quot;工资&quot;</span>:<span class="number">3000</span>,<span class="string">&quot;级别&quot;</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&quot;周婕纶&quot;</span>:&#123;<span class="string">&quot;部门&quot;</span>:<span class="string">&quot;市场部&quot;</span>,<span class="string">&quot;工资&quot;</span>:<span class="number">5000</span>,<span class="string">&quot;级别&quot;</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;凌俊杰&quot;</span>:&#123;<span class="string">&quot;部门&quot;</span>:<span class="string">&quot;市场部&quot;</span>,<span class="string">&quot;工资&quot;</span>:<span class="number">7000</span>,<span class="string">&quot;级别&quot;</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&quot;张雪有&quot;</span>:&#123;<span class="string">&quot;部门&quot;</span>:<span class="string">&quot;科技部&quot;</span>,<span class="string">&quot;工资&quot;</span>:<span class="number">4000</span>,<span class="string">&quot;级别&quot;</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&quot;牛德华&quot;</span>:&#123;<span class="string">&quot;部门&quot;</span>:<span class="string">&quot;市场部&quot;</span>,<span class="string">&quot;工资&quot;</span>:<span class="number">6000</span>,<span class="string">&quot;级别&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">keys = D.keys()</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key in keys:</span><br><span class="line">    <span class="keyword">if</span> D[key][<span class="string">&quot;级别&quot;</span>] == <span class="number">1</span>:</span><br><span class="line">        D[key][<span class="string">&quot;工资&quot;</span>] = D[key][<span class="string">&quot;工资&quot;</span>] + <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br></pre></td></tr></table></figure><h3 id="扩展：数据容器的对比总结"><a href="#扩展：数据容器的对比总结" class="headerlink" title="扩展：数据容器的对比总结"></a>扩展：数据容器的对比总结</h3><h2 id="（九）-数据容器的通用操作"><a href="#（九）-数据容器的通用操作" class="headerlink" title="（九） 数据容器的通用操作"></a>（九） 数据容器的通用操作</h2><h2 id="（十）综合案例"><a href="#（十）综合案例" class="headerlink" title="（十）综合案例"></a>（十）综合案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 幸运数字<span class="number">6</span>：</span><br><span class="line"># <span class="number">1.</span> 输入任意数字，如数字<span class="number">8</span>，生成nums列表，元素值为<span class="number">1</span>-<span class="number">8</span>，</span><br><span class="line">#  <span class="number">2.</span> 从中选取幸运数字（能被<span class="number">6</span>整除）移动到新列表lucky</span><br><span class="line"># <span class="number">3.</span> 打印nums和<span class="type">lucky</span></span><br><span class="line"></span><br><span class="line"><span class="variable">n</span> <span class="operator">=</span> <span class="type">int</span>(input(<span class="string">&quot;请输入您所想的数字：&quot;</span>))</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">nums = list()</span><br><span class="line">lucky = list()</span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt;= n:</span><br><span class="line">    nums.append(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(f<span class="string">&quot;nums列表为：&#123;nums&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j in nums:</span><br><span class="line">    <span class="keyword">if</span> j % <span class="number">6</span> == <span class="number">0</span>:</span><br><span class="line">        lucky.append(j)</span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(f<span class="string">&quot;lucky列表为：&#123;lucky&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 列表嵌套：</span><br><span class="line"># <span class="number">3</span>个教室[[],[],[]]</span><br><span class="line"># <span class="number">8</span>名讲师[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>]</span><br><span class="line"># 随机分配</span><br><span class="line"><span class="keyword">import</span> <span class="type">random</span></span><br><span class="line"></span><br><span class="line"><span class="variable">classroom</span> <span class="operator">=</span> [[],[],[]]</span><br><span class="line">teacher = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>]</span><br><span class="line"></span><br><span class="line">j = random.randint(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in teacher:</span><br><span class="line">    classroom[j].append(i)</span><br><span class="line">    j = random.randint(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(f<span class="string">&quot;分配后为：&#123;classroom&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="（一）-函数多返回值"><a href="#（一）-函数多返回值" class="headerlink" title="（一） 函数多返回值"></a>（一） 函数多返回值</h2><ul><li>按照返回值的顺序，写对顺序的多个变量接收即可 </li><li>变量之间用逗号隔开 </li><li>支持不同类型的数据return</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">test_return</span><span class="params">()</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">x,y = test_return()</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="number">1</span></span><br><span class="line">&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="（二）-函数的多种传参方式"><a href="#（二）-函数的多种传参方式" class="headerlink" title="（二） 函数的多种传参方式"></a>（二） 函数的多种传参方式</h2><p>函数参数种类：根据使用方式不同：分为以下4种</p><h3 id="1-位置参数"><a href="#1-位置参数" class="headerlink" title="1. 位置参数"></a>1. 位置参数</h3><ul><li>根据函数定义的参数位置来传递参数</li></ul><p>！ 传递的参数和定义的参数的顺序及个数必须一致</p><h3 id="2-关键字参数"><a href="#2-关键字参数" class="headerlink" title="2. 关键字参数"></a>2. 关键字参数</h3><ul><li>函数调用时通过键值对的形式传递参数</li></ul><p>！ 函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序</p><h3 id="3-缺省参数"><a href="#3-缺省参数" class="headerlink" title="3. 缺省参数"></a>3. 缺省参数</h3><ul><li>也称默认参数，用于定义函数，为函数提供默认值，调用函数时可不传该默认参数的值</li></ul><p>！ 所有位置参数必须出现在默认参数前，包括函数定义和调用</p><p>！ 函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值</p><h3 id="4-不定长参数"><a href="#4-不定长参数" class="headerlink" title="4. 不定长参数"></a>4. 不定长参数</h3><ul><li>也称可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景。</li></ul><p>！ 当调用函数时不确定参数个数时，可以使用不定长参数。</p><p>（1） 位置传递</p><ul><li>传进的所有参数都会被args变量收集，他会根据传进参数的位置合并为一个元组（tuple），args是元组类型，这就是位置传递</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">user</span><span class="params">(*args)</span>:</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line">user(<span class="string">&#x27;Belly&#x27;</span>,<span class="number">20</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;(<span class="string">&#x27;Belly&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>（2） 关键字传递</p><ul><li>参数是键值对形式，所有键值对都会被kwargs接受，同时根据键值对组成字典</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">user</span><span class="params">(**kwargs)</span>:</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">user(name = <span class="string">&#x27;Belly&#x27;</span>,age = <span class="number">20</span>,sex = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Belly&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）-匿名函数"><a href="#（三）-匿名函数" class="headerlink" title="（三） 匿名函数"></a>（三） 匿名函数</h2><h3 id="1-函数作为参数传递"><a href="#1-函数作为参数传递" class="headerlink" title="1. 函数作为参数传递"></a>1. 函数作为参数传递</h3><ul><li>函数本身可以作为参数，传入另一个函数中进行使用 </li><li>函数传入的作用在于：传入计算逻辑，而非传入数据</li></ul><h3 id="2-lambda匿名函数"><a href="#2-lambda匿名函数" class="headerlink" title="2. lambda匿名函数"></a>2. lambda匿名函数</h3><p>（1） 函数定义：</p><ul><li>def关键字：定义带有名称的函数（可以使用名称进行重复使用） </li><li>lambda关键字：定义匿名函数（只可临时使用一次）</li></ul><p>（2） lambda基本语法：</p><p>lambda 传入参数：函数体（一行代码）</p><p>！ 函数体只可写一行代码，无法写多行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">test</span><span class="params">(compute)</span>:</span><br><span class="line">    result = compute(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">test(lambda x,y:x + y)</span><br></pre></td></tr></table></figure><h2 id="（一）-文件的编码"><a href="#（一）-文件的编码" class="headerlink" title="（一） 文件的编码"></a>（一） 文件的编码</h2><h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h3><ul><li>编码是一种规则集合，记录了内容和二进制间进行相互转换的逻辑 </li><li>编码有许多种，最常用的是utf-8</li></ul><h3 id="2-使用编码的原因"><a href="#2-使用编码的原因" class="headerlink" title="2. 使用编码的原因"></a>2. 使用编码的原因</h3><ul><li>计算机只能识别二进制数，因此要将文件的内容翻译为二进制数，才能保存进计算机内 </li><li>同时也需要编码，将计算机保存的二进制数，反向编译回可识别的内容</li></ul><h2 id="（二）-文件的读取"><a href="#（二）-文件的读取" class="headerlink" title="（二） 文件的读取"></a>（二） 文件的读取</h2><ol><li>文件的基本操作步骤</li></ol><ul><li>打开文件 </li><li>读写文件 </li><li>关闭文件</li></ul><p>！ 可以只读，不写</p><ol start="2"><li>文件的基本操作函数</li></ol><p>！ 读取文件后，要用进行关闭，否则文件一直被占用</p><p>$练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word = open(<span class="string">&#x27;D:\Desktop\word.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">L = word.readlines()</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">print(L)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in L:</span><br><span class="line">    num = num + i.count(<span class="string">&quot;itheima&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><h2 id="（三）-文件的写入"><a href="#（三）-文件的写入" class="headerlink" title="（三） 文件的写入"></a>（三） 文件的写入</h2><ol><li>写操作快速入门：</li></ol><p>（1） 使用open的“w”模式进行写入</p><p>（2） 文件写入：f.write（）</p><p>（3） 内容刷新：f.flush（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">f = open(<span class="string">&#x27;D:\Desktop\word.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 写入文件</span><br><span class="line">f.write(<span class="string">&#x27;hello world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 内容刷新</span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure><p><strong>！ 直接调用write，内容并未真正写入文件，而是积攒在程序的内存中，称为缓冲区</strong></p><p><strong>！ 当调用flush时，文件才会真正写入文件</strong></p><p><strong>！ 这样避免频繁的操作硬盘，导致效率下降</strong></p><ol start="2"><li>注意事项：</li></ol><ul><li>w模式，文件不存在，会创建新文件 </li><li>w模式，文件存在，会清空原有内容 </li><li>close方法，具有flush方法的作用</li></ul><h2 id="（四）-文件的追加"><a href="#（四）-文件的追加" class="headerlink" title="（四） 文件的追加"></a>（四） 文件的追加</h2><ol><li>追加写入操作的快速入门</li></ol><p>（1） 使用open的“a”模式进行写入</p><p>（2） 文件写入：f.write（）</p><p>（3） 内容刷新：f.flush（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开文件</span><br><span class="line">f = open(<span class="string">&#x27;D:\Desktop\word.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 文件写入</span><br><span class="line">f.write(<span class="string">&#x27;I like pyhton!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 内容刷新</span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure><ol start="2"><li>注意事项</li></ol><ul><li>a模式，文件不存在，不会创建文件 </li><li>a模式，文件存在，会在最后追加写入文件</li></ul><h2 id="（五）-综合案例"><a href="#（五）-综合案例" class="headerlink" title="（五） 综合案例"></a>（五） 综合案例</h2><h2 id="（一）-了解异常"><a href="#（一）-了解异常" class="headerlink" title="（一） 了解异常"></a>（一） 了解异常</h2><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h3><ul><li>程序运行的过程中出现了错误</li></ul><h3 id="2-bug"><a href="#2-bug" class="headerlink" title="2. bug"></a>2. bug</h3><ul><li>bug就是指异常的意思，因为历史是因为小虫子导致计算机失灵的案例，所以延续至今，bug就代表软件出现错误</li></ul><h2 id="（二）-异常的捕获方法"><a href="#（二）-异常的捕获方法" class="headerlink" title="（二） 异常的捕获方法"></a>（二） 异常的捕获方法</h2><h3 id="1-程序出现bug后的情况"><a href="#1-程序出现bug后的情况" class="headerlink" title="1. 程序出现bug后的情况"></a>1. 程序出现bug后的情况</h3><ul><li>程序因为一个bug停止运行 </li><li>对bug进行提醒·，整个程序继续运行</li></ul><h3 id="2-为什么要捕获异常？"><a href="#2-为什么要捕获异常？" class="headerlink" title="2. 为什么要捕获异常？"></a>2. 为什么要捕获异常？</h3><ul><li>在可能发生异常的方法，进行捕获，当出现异常时，提供解决方式，而不是任由其导致程序无法运行 </li><li>作用：提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段</li></ul><h2 id="（三）-异常综合案例"><a href="#（三）-异常综合案例" class="headerlink" title="（三） 异常综合案例"></a>（三） 异常综合案例</h2><h2 id="（四）-Pyhton模块"><a href="#（四）-Pyhton模块" class="headerlink" title="（四） Pyhton模块"></a>（四） Pyhton模块</h2><h2 id="（五）-Python包"><a href="#（五）-Python包" class="headerlink" title="（五） Python包"></a>（五） Python包</h2><h2 id="（六）-安装第三类Python包"><a href="#（六）-安装第三类Python包" class="headerlink" title="（六） 安装第三类Python包"></a>（六） 安装第三类Python包</h2>]]></content>
    
    
    <summary type="html">python学习</summary>
    
    
    
    <category term="Python" scheme="https://bennettgao.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://bennettgao.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
