<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/myblog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/myblog/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/myblog/images/favicon.ico">
  <link rel="mask-icon" href="/myblog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/myblog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bennettg6.gitee.io","root":"/myblog/","images":"/myblog/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/myblog/js/config.js"></script>

    <meta name="description" content="java自用学习笔记，比较简陋，欢迎学习与交流">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础学习笔记">
<meta property="og:url" content="https://bennettg6.gitee.io/myblog/2023/08/21/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Bennett の BLOG">
<meta property="og:description" content="java自用学习笔记，比较简陋，欢迎学习与交流">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210429150845555.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a78e034ed81343a1859783161a83f193.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4e744525a72247c1a091deacc3508ceb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/548f0ac51a2c413a9032552d8603ea0f.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/6dda1686-b38e-4a88-b7b9-cdf767405545.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/519ae451-a421-4cb6-a575-ff46187487c4.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/2be7d61a-f513-4e5d-aa4b-ccf3c16e1cfd.png?msec=1681038201688">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210616175436943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/b31caab1-f83b-49a4-a25d-cd74f0631ffe.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/7ae67b77-245e-4b50-8f22-3872be2cf7d9.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/d6e042ae-9eba-412c-a522-a2840c05601f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305000445812.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305001135544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305002233296.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305002306124.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305003304870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305003408605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305004128646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190305005713575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/3385e99f-6fa8-42ec-a24b-a48134c68fa9.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/207be562-0a32-4f5c-8b85-8563a8c56db7.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/53456b23-3d52-44f5-95db-3e65db0e04dc.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/56ad66ce-a912-4aaa-a2c7-577052c7e9f9.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/e456d783-f2f2-41c8-b426-2b0d1f6988d6.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/82810560-a2f7-468d-a0bf-cc0cd2a366f5.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/49f5e2f0-9b02-4080-93b2-24803483ef17.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/256c026c-3def-47f9-8410-35f67b6bd683.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/01bd44fd-44ca-4101-a9a6-edd48f5f3bfc.png">
<meta property="og:image" content="file:///C:/Users/26927/Pictures/Typedown/92a78951-33e1-4e67-b96b-0a9c00075090.png">
<meta property="article:published_time" content="2023-08-21T08:15:30.795Z">
<meta property="article:modified_time" content="2023-08-21T08:29:58.187Z">
<meta property="article:author" content="Bennett Gao">
<meta property="article:tag" content="技术学习与分享">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210429150845555.png">


<link rel="canonical" href="https://bennettg6.gitee.io/myblog/2023/08/21/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://bennettg6.gitee.io/myblog/2023/08/21/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","path":"2023/08/21/java程序设计基础/","title":"java基础学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>java基础学习笔记 | Bennett の BLOG</title>
  








  <noscript>
    <link rel="stylesheet" href="/myblog/css/noscript.css">
  </noscript>
<link rel="alternate" href="/myblog/atom.xml" title="Bennett の BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/myblog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bennett の BLOG</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">鱼乘于水，鸟乘于风，草木乘于时</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/myblog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/myblog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/myblog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <!-- canvas粒子时钟 -->
      
       <div id="">
  <canvas id="canvas" style="width:80%;">
</div>
<script async>
(function(){
  var WINDOW_WIDTH = 820;
  		var WINDOW_HEIGHT = 250;
  		var RADIUS = 7; //球半径
  		var NUMBER_GAP = 10; //数字之间的间隙
  		var u=0.65; //碰撞能量损耗系数
  		var context; //Canvas绘制上下文
  		var balls = []; //存储彩色的小球
  		const colors = ["#33B5E5","#0099CC","#AA66CC","#9933CC","#99CC00","#669900","#FFBB33","#FF8800","#FF4444","#CC0000"]; //彩色小球的颜色
  		var currentNums = []; //屏幕显示的8个字符
  		var digit =
                  [
                      [
                          [0,0,1,1,1,0,0],
                          [0,1,1,0,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,0,1,1,0],
                          [0,0,1,1,1,0,0]
                      ],//0
                      [
                          [0,0,0,1,1,0,0],
                          [0,1,1,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [1,1,1,1,1,1,1]
                      ],//1
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,0,0,0],
                          [0,1,1,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,0,0,0,1,1],
                          [1,1,1,1,1,1,1]
                      ],//2
                      [
                          [1,1,1,1,1,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,1,0,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//3
                      [
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,1,0],
                          [0,0,1,1,1,1,0],
                          [0,1,1,0,1,1,0],
                          [1,1,0,0,1,1,0],
                          [1,1,1,1,1,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,1,1]
                      ],//4
                      [
                          [1,1,1,1,1,1,1],
                          [1,1,0,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,1,1,1,1,0],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//5
                      [
                          [0,0,0,0,1,1,0],
                          [0,0,1,1,0,0,0],
                          [0,1,1,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,0,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//6
                      [
                          [1,1,1,1,1,1,1],
                          [1,1,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0]
                      ],//7
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//8
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,1,1,0,0,0,0]
                      ],//9
                      [
                          [0,0,0,0],
                          [0,0,0,0],
                          [0,1,1,0],
                          [0,1,1,0],
                          [0,0,0,0],
                          [0,0,0,0],
                          [0,1,1,0],
                          [0,1,1,0],
                          [0,0,0,0],
                          [0,0,0,0]
                      ]//:
                  ];

  		function drawDatetime(cxt){
  			var nums = [];

  			context.fillStyle="#005eac"
  			var date = new Date();
  			var offsetX = 70, offsetY = 30;
  			var hours = date.getHours();
  			var num1 = Math.floor(hours/10);
  			var num2 = hours%10;
  			nums.push({num: num1});
  			nums.push({num: num2});
  			nums.push({num: 10}); //冒号
  			var minutes = date.getMinutes();
  			var num1 = Math.floor(minutes/10);
  			var num2 = minutes%10;
  			nums.push({num: num1});
  			nums.push({num: num2});
  			nums.push({num: 10}); //冒号
  			var seconds = date.getSeconds();
  			var num1 = Math.floor(seconds/10);
  			var num2 = seconds%10;
  			nums.push({num: num1});
  			nums.push({num: num2});

  			for(var x = 0;x<nums.length;x++){
  				nums[x].offsetX = offsetX;
  				offsetX = drawSingleNumber(offsetX,offsetY, nums[x].num,cxt);
  				//两个数字连一块，应该间隔一些距离
  				if(x<nums.length-1){
  					if((nums[x].num!=10) &&(nums[x+1].num!=10)){
  						offsetX+=NUMBER_GAP;
  					}
  				}
  			}

  			//说明这是初始化
  			if(currentNums.length ==0){
  				currentNums = nums;
  			}else{
  				//进行比较
  				for(var index = 0;index<currentNums.length;index++){
  					if(currentNums[index].num!=nums[index].num){
  						//不一样时，添加彩色小球
  						addBalls(nums[index]);
  						currentNums[index].num=nums[index].num;
  					}
  				}
  			}
  			renderBalls(cxt);
  			updateBalls();

  			return date;
  		}

  		function addBalls (item) {
  			var num = item.num;
  			var numMatrix = digit[num];
  			for(var y = 0;y<numMatrix.length;y++){
  				for(var x = 0;x<numMatrix[y].length;x++){
  					if(numMatrix[y][x]==1){
  						var ball={
  							offsetX:item.offsetX+RADIUS+RADIUS*2*x,
  							offsetY:30+RADIUS+RADIUS*2*y,
  							color:colors[Math.floor(Math.random()*colors.length)],
  							g:1.5+Math.random(),
  							vx:Math.pow(-1, Math.ceil(Math.random()*10))*4+Math.random(),
  							vy:-5
  						}
  						balls.push(ball);
  					}
  				}
  			}
  		}

  		function renderBalls(cxt){
  			for(var index = 0;index<balls.length;index++){
  				cxt.beginPath();
  				cxt.fillStyle=balls[index].color;
  				cxt.arc(balls[index].offsetX, balls[index].offsetY, RADIUS, 0, 2*Math.PI);
  				cxt.fill();
  			}
  		}

  		function updateBalls () {
  			var i =0;
  			for(var index = 0;index<balls.length;index++){
  				var ball = balls[index];
  				ball.offsetX += ball.vx;
  				ball.offsetY += ball.vy;
  				ball.vy+=ball.g;
  				if(ball.offsetY > (WINDOW_HEIGHT-RADIUS)){
  					ball.offsetY= WINDOW_HEIGHT-RADIUS;
  					ball.vy=-ball.vy*u;
  				}
  				if(ball.offsetX>RADIUS&&ball.offsetX<(WINDOW_WIDTH-RADIUS)){

  					balls[i]=balls[index];
  					i++;
  				}
  			}
  			//去除出边界的球
  			for(;i<balls.length;i++){
  				balls.pop();
  			}
  		}
  		function drawSingleNumber(offsetX, offsetY, num, cxt){
  			var numMatrix = digit[num];
  			for(var y = 0;y<numMatrix.length;y++){
  				for(var x = 0;x<numMatrix[y].length;x++){
  					if(numMatrix[y][x]==1){
  						cxt.beginPath();
  						cxt.arc(offsetX+RADIUS+RADIUS*2*x,offsetY+RADIUS+RADIUS*2*y,RADIUS,0,2*Math.PI);
  						cxt.fill();
  					}
  				}
  			}
  			cxt.beginPath();
  			offsetX += numMatrix[0].length*RADIUS*2;
  			return offsetX;
  		}

  		var canvas = document.getElementById("canvas");
  		canvas.width=WINDOW_WIDTH;
  		canvas.height=WINDOW_HEIGHT;
  		context = canvas.getContext("2d");

  		//记录当前绘制的时刻
  		var currentDate = new Date();

  		setInterval(function(){
  			//清空整个Canvas，重新绘制内容
  			context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  			drawDatetime(context);
  		}, 50)
})();
</script>


    
 
<ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Java语言概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BA%A7%E7%94%9F%E3%80%81%E5%BA%94%E7%94%A8%E5%89%8D%E6%99%AF%E5%92%8C%E7%89%B9%E7%82%B9%EF%BC%9B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">Java 语言的产生、应用前景和特点；（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8AJava%E8%BF%90%E8%A1%8C%E7%B3%BB%E7%BB%9F%EF%BC%9B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">Java虚拟机及Java运行系统；（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E8%AF%AD%E8%A8%80%E5%92%8C-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%9B%B8%E5%90%8C%E5%8F%8A%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9B"><span class="nav-number">1.3.</span> <span class="nav-text">Java 语言和 C++语言的相同及不同之处；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E3%80%82"><span class="nav-number">1.4.</span> <span class="nav-text">Java 应用程序的编写、编译和运行过程。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">java语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89%EF%BC%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%EF%BC%9B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9B"><span class="nav-number">2.2.</span> <span class="nav-text">Java语言各种数据类型；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%9B"><span class="nav-number">2.3.</span> <span class="nav-text">Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%EF%BC%9B"><span class="nav-number">2.4.</span> <span class="nav-text">Java语言变量、常量的使用及其运算操作；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">Java语言流程控制语句的功能及使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9B%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82"><span class="nav-number">2.6.</span> <span class="nav-text">Java数组的定义；数组的初始化和数组的应用；二维数组的应用。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">面向对象的概念（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%9B"><span class="nav-number">3.2.</span> <span class="nav-text">类的创建与使用；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">方法的定义和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">对象的基本操作方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">抽象类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">抽象类和接口的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">Java中的内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">单例模式（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">模板设计方法（了解）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%BC%82%E5%B8%B8"><span class="nav-number">5.</span> <span class="nav-text">java异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">异常的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">异常的处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#try-catch-finally"><span class="nav-number">5.2.1.</span> <span class="nav-text">try-catch-finally</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#throws"><span class="nav-number">5.2.2.</span> <span class="nav-text">throws</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#throw"><span class="nav-number">5.2.3.</span> <span class="nav-text">throw</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.3.</span> <span class="nav-text">自定义异常的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text">字符串相关类的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System%E7%B1%BB%E4%B8%8ERuntime%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9B"><span class="nav-number">6.2.</span> <span class="nav-text">System类与Runtime类的使用；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math%E7%B1%BB%E4%B8%8ERandom%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.3.</span> <span class="nav-text">Math类与Random类的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">日期类的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">7.</span> <span class="nav-text">集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E3%80%81Map%E3%80%81Set%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.1.</span> <span class="nav-text">List、Map、Set集合的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">集合遍历的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.</span> <span class="nav-text">泛型的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.</span> <span class="nav-text">集合工具类的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-API%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.5.</span> <span class="nav-text">Stream API的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-IO"><span class="nav-number">8.</span> <span class="nav-text">Java IO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">File类及其用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">8.2.</span> <span class="nav-text">操作字节流和字符流读写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96IO%E6%B5%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">8.3.</span> <span class="nav-text">其他IO流（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">8.4.</span> <span class="nav-text">NIO的概念及其用法（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">8.5.</span> <span class="nav-text">常见字符编码（了解）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="nav-number">9.</span> <span class="nav-text">图形用户界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AWT%E7%BB%84%E4%BB%B6%E5%92%8CSwing%E7%BB%84%E4%BB%B6%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">AWT组件和Swing组件的联系和区别（了解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Swing%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">11.</span> <span class="nav-text">常用的Swing组件的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AA%97%E4%BD%93%E5%92%8C%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">11.1.</span> <span class="nav-text">常用的窗体和布局管理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E8%BE%B9%E6%A1%86%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8-BorderLayout"><span class="nav-number">11.2.</span> <span class="nav-text">1.1 边框布局管理器(BorderLayout)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-BorderLayout-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">11.2.1.</span> <span class="nav-text">1.2 BorderLayout 布局管理器的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.2.2.</span> <span class="nav-text">1.3 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8-FlowLayout"><span class="nav-number">11.3.</span> <span class="nav-text">二、流式布局管理器(FlowLayout)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-FlowLayout"><span class="nav-number">11.3.1.</span> <span class="nav-text">2.1 FlowLayout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-FlowLayout-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">11.3.2.</span> <span class="nav-text">2.2 FlowLayout 布局管理器的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.3.3.</span> <span class="nav-text">2.3 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8D%A1%E7%89%87%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8-CardLayout"><span class="nav-number">11.4.</span> <span class="nav-text">三、卡片布局管理器(CardLayout)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-CardLayout"><span class="nav-number">11.4.1.</span> <span class="nav-text">3.1 CardLayout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-CardLayout-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">11.4.2.</span> <span class="nav-text">3.2 CardLayout 的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.4.3.</span> <span class="nav-text">3.3 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8-GridLayout"><span class="nav-number">11.5.</span> <span class="nav-text">四、网格布局管理器(GridLayout)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-GridLayout"><span class="nav-number">11.5.1.</span> <span class="nav-text">4.1 GridLayout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-GridLayout-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">11.5.2.</span> <span class="nav-text">4.2 GridLayout 的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.5.3.</span> <span class="nav-text">4.3 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%BD%91%E6%A0%BC%E5%8C%85%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8-GridBagLayout"><span class="nav-number">11.6.</span> <span class="nav-text">五、网格包布局管理器(GridBagLayout)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-GridBagLayout"><span class="nav-number">11.6.1.</span> <span class="nav-text">5.1 GridBagLayout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-GridBagLayout%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="nav-number">11.6.2.</span> <span class="nav-text">5.2 GridBagLayout属性设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.6.3.</span> <span class="nav-text">5.3 示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">11.7.</span> <span class="nav-text">事件处理机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">Java多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">12.1.</span> <span class="nav-text">进程和线程的区别（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">创建线程的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E5%85%B6%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">12.3.</span> <span class="nav-text">线程的生命周期及其状态转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">12.4.</span> <span class="nav-text">多线程的同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">12.5.</span> <span class="nav-text">多线程之间的通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">12.6.</span> <span class="nav-text">线程池的使用（了解）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">13.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">14.</span> <span class="nav-text">Java网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-%E4%BA%86%E8%A7%A3"><span class="nav-number">14.1.</span> <span class="nav-text">网络通信协议(了解)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#TCP-x2F-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.1.0.1.</span> <span class="nav-text">TCP&#x2F;IP参考模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E9%80%9A%E4%BF%A1-%E4%BA%86%E8%A7%A3"><span class="nav-number">14.2.</span> <span class="nav-text">UDP通信(了解)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">14.3.</span> <span class="nav-text">TCP通信（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91"><span class="nav-number">14.4.</span> <span class="nav-text">网络程序的开发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E7%BC%96%E7%A8%8B"><span class="nav-number">15.</span> <span class="nav-text">JDBC编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">15.1.</span> <span class="nav-text">JDBC原理（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection%E6%8E%A5%E5%8F%A3%E3%80%81Statement%E6%8E%A5%E5%8F%A3%E3%80%81ResultSet%E6%8E%A5%E5%8F%A3%E3%80%81PreparedStatement%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9B"><span class="nav-number">15.2.</span> <span class="nav-text">Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">15.3.</span> <span class="nav-text">使用JDBC操作数据库</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bennett Gao"
      src="/myblog/images/HeadSculpture.jpg">
  <p class="site-author-name" itemprop="name">Bennett Gao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/myblog/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    	

  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bennettg6.gitee.io/myblog/2023/08/21/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/myblog/images/HeadSculpture.jpg">
      <meta itemprop="name" content="Bennett Gao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bennett の BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="java基础学习笔记 | Bennett の BLOG">
      <meta itemprop="description" content="java自用学习笔记，比较简陋，欢迎学习与交流">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-21 16:15:30 / 修改时间：16:29:58" itemprop="dateCreated datePublished" datetime="2023-08-21T16:15:30+08:00">2023-08-21</time>
    </span>

  
</div>

            <div class="post-description">java自用学习笔记，比较简陋，欢迎学习与交流</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><meta name="referrer" content="no-referrer" />



<meta name="referrer" content="no-referrer" /> 

<h3 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h3><h4 id="Java-语言的产生、应用前景和特点；（了解）"><a href="#Java-语言的产生、应用前景和特点；（了解）" class="headerlink" title="Java 语言的产生、应用前景和特点；（了解）"></a>Java 语言的产生、应用前景和特点；（了解）</h4><p>Java语言是由Sun Microsystems公司于1995年推出的一种面向对象编程语言，其产生源于对嵌入式设备和网络应用的需求。Java拥有跨平台、高效性、安全性等优点，被广泛应用于Web开发、企业级应用开发、移动应用开发、游戏开发等领域。</p>
<p>Java语言的主要特点包括：</p>
<ol>
<li><p>跨平台性：Java代码在编译后生成字节码，可以在任何支持Java虚拟机（JVM）的平台上运行，实现了”一次编写，到处运行”。</p>
</li>
<li><p>面向对象：Java是一种纯粹的面向对象编程语言，所有的数据类型都是对象，所有的操作都是方法调用。</p>
</li>
<li><p>自动内存管理：Java具有内置的垃圾收集器，可以自动回收不再使用的内存空间，避免了C++中常见的内存泄漏问题。</p>
</li>
<li><p>强类型检查：Java程序在编译时会进行类型检查，避免了类型转换错误等运行时错误。</p>
</li>
<li><p>安全性：Java提供了丰富的安全机制，如字节码校验、安全管理器等，可以保证程序的安全性。</p>
</li>
<li><p>多线程支持：Java提供了高级的多线程支持库和同步机制，方便开发人员编写多线程程序。</p>
</li>
</ol>
<p>从目前的趋势来看，Java仍然是一种非常流行的编程语言，它的应用前景非常广泛。在企业级应用开发、Web应用开发、大数据处理、云计算等领域，Java都有着广泛的应用。同时，Java社区也非常活跃，涌现出了很多优秀的开源框架和工具，如Spring、Hibernate、Maven等，它们可以帮助开发人员更高效地进行开发，并提高了Java应用程序的质量。此外，由于移动互联网的普及，Java在移动应用开发领域也有不少的应用，如Android应用程序开发。</p>
<p>总之，Java作为一种强大、灵活、安全和跨平台的编程语言，具有广泛的应用前景，在各行业都有着较为广泛的应用需求。同时，由于其开源性质，Java社区中不断涌现出更多优秀的框架和工具，使得Java语言变得更加易于使用和学习。</p>
<h4 id="Java虚拟机及Java运行系统；（了解）"><a href="#Java虚拟机及Java运行系统；（了解）" class="headerlink" title="Java虚拟机及Java运行系统；（了解）"></a>Java虚拟机及Java运行系统；（了解）</h4><p>Java虚拟机（JVM）是一个可以执行Java字节码的虚拟计算机，负责将编译后的Java源代码转换成可执行的字节码，并提供了内存管理、垃圾回收、安全检查和动态链接等功能。JVM的核心是一个解释器和一个即时编译器，能够在运行时动态优化代码，提高应用程序的性能。</p>
<p>Java运行系统（JRE）是Java应用程序的运行环境，包括Java虚拟机、Java类库和其他运行所需的文件。JRE可以在不同的平台上运行Java程序，并且与操作系统相对独立，因此Java程序能够实现跨平台运行。</p>
<p>Java虚拟机和Java运行系统的结构如下：</p>
<ol>
<li><p>Java虚拟机由三个子系统组成：类加载器、运行时数据区和执行引擎。类加载器负责将编写好的Java代码加载到JVM中；运行时数据区包括方法区、堆、栈、本地方法栈和程序计数器等几个部分，用于存储Java对象、JVM执行状态和方法信息等；执行引擎则负责执行Java字节码。</p>
</li>
<li><p>Java运行系统包括两部分：JRE和Java开发工具包（JDK）。JRE是Java应用程序的运行环境，包括Java虚拟机、Java类库和其他运行所需的文件；而JDK则是Java开发人员的工具包，除了包含JRE之外，还包括编译器、调试器、文档生成器等开发工具，用于编写和调试Java程序。</p>
</li>
</ol>
<p>总之，Java虚拟机和Java运行系统是Java程序运行的基础，Java程序通过这些机制来实现跨平台运行，并提供了强大的内存管理、安全检查和动态链接等功能，极大地简化了Java应用程序的开发和部署。因此，Java虚拟机和Java运行系统是Java语言成功的关键所在，也是Java语言广泛应用于各个领域的重要原因之一。</p>
<h4 id="Java-语言和-C-语言的相同及不同之处；"><a href="#Java-语言和-C-语言的相同及不同之处；" class="headerlink" title="Java 语言和 C++语言的相同及不同之处；"></a>Java 语言和 C++语言的相同及不同之处；</h4><p>Java 和 C++ 都是面向对象的编程语言，它们在语法和基本概念上有些相似，例如类、继承、多态等。但是，两者之间还存在一些不同之处：</p>
<ol>
<li><p>平台依赖性：Java是跨平台的，因为Java程序不直接运行于操作系统，而是通过Java虚拟机（JVM）来执行，可以在任何支持JVM的平台上运行；而C++是与特定操作系统相关的，需要编译成对应平台的可执行文件。</p>
</li>
<li><p>内存管理：Java中的内存管理是由垃圾回收器负责的，开发人员无需手动分配或释放内存，避免了C++中常见的内存泄漏问题。</p>
</li>
<li><p>异常处理：Java支持异常处理机制，在出现异常时会抛出异常并进行处理，而C++中则使用try&#x2F;catch机制实现异常处理。</p>
</li>
<li><p>多线程：Java天生支持多线程编程，提供了高级的线程支持库和同步机制，方便开发人员编写多线程程序。C++也支持多线程编程，但需要使用操作系统提供的线程API和同步机制。</p>
</li>
<li><p>代码复杂度：相对于C++，Java的代码更容易阅读和理解，因为Java具有更简单的语法，同时也有更多的自动化功能，如垃圾回收等。</p>
</li>
</ol>
<p>总体来说，Java更适合开发大型企业级应用程序，尤其是网络应用程序，而C++更适合低层次系统编程和性能要求高的应用程序。</p>
<h4 id="Java-应用程序的编写、编译和运行过程。"><a href="#Java-应用程序的编写、编译和运行过程。" class="headerlink" title="Java 应用程序的编写、编译和运行过程。"></a>Java 应用程序的编写、编译和运行过程。</h4><p>Java应用程序的编写、编译和运行过程主要包括以下几个步骤：</p>
<ol>
<li><p>编写Java源代码：使用文本编辑器或IDE（集成开发环境）编写Java源代码，以.java为文件扩展名保存。</p>
</li>
<li><p>编译Java源代码：使用Java编译器将Java源代码编译成字节码，以.class为文件扩展名保存。在命令行窗口中，可以使用“javac”命令进行编译，例如：“javac HelloWorld.java”。</p>
</li>
<li><p>运行Java程序：使用Java虚拟机（JVM）来执行编译后的Java字节码文件，以.class为文件扩展名。在命令行窗口中，可以使用“java”命令来运行Java程序，例如：“java HelloWorld”。</p>
</li>
<li><p>测试和调试：通过单元测试、集成测试等方式对Java程序进行测试，如果出现问题，则需要进行调试和修复，在开发过程中反复进行上述步骤。</p>
</li>
</ol>
<p>总之，Java应用程序的编写、编译和运行过程是一个由多个步骤组成的过程，需要遵循一定的规范和标准。开发人员在编写Java程序时，需要熟悉Java语言和编程环境，并且注意代码的质量和性能。同时，Java社区中也有很多优秀的开源框架和工具，如Spring、Hibernate、Maven等，可以帮助开发人员更高效地进行开发，并提高了Java应用程序的质量。</p>
<h3 id="java语言基础"><a href="#java语言基础" class="headerlink" title="java语言基础"></a>java语言基础</h3><h4 id="数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）"><a href="#数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）" class="headerlink" title="数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）"></a>数据类型的转换（自动类型转换和强制类型转换）；运算符的优先级和结合性；（了解）</h4><p>数据类型的转换：</p>
<p>Java中有两种数据类型的转换：自动类型转换和强制类型转换。</p>
<ol>
<li><p>自动类型转换：当一种数据类型的值赋值给另一种数据类型时，如果目标类型可以容纳原始类型的数据，则会自动进行类型转换。例如，将int类型的值赋值给double类型的变量，编译器会自动将int类型转换为double类型。</p>
</li>
<li><p>强制类型转换：当需要将一个较大的数值类型转换成一个较小的数值类型时，需要使用强制类型转换。在强制类型转换时，需要在括号内指定要转换的数据类型。例如，将double类型的值转换为int类型的值，可以使用强制类型转换运算符，例如：“int a &#x3D; (int) 3.14”。<br><img src="https://img-blog.csdnimg.cn/20210429150845555.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>运算符的优先级和结合性：</p>
<p>Java中有多种运算符，它们具有不同的优先级和结合性，可以通过以下规则来确定表达式的计算顺序：</p>
<ol>
<li><p>括号优先级最高，先计算括号内的表达式。</p>
</li>
<li><p>先计算高优先级的运算符，再计算低优先级的运算符。如果有相同优先级的运算符，则按照结合性从左到右或从右到左计算，例如“+”和“-”运算符的结合性是从左到右。</p>
</li>
<li><p>赋值运算符“&#x3D;”的优先级最低。</p>
</li>
</ol>
<p>下面是常见运算符的优先级从高到低的顺序：</p>
<p>以下是Java中常见的运算符优先级，按照从高到低的顺序排列：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>() []</td>
<td align="center">括号，具有最高优先级，用于强制改变运算符的计算顺序</td>
</tr>
<tr>
<td>! ~ ++ – -</td>
<td align="center">一元运算符，包括取反、位非、自增、自减、负数等</td>
</tr>
<tr>
<td>* &#x2F; %</td>
<td align="center">乘法、除法、取模 new同级</td>
</tr>
<tr>
<td>+ -</td>
<td align="center">加法、减法</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td align="center">位移运算符，分别表示左移、右移、无符号右移</td>
</tr>
<tr>
<td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="center">关系运算符，用于比较两个值的大小关系</td>
</tr>
<tr>
<td>&#x3D;&#x3D; !&#x3D;</td>
<td align="center">等于、不等于</td>
</tr>
<tr>
<td>&amp;</td>
<td align="center">按位与</td>
</tr>
<tr>
<td>^</td>
<td align="center">按位异或</td>
</tr>
<tr>
<td>|</td>
<td align="center">按位或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td align="center">逻辑与</td>
</tr>
<tr>
<td>||</td>
<td align="center">逻辑或</td>
</tr>
<tr>
<td>?:</td>
<td align="center">三目运算符，用于条件判断</td>
</tr>
<tr>
<td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</td>
<td align="center">赋值运算符，包括复合赋值运算符和位移赋值运算符</td>
</tr>
</tbody></table>
<p>在实际编程中，为了避免优先级和结合性引起的错误，建议使用括号来明确表达式的计算顺序。同时，也需要注意强制类型转换可能会导致数据丢失或溢出问题，需要进行适当的检查和处理。</p>
<h4 id="Java语言各种数据类型；"><a href="#Java语言各种数据类型；" class="headerlink" title="Java语言各种数据类型；"></a>Java语言各种数据类型；</h4><p>Java语言中有8种基本数据类型，可以分为4种整型、2种浮点型、1种字符型和1种布尔型。具体如下：</p>
<ol>
<li><p>整型（4种）：byte、short、int、long。</p>
</li>
<li><p>浮点型（2种）：float、double。</p>
</li>
<li><p>字符型（1种）：char。</p>
</li>
<li><p>布尔型（1种）：boolean。</p>
</li>
</ol>
<p>这些数据类型在Java中都是关键字，在程序中可以直接使用。各数据类型的范围和存储长度如下：</p>
<ol>
<li><p>byte：1字节，-128到127。</p>
</li>
<li><p>short：2字节，-32768到32767。</p>
</li>
<li><p>int：4字节，-2147483648到2147483647。</p>
</li>
<li><p>long：8字节，-9223372036854775808到9223372036854775807。</p>
</li>
<li><p>float：4字节，IEEE754标准表示的单精度浮点数。</p>
</li>
<li><p>double：8字节，IEEE754标准表示的双精度浮点数。</p>
</li>
<li><p>char：2字节，0到65535（Unicode编码）。</p>
</li>
<li><p>boolean：1位，true或false。</p>
</li>
</ol>
<p>可以根据需求选择不同的数据类型来存储数据，例如使用byte类型来存储文件内容，使用int类型来存储计数器等。同时，在进行数据类型转换时需要注意避免出现数据溢出或数据丢失的情况。</p>
<h4 id="Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；"><a href="#Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；" class="headerlink" title="Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；"></a>Java语言算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符的功能及使用；</h4><p>Java语言中有多种运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符和复合赋值运算符等。下面分别介绍这些运算符的功能及使用。</p>
<ol>
<li><p>算术运算符：用于处理数学运算，包括加减乘除、取余数等，常见的算术运算符有+、-、*、&#x2F;、%等。例如，a + b表示a与b的和，a % b表示a除以b的余数。</p>
</li>
<li><p>关系运算符：用于比较两个变量的关系，常见的关系运算符有&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;等。例如，a &gt; b表示a是否大于b，a &#x3D;&#x3D; b表示a是否等于b。</p>
</li>
<li><p>逻辑运算符：用于连接两个或多个表达式，常见的逻辑运算符有&amp;&amp;（与）、||（或）、！（非）等。例如，a &gt; b &amp;&amp; c &gt; d表示当a大于b并且c大于d时为真。</p>
</li>
<li><p>位运算符：用于对数据的二进制位进行操作，常见的位运算符有&amp;（按位与）、|（按位或）、^（按位异或）、~（按位取反）、&lt;&lt;（左移）、&gt;&gt;（右移）和&gt;&gt;&gt;（无符号右移）等。例如，a &amp; b表示将a和b按位与运算。</p>
</li>
<li><p>复合赋值运算符：用于简化赋值语句的编写，常见的复合赋值运算符有+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;、&gt;&gt;&gt;&#x3D;等。例如，a +&#x3D; b可以写成a &#x3D; a + b的形式。</p>
</li>
</ol>
<p>总之，Java语言中的各种运算符可帮助开发人员进行数学、逻辑和位运算，更高效地完成程序的设计和实现。在使用运算符时，需要注意数据类型的匹配和运算符的优先级和结合性，以避免出现错误的结果。同时，也可以通过括号来明确表达式的计算顺序，提高代码的可读性和可维护性。例如：</p>
<p><code>int a = 10, b = 3, c = 5; int result = (a + b) * c; // 使用括号明确计算顺序 System.out.println(result); // 输出65</code></p>
<p>另外还需要注意，在进行位运算时，需要特别小心因为这些运算是基于二进制表示的，如果使用不当可能会导致数据被修改或出现意外的结果。</p>
<h4 id="Java语言变量、常量的使用及其运算操作；"><a href="#Java语言变量、常量的使用及其运算操作；" class="headerlink" title="Java语言变量、常量的使用及其运算操作；"></a>Java语言变量、常量的使用及其运算操作；</h4><p>Java语言中，变量和常量是程序中存储数据的基本方式。下面分别介绍变量、常量的使用及其运算操作。</p>
<ol>
<li>变量：在程序中用于存储可变的数据值，需要先声明再使用，可以多次赋值。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a; // 声明变量a</span><br><span class="line"> a = 10; </span><br><span class="line">// 赋值为10</span><br><span class="line"> a = a + 5; </span><br><span class="line">// 加上5并重新赋值 </span><br><span class="line">System.out.println(a); // 输出15</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>常量：在程序中用于存储不可变的数据值，一旦被赋值就不能改变。通常使用关键字final来定义常量，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int MAX_VALUE = 100; // 定义一个常量</span><br><span class="line">//MAX_VALUE = 200; // 编译错误，无法更改常量的值 System.out.println(MAX_VALUE); // 输出100</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运算操作：在Java中，变量和常量可以进行各种数学和逻辑运算，在使用运算符时需要注意数据类型的匹配和运算符的优先级和结合性。例如：</li>
</ol>
<p>java复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 3; double c = 5.0;</span><br><span class="line"> int result = a / b;</span><br><span class="line"> // 整型除法，result的值为3 double result2 = a / c;</span><br><span class="line"> // 自动类型转换为浮点型，result2的值为2.0 int result3 = a % b;</span><br><span class="line"> // 取余数操作，result3的值为1  boolean flag = true; if (flag &amp;&amp; (a &gt; b)) &#123; // 使用逻辑与运算符和关系运算符     System.out.println(&quot;a is greater than b&quot;); &#125;</span><br></pre></td></tr></table></figure>

<p>总之，变量和常量是Java程序中存储数据的基本方式，可以通过各种运算操作来实现程序的需求。在使用过程中，需要遵循命名规范和数据类型规范，以提高代码的可读</p>
<p>性和可维护性，同时也需要注意变量的作用域和生命周期等问题。</p>
<p>在进行数学运算时，需要注意整型除法可能会出现数据截断的问题，因此可以使用浮点型变量或强制类型转换来避免这些问题。另外，还需要注意整型溢出问题，当超出了数据类型所能表示的范围时，结果将不可预测。在使用常量时，建议使用大写字母和下划线来命名，以便于区分变量和常量。</p>
<h4 id="Java语言流程控制语句的功能及使用"><a href="#Java语言流程控制语句的功能及使用" class="headerlink" title="Java语言流程控制语句的功能及使用"></a>Java语言流程控制语句的功能及使用</h4><p>Java语言中，流程控制语句用于控制程序的执行顺序，可以根据条件选择不同的分支或者重复执行某些代码。下面分别介绍流程控制语句的功能及使用。</p>
<ol>
<li><p>if语句：用于根据特定条件执行不同的代码块，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">if (a &gt; b) &#123;</span><br><span class="line">    System.out.println(&quot;a is greater than b&quot;);</span><br><span class="line">&#125; else if (a &lt; b) &#123;</span><br><span class="line">    System.out.println(&quot;a is less than b&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;a is equal to b&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch语句：用于根据不同条件执行不同的代码块，比if语句更加简洁，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int dayOfWeek = 3;</span><br><span class="line">switch (dayOfWeek) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        System.out.println(&quot;Monday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        System.out.println(&quot;Tuesday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        System.out.println(&quot;Wednesday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;Other day&quot;);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环：用于对一段代码进行固定次数的重复执行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while循环和do-while循环：用于在满足特定条件的情况下重复执行一段代码，其中while循环先检查条件再执行代码，而do-while循环先执行代码再检查条件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int j = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt; 10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>break和continue语句：用于控制循环的执行，break语句可用于跳出循环，continue语句可用于跳过当前迭代并进入下一迭代，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break; // 跳出循环</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">    if (j % 2 == 0) &#123;</span><br><span class="line">        continue; // 跳过当前迭代</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>return语句：用于退出函数并返回一个值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw语句：用于在程序中抛出异常，需要与try-catch语句一起使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a &lt; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;a must be greater than 0&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总之，Java语言中的流程控制语句可以帮助开发人员根据条件选择执行不同的代码块或重复执行某些代码，从而实现程序的需求。在使用时需要注意语法和使用场景，以避免出现逻辑错误和性能问题。</p>
<h4 id="Java数组的定义；数组的初始化和数组的应用；二维数组的应用。"><a href="#Java数组的定义；数组的初始化和数组的应用；二维数组的应用。" class="headerlink" title="Java数组的定义；数组的初始化和数组的应用；二维数组的应用。"></a>Java数组的定义；数组的初始化和数组的应用；二维数组的应用。</h4><p>Java数组是一组相同数据类型的元素的集合，可以通过下标来访问和修改数组中的元素。下面分别介绍Java数组的定义、初始化和应用，以及二维数组的应用。</p>
<ol>
<li><p>数组的定义：在Java中，使用方括号[]来定义一个数组，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers; // 定义一个整型数组</span><br><span class="line">String[] names; // 定义一个字符串数组</span><br><span class="line">double[] prices; // 定义一个双精度浮点数数组</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的初始化：在Java中，可以使用大括号{}来初始化一个数组，也可以使用new关键字在堆上分配空间进行初始化，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;1, 2, 3&#125;; // 使用大括号初始化数组</span><br><span class="line">String[] names = new String[5]; // 在堆上分配空间并初始化为null</span><br><span class="line">double[] prices = new double[]&#123;1.0, 2.0, 3.0&#125;; // 使用new关键字和大括号初始化数组</span><br></pre></td></tr></table></figure>

<p>3.数组的应用：在Java中，可以使用下标来访问和修改数组中的元素，数组下标从0开始，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;1, 2, 3&#125;;</span><br><span class="line">System.out.println(numbers[0]); // 输出1</span><br><span class="line">numbers[1] = 4;</span><br><span class="line">System.out.println(numbers[1]); // 输出4</span><br><span class="line"></span><br><span class="line">//可以使用Arrays.toString()来输出一个完整数组</span><br><span class="line"> System.out.println(Arrays.toString(num));</span><br></pre></td></tr></table></figure>

<p>4.数组排序<br>（1）<strong>数组遍历查找最小值法</strong>是一种常用的查找数组中最小值的方法。其基本思路是使用循环遍历整个数组，通过比较每个元素的大小来找到数组中的最小值。<br>具体实现步骤如下：</p>
<ol>
<li>使用一个变量temp记录当前所遍历到的最小值，将数组中的第一个元素赋值给temp作为初始值；</li>
<li>使用for循环遍历数组中的每个元素，从第二个元素开始比较；</li>
<li>如果当前元素比temp小，则将当前元素赋值给temp，以更新最小值；</li>
<li>循环结束后，temp中存储的就是数组中的最小值。</li>
</ol>
<p>该方法简单易懂，适用于各种类型的数组，并且空间复杂度和时间复杂度都比较低，是一种常见的查找数组最小值的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;5, 2, 3, 4, 5,&#125;; //数组遍历查找最小值法</span><br><span class="line">        int temp = a[0];</span><br><span class="line">        for (int index = 1; index &lt; 5; index++) &#123;</span><br><span class="line">            if (a[index] &lt; temp) &#123;</span><br><span class="line">                temp=a[index];</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>冒泡排序</strong>是一种简单的排序算法，它通过比较相邻元素的大小来重复地交换、移动数组中的元素，从而将一个无序的数组按照升序（或降序）排列。<br><img src="https://img-blog.csdnimg.cn/a78e034ed81343a1859783161a83f193.gif" alt="a78e034ed81343a1859783161a83f193"><br>找规律：总共比了4轮，轮数&#x3D;数组长度-1（arr.length-1）,<br>                  每轮比较的次数&#x3D;素组长度 — 轮数（arr.length-1-i），<br>   比较的轮数用一个for循环表示，每一轮里比较的次数用一个for循环表示，此处用双重for循环，<br><img src="https://img-blog.csdnimg.cn/4e744525a72247c1a091deacc3508ceb.png" alt="4e744525a72247c1a091deacc3508ceb"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//排序算法——冒泡排序</span><br><span class="line">       int[] num=&#123;90,99,25,24,23,22&#125;;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; num.length - 1; i++) &#123;  //外层循环控制  轮数=数组长度-1（arr.length-1）</span><br><span class="line">           //内层循环控制元素两两比较的次数</span><br><span class="line">           //每轮比较的次数=素组长度 — 轮数（arr.length-1-i）</span><br><span class="line">           for (int j = 0; j &lt; num.length - 1 - i; j++) &#123;</span><br><span class="line">                //判断是否满足交换条件</span><br><span class="line">               if (num[j] &gt; num[j + 1]) &#123;</span><br><span class="line">                   //如果满足--交换两个元素的值</span><br><span class="line">                   int temp = num[j];</span><br><span class="line">                   num[j] = num[j + 1];</span><br><span class="line">                   num[j + 1] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Arrays.toString(num));</span><br></pre></td></tr></table></figure>



<p>   5.二维数组的应用：在Java中，可以使用二维数组来表示表格等结构化数据，二维数组可以看做是一个由数组构成的数组，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[][] matrix = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;</span><br><span class="line">System.out.println(matrix[0][1]); // 输出2</span><br><span class="line">matrix[1][0] = 5;</span><br><span class="line">System.out.println(matrix[1][0]); // 输出5</span><br><span class="line"></span><br><span class="line">//可以使用Arrays.deepToString()输出完整二维数组</span><br><span class="line">Arrays.deepToString(allScore)</span><br></pre></td></tr></table></figure>

<p>总之，Java数组是一种重要的数据结构，可以用于存储和处理一组相同类型的数据。在使用时需要注意数组下标从0开始、数组越界问题、数组的初始化和数组越界问题等，特别是在遍历数组时需要格外小心。另外，Java中还提供了大量的数组操作方法，如排序、查找、求和、复制等，可以大大简化数组的处理过程。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;3, 1, 4, 1, 5, 9&#125;;</span><br><span class="line">Arrays.sort(numbers); // 对数组进行排序</span><br><span class="line">int index = Arrays.binarySearch(numbers, 5); // 查找元素5的下标</span><br><span class="line">int sum = Arrays.stream(numbers).sum(); // 求和</span><br><span class="line">int[] copy = Arrays.copyOf(numbers, 3); // 复制前3个元素</span><br></pre></td></tr></table></figure>

<p>二维数组可以看做是一个由一维数组构成的数组，在使用时需要注意行列的顺序以及各维度的大小等问题。可以使用多重循环来遍历和处理二维数组，也可以使用流式API进行处理。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[][] matrix = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;</span><br><span class="line">for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">        System.out.println(matrix[i][j]); // 遍历二维数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum = Arrays.stream(matrix)</span><br><span class="line">                .flatMapToInt(Arrays::stream)</span><br><span class="line">                .sum(); // 使用流式API求和</span><br></pre></td></tr></table></figure>

<p>总之，Java数组是一个非常有用的数据结构，可以用于存储和处理一组相同类型的数据。在使用时需要注意数组下标从0开始、数组越界问题、多维数组的应用等问题，同时也可以使用大量的数组操作方法来简化处理过程.</p>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="面向对象的概念（了解）"><a href="#面向对象的概念（了解）" class="headerlink" title="面向对象的概念（了解）"></a>面向对象的概念（了解）</h4><p>面向对象是一种程序设计的思想和方法，它将程序中的所有数据和操作都看做是一个对象，每个对象有自己的属性和行为，并且可以相互交互和协作。通过面向对象的方式，可以更加直观、灵活和可维护地实现程序逻辑。</p>
<p>在Java语言中，面向对象是一种基本的编程范式。面向对象的编程包括以下几个概念：</p>
<ol>
<li><p>类(class)：类是一种定义对象属性和行为的模板，可以看做是一种用户自定义的数据类型。每个类定义了对象的状态和行为，并提供了一组公共接口来访问和修改对象的状态。</p>
</li>
<li><p>对象(object)：对象是类的一个实例，具有类所定义的属性和行为。每个对象都具有独立的状态和行为，并可以与其他对象进行交互和协作。</p>
</li>
<li><p>方法(method)：方法是类中定义的用于执行特定任务的代码块，可以访问和修改对象的状态，并返回一个值或执行一些操作。</p>
</li>
<li><p>继承(inheritance)：继承是一种从一个类派生出新类的机制，新类可以继承原类的属性和方法，并可以添加自己的属性和方法。继承可以大大简化程序的设计和实现过程。</p>
</li>
<li><p>多态(polymorphism)：多态是一种在运行时选择不同实现的机制，允许使用相同的接口来访问不同的对象。多态可以提高程序的灵活性和可扩展性。</p>
</li>
<li><p>封装(encapsulation)：封装是一种将对象的状态和行为隐藏起来，只提供必要的接口供其他对象访问的机制。封装可以保证对象的安全性和稳定性。</p>
</li>
</ol>
<p>总之，面向对象是一种重要的编程思想和方法，它可以使程序更加清晰、灵活和可维护。在Java语言中，面向对象是一种基本的编程范式，包括类、对象、方法、继承、多态和封装等概念。通过面向对象的方式，可以将问题分解为更小的模块，并且可以更加直观地描述和实现系统的逻辑。同时，面向对象也可以提高程序的复用性、可扩展性和可测试性，从而大大提高程序的质量和效率。</p>
<p>在实践中，为了更好地应用面向对象的思想和方法，需要遵循一些设计原则和最佳实践。例如，单一职责原则(SRP)、开放封闭原则(OCP)、里氏替换原则(LSP)、依赖倒置原则(DIP)和接口隔离原则(ISP)等，这些原则可以帮助开发人员设计出更加优秀、可维护和可扩展的系统。另外，在Java中还有一些常用的设计模式，如工厂模式、单例模式、观察者模式等，这些模式可以在具体的场景中帮助开发人员更加高效地实现系统需求。</p>
<p>总之，面向对象是一种重要的编程思想和方法，可以使程序更加清晰、灵活和可维护。在Java语言中，面向对象是一种基本的编程范式，包括类、对象、方法、继承、多态和封装等概念，同时也需要遵循一些设计原则和最佳实践，以实现高质量的软件系统。</p>
<h4 id="类的创建与使用；"><a href="#类的创建与使用；" class="headerlink" title="类的创建与使用；"></a>类的创建与使用；</h4><p>在Java中，类是一种用户自定义的数据类型，它用于描述对象的属性和行为，并提供了一组公共接口来访问和修改对象的状态。下面介绍如何创建和使用Java类。</p>
<ol>
<li><p>类的创建：在Java中，可以使用关键字class来定义一个类，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个例子定义了一个名为Person的类，它具有两个私有属性name和age以及四个公共方法getName、setName、getAge和setAge。其中，构造函数用于创建对象，并初始化对象的状态</p>
<ol start="2">
<li><p>对象的创建：在Java中，可以使用new关键字来创建一个对象，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person(&quot;Alice&quot;, 20);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个例子创建了一个名为p的Person对象，并将其初始化为姓名为Alice、年龄为20。</p>
<ol start="3">
<li><p>对象的使用：在Java中，使用点号(.)来访问和修改对象的属性和调用对象的方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = p.getName(); // 获取对象的姓名</span><br><span class="line">p.setAge(21); // 修改对象的年龄</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的继承：在Java中，可以通过extends关键字来实现类的继承，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123;</span><br><span class="line">    private String major;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age, String major) &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMajor() &#123;</span><br><span class="line">        return major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMajor(String major) &#123;</span><br><span class="line">        this.major = major;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个例子定义了一个名为Student的类，它是Person类的子类，具有一个额外的属性major。在构造函数中，使用super关键字调用父类的构造函数来初始化姓名和年龄。</p>
<ol start="5">
<li><p>对象的多态：在Java中，可以通过向上转型和方法重写等机制实现对象的多态性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Student(&quot;Bob&quot;, 22, &quot;Computer Science&quot;);</span><br><span class="line">String name = p.getName(); // 调用父类的方法</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个例子创建了一个名为p的Person对象，并将其指向一个Student对象。由于Student是Person的子类，因此可以向上转型为Person类型，并访问Person中定义的公共接口。</p>
<p>总之，在Java中，创建和使用类是一种基本的编程技能。需要熟悉类的定义、对象的创建和使用、继承和多态等概念，并遵循相关的设计原则和最佳实践，以实现高质量的软件系统。同时，在实践中还需要注意类的命名规范、属性的封装、方法的参数和返回值等问题，以保证程序的正确性和可维护性。</p>
<h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>方法是一段可重复调用的代码块，用于完成特定的任务。在程序中定义方法后，可以在需要的地方多次调用该方法，从而避免重复编写相同的代码。</p>
<p>方法通常由方法名、参数列表和方法体组成。方法名是唯一的标识符，描述了方法执行的任务。参数列表包含了传递给方法的参数，这些参数可以在方法体中使用。方法体是实现方法功能的代码块。</p>
<p>要使用一个方法，只需通过方法名和必要的参数调用它即可。方法的返回值可以用来提供操作结果或状态信息。</p>
<p>例如，下面是一个简单的Java方法，用于计算两个整数的和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int add(int x, int y) &#123; </span><br><span class="line"></span><br><span class="line">   return x + y</span><br><span class="line"></span><br><span class="line">;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在程序中，可以通过以下方式调用该方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result = add(2, 3);</span><br></pre></td></tr></table></figure>

<p>此时，result 的值将为 5，因为传递给 add 方法的两个参数分别为 2 和 3，方法计算它们的和并返回结果。</p>
<h4 id="对象的基本操作方式"><a href="#对象的基本操作方式" class="headerlink" title="对象的基本操作方式"></a>对象的基本操作方式</h4><p>对象是类的一个实例，通常用来表示现实世界中的某个实体或概念。在程序中，我们可以通过创建对象来操作它们的属性和方法，实现特定的功能。</p>
<p>以下是对象的基本操作方式：</p>
<ol>
<li><pre><code>创建对象：使用关键字“new”加上类名来创建一个对象，并将其赋值给一个变量。
Person person = new Person();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   访问对象属性：使用点号（&quot;.&quot;）操作符来访问对象的属性。</span><br><span class="line">   String name = person.name;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>修改对象属性：使用点号（&quot;.&quot;）操作符来修改对象的属性。
person.age = 25;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   调用对象方法：使用点号（&quot;.&quot;）操作符来调用对象的方法。</span><br><span class="line">   person.sayHello();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>比较对象：可以使用“==”运算符来比较两个对象是否相等，或者使用对象的 equals 方法。
if (person1 == person2) &#123;    
System.out.println(&quot;They are the same person.&quot;);
&#125;
if (person1.equals(person2)) 
&#123;    
System.out.println(&quot;They have the same name and age.&quot;);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 销毁对象：虽然Java有自动垃圾回收机制，但如果需要立即销毁一个对象，可以将其引用设置为 null，以便系统回收该对象的内存空间。</span><br><span class="line">   person = null;</span><br><span class="line"></span><br><span class="line">希望这些基本的对象操作能够帮助您更好地理解如何使用对象。</span><br><span class="line"></span><br><span class="line">#### 构造方法的定义和使用</span><br><span class="line"></span><br><span class="line">构造方法是一种特殊类型的方法，它用于在创建对象时初始化对象的属性。当我们使用“new”操作符来创建一个对象时，实际上就是调用了该类的构造方法。</span><br><span class="line"></span><br><span class="line">在Java中，构造方法与类名相同，并且没有返回类型。构造方法可以有参数，也可以没有参数。如果没有定义任何构造方法，则Java会自动提供一个无参构造方法（即默认构造方法）。</span><br><span class="line"></span><br><span class="line">下面是一个简单的Java构造方法的例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public class Person &#123;
 private String name;
 private int age;

 public Person(String name, int age) &#123;
     this.name = name;
     this.age = age;
 &#125;
</code></pre>
</li>
</ol>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中，Person 类有一个带有两个参数的构造方法，用于初始化对象的属性。当我们创建一个 Person 对象时，需要提供 name 和 age 两个参数。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Person person1 &#x3D; new Person(“Alice”, 25);<br>Person person2 &#x3D; new Person(“Bob”, 30);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在以上代码中，我们分别创建了 person1 和 person2 两个 Person 对象，并分别传递了不同的参数。这些参数被用于初始化相应对象的属性值。</span><br><span class="line"></span><br><span class="line">需要注意的是，构造方法的名称必须与类名相同，而且不能使用返回类型。构造方法可以重载，即在同一个类中可以定义多个具有不同参数的构造方法，以便满足不同的需求。</span><br><span class="line"></span><br><span class="line">希望这个例子能够帮助您了解如何定义和使用 Java 构造方法。</span><br><span class="line"></span><br><span class="line">#### this关键字使用</span><br><span class="line"></span><br><span class="line">在Java中，this关键字用于指代当前对象。可以使用this关键字访问当前对象的属性、方法或者构造函数。this关键字经常被用于以下情况：</span><br><span class="line"></span><br><span class="line">1. 引用当前对象的成员变量</span><br><span class="line"></span><br><span class="line">在类的实例方法中，可以使用this关键字来引用当前对象的成员变量。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Person {<br>    private String name;</p>
<pre><code>public void setName(String name) &#123;
    this.name = name;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，使用了this关键字来引用当前对象的name属性。</span><br><span class="line"></span><br><span class="line">2. 调用当前对象的其他方法</span><br><span class="line"></span><br><span class="line">在类的某个实例方法中，可以使用this关键字来调用该对象的其他方法。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Person {<br>    public void sayHello() {<br>        System.out.println(“Hello”);<br>    }</p>
<pre><code>public void sayHi() &#123;
    this.sayHello(); // 调用当前对象的sayHello方法
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，在sayHi方法中使用了this关键字来调用当前对象的sayHello方法。</span><br><span class="line"></span><br><span class="line">3. 在构造函数中调用其他构造函数</span><br><span class="line"></span><br><span class="line">在一个类的构造函数中，可以使用this关键字来调用该类的其他构造函数。这种方式称为构造函数的重载。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Person {<br>    private String name;<br>    private int age;</p>
<pre><code>public Person() &#123;
    this(&quot;&quot;, 0); // 调用另一个构造函数
&#125;

public Person(String name, int age) &#123;
    this.name = name;
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，定义了两个构造函数。第一个构造函数不带参数，当创建Person对象时会自动调用该构造函数。在该构造函数中使用了this关键字来调用另一个构造函数。</span><br><span class="line"></span><br><span class="line">#### static关键字使用</span><br><span class="line"></span><br><span class="line">在Java中，static关键字用于定义静态变量、静态方法和静态代码块。被static修饰的成员属于类而非实例化对象，可以通过类名直接访问，不需要先创建对象。</span><br><span class="line"></span><br><span class="line">1. 静态变量</span><br><span class="line"></span><br><span class="line">静态变量是类级别的变量，被该类的所有对象所共享，通常用于记录某个类的全局状态。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Person {<br>    public static int count;</p>
<pre><code>public Person() &#123;
    count++;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个静态变量count，它的初始值为0。每当创建Person对象时，会自动调用构造函数，并将count加1。</span><br><span class="line"></span><br><span class="line">2. 静态方法</span><br><span class="line"></span><br><span class="line">静态方法也是类级别的方法，可以直接通过类名来调用，不需要先创建实例化对象。静态方法不能访问非静态成员，因为非静态成员的存在依赖于具体的对象。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class MathUtil {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个静态方法add，用于计算两个整数的和。该方法可以直接通过类名来调用，例如MathUtil.add(1, 2)。</span><br><span class="line"></span><br><span class="line">3. 静态代码块</span><br><span class="line"></span><br><span class="line">静态代码块是在类加载时执行的一段代码块，用于初始化静态变量或其他操作。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class MyClass {<br>    private static int count;<br>    static {<br>        count &#x3D; 0;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个静态变量count和一个静态代码块，用于将count的初始值设为0。</span><br><span class="line"></span><br><span class="line">#### 成员变量和局部变量的区别</span><br><span class="line"></span><br><span class="line">成员变量和局部变量是Java中两种不同的变量类型，它们有以下区别：</span><br><span class="line"></span><br><span class="line">1. 定义位置</span><br><span class="line"></span><br><span class="line">成员变量定义在类中，而局部变量定义在代码块、方法或构造函数中。</span><br><span class="line"></span><br><span class="line">2. 生命周期</span><br><span class="line"></span><br><span class="line">成员变量的生命周期与对象相同，即只有在创建对象时才会被初始化，并且在对象被销毁时才会被销毁。而局部变量的生命周期仅限于所在的代码块、方法或构造函数的执行过程中。</span><br><span class="line"></span><br><span class="line">3. 访问权限</span><br><span class="line"></span><br><span class="line">成员变量可以被类中的其他方法和对象访问，而局部变量只能在其所在的代码块、方法或构造函数中访问。</span><br><span class="line"></span><br><span class="line">4. 初始化</span><br><span class="line"></span><br><span class="line">成员变量可以自动初始化，如果没有显式地为其赋初始值，则会被赋予默认值（如int类型的默认值为0）。而局部变量必须显式地进行初始化，否则编译器会提示错误。</span><br><span class="line"></span><br><span class="line">5. 存储方式</span><br><span class="line"></span><br><span class="line">成员变量存储在堆内存中的对象中，而局部变量存储在栈内存中。</span><br><span class="line"></span><br><span class="line">总之，成员变量和局部变量在定义位置、生命周期、访问权限、初始化和存储方式等方面都存在一些差异，需要根据具体需求选用合适的变量类型。</span><br><span class="line"></span><br><span class="line">### 面向对象的特性</span><br><span class="line"></span><br><span class="line">#### 封装的概念</span><br><span class="line"></span><br><span class="line">封装是面向对象编程中的一个重要概念，指的是将一个对象的属性和行为都隐藏在对象内部，对外只提供必要的接口，从而保证数据的安全性和代码的稳定性。</span><br><span class="line"></span><br><span class="line">封装包括两个方面：访问控制和方法暴露。访问控制指的是控制对象属性的访问权限，可以使用private、protected、public等关键字进行修饰，使得只有需要访问该属性的方法才能够访问它，其他方法或类无法访问。方法暴露则指的是设计良好的公共方法，通过这些公共方法来访问对象的属性和行为，而不是直接访问属性或调用对象的方法。</span><br><span class="line"></span><br><span class="line">封装的好处：</span><br><span class="line"></span><br><span class="line">1. 提高安全性：封装可以隐藏数据的实现细节，防止外部破坏或者误操作导致数据错误或程序故障。</span><br><span class="line"></span><br><span class="line">2. 简化编程：封装可以简化编程，封装对象的功能，减少代码复杂度，降低了编程的难度。</span><br><span class="line"></span><br><span class="line">3. 提高重用性：封装使得实现细节不可见，对外只提供接口，可以降低代码之间的耦合度，提高代码的重用性。</span><br><span class="line"></span><br><span class="line">4. 方便修改和维护：封装可以将变化隔离，使得修改某一部分的实现不影响其他部分，利于程序的维护。</span><br><span class="line"></span><br><span class="line">总之，封装是面向对象编程中很重要的概念，能够提高代码的质量和可维护性，使得程序更加健壮和可靠</span><br><span class="line"></span><br><span class="line">#### 继承的概念</span><br><span class="line"></span><br><span class="line">继承是面向对象编程中的一个重要概念，指的是基于已有类创建新类的过程。子类（派生类）可以继承父类（基类、超类）的属性和方法，同时还可以在此基础上添加新的属性和方法。</span><br><span class="line"></span><br><span class="line">继承是一种代码复用的机制，通过继承可以避免重复编写代码，提高了代码的可维护性和重用性。同时，继承也是实现多态的基础，在继承关系中，子类可以替换掉父类，从而产生不同的行为。</span><br><span class="line"></span><br><span class="line">在Java中，使用extends关键字来实现继承，例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Person {<br>    private String name;<br>    private int age;</p>
<pre><code>// 构造函数
public Person(String name, int age) &#123;
    this.name = name;
    this.age = age;
&#125;

// getter和setter方法
public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public int getAge() &#123;
    return age;
&#125;

public void setAge(int age) &#123;
    this.age = age;
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Student类继承自Person类<br>public class Student extends Person {<br>    private String school;</p>
<pre><code>// Student类的构造函数
public Student(String name, int age, String school) &#123;
    super(name, age); // 调用父类的构造函数
    this.school = school;
&#125;

// 新增的getter和setter方法
public String getSchool() &#123;
    return school;
&#125;

public void setSchool(String school) &#123;
    this.school = school;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个Person类和一个Student类，Student类继承自Person类。在其中，Student类除了继承了Person类的所有属性和方法之外，还新增了一个school属性和相应的getter/setter方法。</span><br><span class="line"></span><br><span class="line">总之，继承是面向对象编程中很</span><br><span class="line"></span><br><span class="line">重要的概念，它可以帮助我们避免重复编写代码，提高代码的可维护性和重用性。在使用继承时，需要注意以下几点：</span><br><span class="line"></span><br><span class="line">1. 父类的属性和方法都是默认继承的，但是如果父类中有private属性或方法，则子类无法访问。</span><br><span class="line"></span><br><span class="line">2. 子类可以覆盖父类的方法，即在子类中重新定义与父类同名的方法，并改变其实现方式。如果子类没有覆盖父类的方法，则调用该方法时会优先调用父类的实现。</span><br><span class="line"></span><br><span class="line">3. 子类可以新增属性和方法，并且可以在父类的基础上进行拓展。但是，子类新增的属性和方法不能被父类所使用。</span><br><span class="line"></span><br><span class="line">4. 在Java中，一个子类只能继承一个父类，但是一个类可以被多个子类继承，形成多层继承关系。</span><br><span class="line"></span><br><span class="line">5. 可以使用super关键字来调用父类的构造函数、属性和方法。</span><br><span class="line"></span><br><span class="line">总之，继承是面向对象编程中很重要的概念，通过继承可以实现代码复用、拓展功能等目的，同时需要注意继承的规范和合理性。</span><br><span class="line"></span><br><span class="line">#### 多态的概念</span><br><span class="line"></span><br><span class="line">多态是面向对象编程中的一个重要概念，指的是同一种行为或操作，对不同的对象有不同的解释或实现方式。简单来说，多态就是同一个接口，不同的实现。</span><br><span class="line"></span><br><span class="line">在Java中，多态性通过继承和接口实现。当子类继承父类或者实现了某个接口时，可以使用父类或者接口的引用来引用子类对象，从而实现多态性。</span><br><span class="line"></span><br><span class="line">例如，定义了一个动物类Animal和两个子类Dog和Cat：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Animal {<br>    public void makeSound() {<br>        System.out.println(“动物发出声音”);<br>    }<br>}</p>
<p>public class Dog extends Animal {<br>    @Override<br>    public void makeSound() {<br>        System.out.println(“狗吠叫”);<br>    }<br>}</p>
<p>public class Cat extends Animal {<br>    @Override<br>    public void makeSound() {<br>        System.out.println(“猫喵喵叫”);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，所有的动物都可以发出声音，但是不同的动物有不同的叫声。这里使用方法重写（Override）实现了多态性。</span><br><span class="line"></span><br><span class="line">然后定义了一个测试类Test：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Test {<br>    public static void main(String[] args) {<br>        Animal animal1 &#x3D; new Dog();<br>        Animal animal2 &#x3D; new Cat();</p>
<pre><code>    animal1.makeSound(); // 输出：狗吠叫
    animal2.makeSound(); // 输出：猫喵喵叫
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了两个Animal类型的引用变量animal1和animal2，并分别引用了Dog和Cat对象。调用它们的makeSound方法时，会分别输出狗吠叫和猫喵喵叫，这就是多态性的体现。</span><br><span class="line"></span><br><span class="line">总之，多态是面向对象编程中很重要的概念，它可以提高代码的灵活性、可维护性和重用性。通过多态，我们可以以最小的代价完成代码的拓展和修改，同时也更容易实现代码的复用。在使用多态时需要注意以下几点：</span><br><span class="line"></span><br><span class="line">1. 多态是基于继承和重写实现的，子类必须重写父类的方法。</span><br><span class="line"></span><br><span class="line">2. 多态时，引用变量类型应该为父类或者接口类型，而不是具体的子类类型。</span><br><span class="line"></span><br><span class="line">3. 在运行时，由JVM动态地确定调用的方法，这就要求被调用的方法必须存在于对象的实际类型中。</span><br><span class="line"></span><br><span class="line">总之，多态是面向对象编程中很重要的概念，它可以提高代码的灵活性、可维护性和重用性，同时需要注意多态的规范和合理性。</span><br><span class="line"></span><br><span class="line">#### final关键字的使用</span><br><span class="line"></span><br><span class="line"> 在Java中，final是一个修饰符，可以用于修饰变量、方法和类。下面分别介绍final关键字的使用：</span><br><span class="line"></span><br><span class="line">1. final变量</span><br><span class="line"></span><br><span class="line">final变量是一种常量，即其值不能被修改。如果在声明时没有进行初始化，则必须在构造函数中对其赋值。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class MyClass {<br>    private final int MAX_VALUE &#x3D; 100;</p>
<pre><code>public MyClass() &#123;
    // 此处可以对MAX_VALUE重新赋值，但是只能赋值一次
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，定义了一个final变量MAX_VALUE，它的值为100，无法被修改。</span><br><span class="line"></span><br><span class="line">2. final方法</span><br><span class="line"></span><br><span class="line">final方法是一种不能被重写的方法，即该方法在子类中不能被重写或覆盖。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Person {<br>    public final void sayHello() {<br>        System.out.println(“你好！”);<br>    }<br>}</p>
<p>public class Student extends Person {<br>    &#x2F;&#x2F; 无法重写Person类的sayHello方法<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，Person类的sayHello方法被定义为final方法，在Student类中无法进行重写。</span><br><span class="line"></span><br><span class="line">3. final类</span><br><span class="line"></span><br><span class="line">final类是一种不能被继承的类，即该类不能有子类。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public final class MyFinalClass {<br>    &#x2F;&#x2F; 类的内容<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的例子中，MyFinalClass类被定义为final类，无法被其他类所继承。</span><br><span class="line"></span><br><span class="line">总之，final关键字可以用于修饰变量、方法和类，分别表示常量、不能被重写或覆盖、不能被继承等含义。使用final关键字可以提高代码的安全性和稳定性，防止意外的修改或错误。</span><br><span class="line"></span><br><span class="line">#### Lambda表示式的使用</span><br><span class="line"></span><br><span class="line">Lambda表达式是Java 8引入的新特性，提供了一种更加简洁、高效的方式来编写代码。Lambda表达式可以看作是一种匿名方法，它没有名称、返回类型和修饰符等属性，但是可以被赋值给一个变量，也可以作为参数传递给方法。</span><br><span class="line"></span><br><span class="line">下面是Lambda表达式的基本语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(parameter1, parameter2, …) -&gt; {<br>    &#x2F;&#x2F; Lambda表达式的代码块<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中，parameter1、parameter2等表示Lambda表达式的参数列表，可以根据实际情况进行定义。箭头“-&gt;”表示Lambda表达式的分隔符，其前面是参数列表，后面是Lambda表达式的执行体，通常是一个代码块。</span><br><span class="line"></span><br><span class="line">Lambda表达式的使用需要满足以下两个条件：</span><br><span class="line"></span><br><span class="line">1. 函数接口：Lambda表达式只能作用于函数接口（Functional Interface），即只有一个抽象方法的接口。例如，Java中的Runnable和Comparator接口就是函数接口。</span><br><span class="line"></span><br><span class="line">2. 上下文推导：Lambda表达式的参数类型和返回类型可以由上下文自动推导出来，不需要显式地指定。</span><br><span class="line"></span><br><span class="line">下面是Lambda表达式的几个示例：</span><br><span class="line"></span><br><span class="line">1. 使用Lambda表达式实现Runnable接口：</span><br><span class="line">2. ```</span><br><span class="line">   Runnable r = () -&gt; &#123;</span><br><span class="line">       System.out.println(&quot;Hello, Lambda!&quot;);</span><br><span class="line">   &#125;;</span><br><span class="line">   Thread t = new Thread(r);</span><br><span class="line">   t.start();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，使用Lambda表达式定义了一个Runnable对象r，并在其执行体中输出了一条信息。然后将该对象赋值给Thread类的构造方法，创建一个线程并启动。</p>
<ol start="2">
<li><p>使用Lambda表达式实现Comparator接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);</span><br><span class="line">Collections.sort(list, (first, second) -&gt; first.length() - second.length());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在上面的例子中，使用Lambda表达式实现了Comparator接口的compare方法，根据字符串长度进行排序。使用Collections类的sort方法对字符串列表进行排序，并输出结果。</p>
<ol start="3">
<li>使用Lambda表达式作为参数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void process(Runnable r) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line">process(() -&gt; System.out.println(&quot;Hello, Lambda!&quot;));</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个process方法，该方法接收一个Runnable对象作为参数，并执行其run方法。然后使用Lambda表达式作为参数，输出一条信息。</p>
<p>总之，Lambda表达式是Java 8引入的新特性，可以提高代码的简洁度和可读性，适用于函数接口的简单实现、匿名内部类的替代等场景。在使用Lambda表达式时需要注意上下文推导和函数接口的限制。</p>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="抽象类和接口的使用"><a href="#抽象类和接口的使用" class="headerlink" title="抽象类和接口的使用"></a>抽象类和接口的使用</h4><p>抽象类和接口是Java中两种重要的概念，它们都可以用于实现多态性和代码复用。</p>
<ol>
<li>抽象类</li>
</ol>
<p>抽象类是一种不能被实例化的类，其主要作用是为子类提供一个模板或者共同的行为。抽象类通过abstract关键字进行定义，其中定义了至少一个抽象方法，即没有实现体的方法。子类必须实现这些抽象方法才能被实例化。</p>
<p>以下是抽象类的一个简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">    public abstract void move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;狗在吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;狗在奔跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个抽象类Animal，其中包含了两个抽象方法eat和move，表示动物的基本行为。然后定义了一个Dog类，并继承自Animal类，实现了eat和move方法。</p>
<ol start="2">
<li>接口</li>
</ol>
<p>接口是一种定义行为的规范，它定义了一组方法（包括默认方法和静态方法），但是没有实现体。接口通过interface关键字进行定义，可以被多个类实现。一个类可以实现多个接口，从而获得不同的行为。</p>
<p>以下是接口的一个简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    double getArea();</span><br><span class="line">    double getPerimeter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    private double radius;</span><br><span class="line"></span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double getArea() &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double getPerimeter() &#123;</span><br><span class="line">        return 2 * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个Shape接口，其中定义了两个方法getArea和getPerimeter，表示形状的基本属性。然后定义了一个Circle类，并实现了Shape接口，实现了getArea和getPerimeter方法。</p>
<p>总之，抽象类和接口都是Java中重要的概念，它们可以用于实现多态性和代码复用。使用抽象类和接口需要注意以下几点：</p>
<ol>
<li><p>抽象类和接口都不能被实例化，只能被子类或者实现类继承或实现。</p>
</li>
<li><p>抽象类可以包含非抽象方法，而接口只能包含抽象方法、默认方法和静态方法。</p>
</li>
<li><p>子类必须实现抽象类中的所有抽象方法，否则子类也必须被声明为抽象类。实现类必须实现接口中的所有方法。</p>
</li>
<li><p>一个类可以继承一个抽象类并实现多个接口。</p>
</li>
<li><p>接口中的方法默认是public和abstract修饰的，而抽象类中的方法可以有不同的访问控制符和非抽象方法。</p>
</li>
</ol>
<p>总之，抽象类和接口都是面向对象编程中很重要的概念，它们可以帮助我们实现多态和代码复用等目的，同时需要注意抽象类和接口的规范和合理性。</p>
<h4 id="Java中的内部类"><a href="#Java中的内部类" class="headerlink" title="Java中的内部类"></a>Java中的内部类</h4><p>1.成员内部类是Java中的一种内部类，它定义在外部类的内部，并与外部类的成员变量和方法具有相同的访问权限。一个成员内部类可以使用public、protected、private或默认修饰符。</p>
<p>成员内部类可以访问外部类的私有成员和方法，而外部类也可以通过创建成员内部类对象来访问内部类的成员。成员内部类不能定义static变量或方法，但可以包含静态final常量。</p>
<p>要创建成员内部类对象，必须先创建外部类对象，然后使用外部类对象来创建内部类对象。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private int outerVar;</span><br><span class="line"></span><br><span class="line">    public class InnerClass &#123;</span><br><span class="line">        private int innerVar;</span><br><span class="line"></span><br><span class="line">        public InnerClass(int var) &#123;</span><br><span class="line">            this.innerVar = var;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;Outer variable: &quot; + outerVar);</span><br><span class="line">            System.out.println(&quot;Inner variable: &quot; + this.innerVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        InnerClass inner = new InnerClass(10);</span><br><span class="line">        inner.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个OuterClass外部类和一个InnerClass成员内部类。在test方法中，我们创建了一个InnerClass对象inner，并调用了它的print方法来打印outerVar和innerVar。注意，在InnerClass类中，我们可以直接访问outerVar变量。</p>
<p>2.静态内部类是Java中的一种内部类，它定义在外部类的内部，但必须使用static关键字修饰。静态内部类只能访问外部类的静态成员和方法，不能访问非静态成员。</p>
<p>静态内部类可以包含静态变量、静态方法和非静态成员变量，但不能包含非静态方法。静态内部类可以使用public、protected、private或默认修饰符。</p>
<p>要创建静态内部类对象，不需要先创建外部类对象。可以直接使用”外部类名.内部类名”的形式来创建静态内部类对象，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private static int outerVar;</span><br><span class="line"></span><br><span class="line">    public static class InnerClass &#123;</span><br><span class="line">        private int innerVar;</span><br><span class="line"></span><br><span class="line">        public InnerClass(int var) &#123;</span><br><span class="line">            this.innerVar = var;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;Outer variable: &quot; + outerVar);</span><br><span class="line">            System.out.println(&quot;Inner variable: &quot; + this.innerVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建静态内部类对象</span><br><span class="line">OuterClass.InnerClass inner = new OuterClass.InnerClass(10);</span><br><span class="line">inner.print();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个OuterClass外部类和一个InnerClass静态内部类。注意，在InnerClass类中，我们只能访问outerVar静态变量。我们可以直接使用”OuterClass.InnerClass”的形式来创建静态内部类对象，而不需要先创建OuterClass对象。</p>
<p>3.局部内部类是Java中的一种内部类，它定义在方法或作用域块内部的类，只在定义它的方法或代码块内可见。局部内部类不能使用public、protected、private或static修饰符。</p>
<p>局部内部类可以访问外部类和外部方法（或代码块）的局部变量，但这些局部变量必须声明为final类型或者隐式地被final修饰。</p>
<p>要创建局部内部类对象，需要先创建外部类对象，然后通过外部类对象来创建内部类对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        final int outerVar = 10;</span><br><span class="line"></span><br><span class="line">        class InnerClass &#123;</span><br><span class="line">            private int innerVar;</span><br><span class="line"></span><br><span class="line">            public InnerClass(int var) &#123;</span><br><span class="line">                this.innerVar = var;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void print() &#123;</span><br><span class="line">                System.out.println(&quot;Outer variable: &quot; + outerVar);</span><br><span class="line">                System.out.println(&quot;Inner variable: &quot; + this.innerVar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InnerClass inner = new InnerClass(20);</span><br><span class="line">        inner.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个OuterClass外部类和一个InnerClass局部内部类。在test方法中，我们创建了一个InnerClass对象inner，并调用了它的print方法来打印outerVar和innerVar。注意，在InnerClass类中，我们可以直接访问outerVar变量，但必须将它声明为final类型。</p>
<p>4.匿名内部类是Java中的一种内部类，它没有类名，通常用于简化代码。匿名内部类可以直接继承一个父类或实现一个接口。</p>
<p>匿名内部类不能有构造方法，但可以在定义时直接实例化并重写其中的方法。匿名内部类只能使用一次，因为无法对它进行引用，所以通常用于创建临时对象。匿名内部类也可以访问外部类的成员变量和方法。</p>
<p>例如，我们可以通过继承Thread类来创建一个匿名内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们创建了一个Thread类的匿名内部类，并实现了它的run方法。然后我们调用了start方法来启动线程。注意，在匿名内部类中，我们可以直接访问外部类的成员变量和方法。</p>
<h4 id="单例模式（了解）"><a href="#单例模式（了解）" class="headerlink" title="单例模式（了解）"></a>单例模式（了解）</h4><p>单例模式是一种常用的设计模式，它保证一个类只有一个实例，并提供一个全局访问点。</p>
<p>单例模式通常有两种实现方式：</p>
<ol>
<li><p>饿汉式单例模式：在类加载时就创建实例对象，并提供一个公共的静态方法来获取这个唯一的实例。这种方式实现简单，线程安全，但可能会浪费系统资源。</p>
</li>
<li><p>懒汉式单例模式：在第一次使用时才创建实例对象，并提供一个公共的静态方法来获取这个唯一的实例。这种方式可以节省系统资源，但需要考虑线程安全问题。<br>下面是饿汉式单例模式的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在上面的例子中，我们将构造函数设为私有的，然后在类加载时就创建了一个Singleton实例，并提供了一个公共的静态方法getInstance来获取这个唯一的实例。由于instance被定义为final类型，所以它只能被赋值一次，从而保证了单例模式的实现。需要注意的是，在多线程环境下，饿汉式单例模式的实现是线程安全的，因为在类加载时就已经创建了实例对象，不需要考虑线程同步问题。</p>
<p>下面是懒汉式单例模式的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将构造函数设为私有的，然后在getInstance方法中判断是否已经创建了Singleton实例，如果没有则创建一个实例并返回。由于getInstance方法被定义为synchronized类型，所以它能保证在多线程环境下只有一个线程能够进入该方法，从而避免了多个线程同时创建实例的问题。</p>
<p>需要注意的是，在高并发场景下，懒汉式单例模式的性能可能会受到影响。可以考虑使用双重检查锁定（Double-Checked Locking）或静态内部类等方式来优化单例模式的性能</p>
<h4 id="模板设计方法（了解）"><a href="#模板设计方法（了解）" class="headerlink" title="模板设计方法（了解）"></a>模板设计方法（了解）</h4><p>模板方法设计模式（Template Method Design Pattern）是一种基于继承的设计模式，它定义了一个算法框架，把一些步骤的实现留给子类来完成。</p>
<p>模板方法设计模式通常由两部分组成：抽象父类和具体子类。抽象父类提供了一个算法框架，其中包含了若干个抽象方法，这些抽象方法由子类来实现。具体子类继承了抽象父类，并重写其中的抽象方法，从而完成了算法中的具体步骤。</p>
<p>下面是模板方法设计模式的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">    public void templateMethod() &#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        step3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void step1();</span><br><span class="line"></span><br><span class="line">    protected abstract void step2();</span><br><span class="line"></span><br><span class="line">    protected abstract void step3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass extends AbstractClass &#123;</span><br><span class="line">    protected void step1() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: step1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void step2() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: step2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void step3() &#123;</span><br><span class="line">        System.out.println(&quot;ConcreteClass: step3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractClass obj = new ConcreteClass();</span><br><span class="line">        obj.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个抽象类AbstractClass和一个具体子类ConcreteClass。在AbstractClass中，我们提供了一个templateMethod方法作为算法框架，并定义了三个抽象方法step1、step2和step3，这些抽象方法由具体子类来实现。在具体子类ConcreteClass中，我们重写了其中的三个抽象方法，并实现了具体的算法步骤。最后，在Main函数中，我们创建了ConcreteClass对象，并调用了它的templateMethod方法来执行算法。</p>
<p>需要注意的是，在模板方法设计模式中，抽象父类控制算法的流程和逻辑，而具体子类负责实现具体的步骤。这样可以避免在具体子类中重复编写相同的代码，提高了代码的复用性。</p>
<h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><h4 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h4><p>在Java中，异常（Exception）是程序运行时发生的意外情况，如：数组下标越界、空指针引用、文件不存在等。如果不加处理，这些异常可能会导致程序崩溃。</p>
<p>为了更好地处理异常，Java提供了异常处理机制。当程序运行时遇到异常，它会抛出一个异常对象，如果没有对这个异常进行处理，程序就会终止执行。可以使用try-catch语句来捕获并处理异常。try块中放置可能会引发异常的代码，catch块用于处理异常，通常包含错误信息的输出或者异常的修复代码。finally块中放置无论是否发生异常都需要执行的代码。</p>
<p><img src="https://img-blog.csdnimg.cn/548f0ac51a2c413a9032552d8603ea0f.png" alt="548f0ac51a2c413a9032552d8603ea0f"></p>
<p>在Java中，异常分为两种：受检异常（Checked Exception）和非受检异常（Unchecked Exception）。受检异常必须在方法签名中显式地声明，并且必须被捕获或者抛出，否则编译器将会报错。非受检异常通常由程序员编写代码时犯的逻辑错误或者系统环境的问题导致，如NullPointerException、ArrayIndexOutOfBoundsException等，编译器不会强制要求进行处理。</p>
<p>例如，以下是一个简单的异常处理示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int num1 = Integer.parseInt(args[0]);</span><br><span class="line">            int num2 = Integer.parseInt(args[1]);</span><br><span class="line">            int result = num1 / num2;</span><br><span class="line">            System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;End of program&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们尝试将命令行参数转换为整数，并计算它们的商。如果遇到异常，就通过catch块输出错误信息。无论是否发生异常，finally块中的代码都会被执行。</p>
<h4 id="异常的处理机制"><a href="#异常的处理机制" class="headerlink" title="异常的处理机制"></a>异常的处理机制</h4><h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><p>Java中的异常处理机制可以通过 try-catch-finally 语句块来实现。try块用于放置可能会抛出异常的代码，catch块用于捕获并处理抛出的异常，finally块用于放置无论是否发生异常都需要执行的代码。</p>
<p>下面是一个使用try-catch-finally语句块处理异常的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 可能会抛出异常的代码</span><br><span class="line">            int result = divide(10, 0);</span><br><span class="line">            System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            // 捕获并处理异常</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 无论是否异常都会执行的代码</span><br><span class="line">            System.out.println(&quot;End of program&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int divide(int a, int b) &#123;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个divide方法来计算两个整数的商，这个方法可能会抛出ArithmeticException异常（例如，被除数为0）。在main函数中，我们调用divide方法，并通过try-catch-finally语句块来捕获并处理可能抛出的异常。无论是否发生异常，finally块中的代码都会被执行。</p>
<p>需要注意的是，异常分为受检异常（Checked Exception）和非受检异常（Unchecked Exception）。对于受检异常，在方法签名中必须显式地声明，并且必须被捕获或者抛出；对于非受检异常，编译器不会强制要求进行处理。</p>
<p>throws和throw都与Java中的异常处理有关，但用法略有不同。</p>
<h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>throws是用于声明方法可能会抛出哪些异常。在Java中，当一个方法可能会抛出某些受检查异常时，应该在方法声明中使用throws关键字来<strong>声明这些异常</strong>，以便调用者知道需要捕获和处理哪些异常。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething() throws IOException, SQLException &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法声明表示doSomething()方法可能会抛出IOException或SQLException异常，调用者必须在调用该方法时进行异常捕获或继续声明这些异常。</p>
<h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>throw语句用于手动抛出一个异常。在Java中，当程序遇到某些错误或异常情况时，可以使用throw语句抛出相应的异常对象，以提示程序出现了错误。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (age &lt; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Age cannot be negative!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码表示如果年龄小于0，则抛出IllegalArgumentException异常，并附带一个错误信息。</p>
<p>需要注意的是，当使用throw抛出异常时，程序会立即停止执行当前方法，并从当前方法返回，而不会继续执行后面的代码。因此，在实际开发中，应该谨慎使用throw语句，确保只在必要的情况下才抛出异常。</p>
<p>throws和throw是两个在Java中用于异常处理的关键字，它们有以下区别：</p>
<ol>
<li>用法不同</li>
</ol>
<p>throws是用于方法声明中，用于声明该方法可能会抛出哪些受检查异常；而throw是用于方法体中，用于手动抛出一个异常对象。</p>
<ol start="2">
<li>作用不同</li>
</ol>
<p>throws主要用于告知调用者可能会发生的异常情况，以便让调用者进行相应的异常处理；而throw则是在具体的方法实现中，用于手动抛出异常对象，并中断当前方法的执行流程。</p>
<ol start="3">
<li>处理方式不同</li>
</ol>
<p>当方法使用throws声明了某些受检查异常时，调用该方法的代码必须对这些异常进行捕获或继续向上层抛出；而当方法在执行过程中使用throw抛出了某个异常时，程序会立即停止执行当前方法，并从当前方法返回，继续执行上层方法或结束程序运行。</p>
<p>需要注意的是，虽然throws和throw都与Java中的异常处理有关，但它们并不是完全互斥的。实际上，在处理异常时，我们通常会同时使用到它们，例如在一个方法中先使用try-catch语句捕获异常，然后再使用throw将异常抛出到更高层次的调用者，最终由这些调用者统一处理异常。</p>
<h4 id="自定义异常的使用"><a href="#自定义异常的使用" class="headerlink" title="自定义异常的使用"></a>自定义异常的使用</h4><p>在Java中，我们可以通过继承Exception或者RuntimeException类来创建自定义异常。自定义异常适用于需要捕获并处理特定类型的异常情况的场景。</p>
<p>下面是一个自定义异常的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CustomException extends Exception &#123;</span><br><span class="line">    public CustomException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CustomException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们创建了一个CustomException类，它继承自Exception类。通过重写Exception类的构造函数，我们为CustomException类提供了两个构造函数，分别用于设置异常信息和异常原因（可选）。</p>
<p>下面是一个使用自定义异常的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 可能会抛出自定义异常的代码</span><br><span class="line">            int result = divide(10, 0);</span><br><span class="line">            System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">        &#125; catch (CustomException e) &#123;</span><br><span class="line">            // 捕获并处理自定义异常</span><br><span class="line">            System.out.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;End of program&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int divide(int a, int b) throws CustomException &#123;</span><br><span class="line">        if (b == 0) &#123;</span><br><span class="line">            throw new CustomException(&quot;除数不能为0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们通过throw关键字抛出了一个自定义异常CustomException，并在divide方法的声明中使用throws关键字将这个异常向上抛出。在main函数中，我们通过try-catch-finally语句块来捕获并处理可能抛出的CustomException异常。</p>
<p>需要注意的是，在自定义异常时，通常应该定义有意义的异常信息，并考虑继承现有的异常类型，以便更好地利用异常处理机制。</p>
<h3 id="java常用类"><a href="#java常用类" class="headerlink" title="java常用类"></a>java常用类</h3><h4 id="字符串相关类的使用"><a href="#字符串相关类的使用" class="headerlink" title="字符串相关类的使用"></a>字符串相关类的使用</h4><p>在Java中，字符串相关的类有很多，比较常用的包括String、StringBuilder和StringBuffer等。</p>
<ol>
<li>String类</li>
</ol>
<p>String类是Java中用于表示字符串的类，它是不可变的（immutable）类。这意味着一旦创建了一个String对象，就不能更改该对象的值。由于String对象的不可变性，每当对String对象进行修改时，都会创建一个新的String对象，并将修改后的字符串赋值给新的对象。</p>
<p>下面是一些常用的String类方法：</p>
<ul>
<li>length()：返回字符串的长度。</li>
<li>charAt(int index)：返回指定位置的字符。</li>
<li>substring(int beginIndex, int endIndex)：返回从beginIndex开始到endIndex-1结束的子字符串。</li>
<li>equals(Object obj)：判断字符串是否相等。</li>
<li>toUpperCase()：将字符串转换为大写字母。</li>
<li>toLowerCase()：将字符串转换为小写字母。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;Hello&quot;;</span><br><span class="line">String str2 = &quot;World&quot;;</span><br><span class="line">String str3 = str1 + str2; // 拼接字符串</span><br><span class="line">System.out.println(str3); // 输出 HelloWorld</span><br><span class="line">System.out.println(str3.substring(0, 5)); // 输出 Hello</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>StringBuilder类</li>
</ol>
<p>StringBuilder类是Java中用于处理字符串的可变类，它提供了许多修改字符串的方法，如添加、插入、删除、替换等操作。与String类不同，StringBuilder类的对象可以直接进行修改，而不需要创建新的对象。</p>
<p>下面是一些常用的StringBuilder类方法：</p>
<ul>
<li>append(String str)：向字符串末尾添加内容。</li>
<li>insert(int offset, String str)：在指定位置插入内容。</li>
<li>delete(int start, int end)：删除指定范围内的内容。</li>
<li>replace(int start, int end, String str)：替换指定范围内的内容。</li>
<li>reverse()：反转字符串。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = new StringBuilder(&quot;Hello&quot;);</span><br><span class="line">builder.append(&quot;, World!&quot;);</span><br><span class="line">builder.insert(5, &quot;Java &quot;);</span><br><span class="line">builder.delete(1, 4);</span><br><span class="line">builder.replace(6, 11, &quot;GPT&quot;);</span><br><span class="line">builder.reverse();</span><br><span class="line">System.out.println(builder.toString()); // 输出TPG avaj olleH,!</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>StringBuffer类</li>
</ol>
<p>StringBuffer类与StringBuilder类类似，也是可变的字符串类，提供了许多修改字符串的方法。与StringBuilder类不同的是，StringBuffer类是线程安全的，适用于多线程环境下的字符串操作。但是，在单线程环境下，StringBuilder类比StringBuffer类的性能更好。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = new StringBuffer(&quot;Hello&quot;);</span><br><span class="line">buffer.append(&quot;, World!&quot;);</span><br><span class="line">buffer.insert(5, &quot;Java &quot;);</span><br><span class="line">buffer.delete(1, 4);</span><br><span class="line">buffer.replace(6, 11, &quot;GPT&quot;);</span><br><span class="line">buffer.reverse();</span><br><span class="line">System.out.println(buffer.toString()); // 输出TPG avaj olleH,!</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当需要频繁地对字符串进行修改时，应该使用StringBuilder或StringBuffer类，而不是String类。如果字符串不需要修改，那么可以使用String类来代替StringBuilder和StringBuffer，因为String类更加简洁、易读</p>
<h4 id="System类与Runtime类的使用；"><a href="#System类与Runtime类的使用；" class="headerlink" title="System类与Runtime类的使用；"></a>System类与Runtime类的使用；</h4><ol>
<li>System类</li>
</ol>
<p>System类提供了一些有用的类变量和方法，如：</p>
<ul>
<li>out：标准输出流。</li>
<li>err：标准错误流。</li>
<li>currentTimeMillis()：返回当前时间的毫秒数。</li>
<li>getProperty(String key)：获取指定系统属性的值。</li>
<li>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将一个数组中的一部分复制到另一个数组中。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 执行一些操作</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;耗时：&quot; + (end - start) + &quot; 毫秒&quot;);</span><br><span class="line"></span><br><span class="line">String osName = System.getProperty(&quot;os.name&quot;);</span><br><span class="line">System.out.println(&quot;操作系统：&quot; + osName);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Runtime类</li>
</ol>
<p>Runtime类提供了与Java虚拟机运行时环境相关的方法，如：</p>
<ul>
<li>exec(String cmd)：在单独的进程中执行命令。</li>
<li>totalMemory()：JVM总内存量。</li>
<li>freeMemory()：JVM空闲内存量。</li>
<li>maxMemory()：JVM最大可用内存量。</li>
<li>gc()：垃圾回收器。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line">try &#123;</span><br><span class="line">    // 在单独的进程中执行命令</span><br><span class="line">    Process process = runtime.exec(&quot;notepad.exe&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;JVM总内存量：&quot; + runtime.totalMemory());</span><br><span class="line">System.out.println(&quot;JVM空闲内存量：&quot; + runtime.freeMemory());</span><br><span class="line">System.out.println(&quot;JVM最大可用内存量：&quot; + runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">runtime.gc(); // 手动触发垃圾回收器</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用exec方法时，需要注意处理异常和流，以避免出现死锁或者内存泄漏等问题；在使用Runtime类的方法时，应该小心谨慎地管理内存，避免出现OutOfMemoryError等问题。</p>
<h4 id="Math类与Random类的使用"><a href="#Math类与Random类的使用" class="headerlink" title="Math类与Random类的使用"></a>Math类与Random类的使用</h4><p>在Java中，Math类和Random类都是Java标准库提供的数学相关类。它们可以用来执行一些数学计算、生成随机数等。</p>
<ol>
<li>Math类</li>
</ol>
<p>Math类提供了许多数学相关的静态方法，如：</p>
<ul>
<li>abs(int a)：返回一个整数的绝对值。</li>
<li>ceil(double a)：返回大于或等于指定 double 值的最小 double 值，等于一个整数。</li>
<li>floor(double a)：返回小于或等于指定 double 值的最大 double 值，等于一个整数。</li>
<li>max(int a, int b)：返回两个整数中较大的那个。</li>
<li>min(int a, int b)：返回两个整数中较小的那个。</li>
<li>pow(double a, double b)：返回第一个参数的第二个参数次幂的值。</li>
<li>random()：返回一个介于0.0和1.0之间的随机数。</li>
<li>round(float a)：将一个float值舍入为最接近的整数。</li>
<li>sqrt(double a)：返回平方根。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = -10;</span><br><span class="line">double b = 3.14;</span><br><span class="line">System.out.println(Math.abs(a)); // 输出 10</span><br><span class="line">System.out.println(Math.ceil(b)); // 输出 4.0</span><br><span class="line">System.out.println(Math.floor(b)); // 输出 3.0</span><br><span class="line">System.out.println(Math.max(2, 5)); // 输出 5</span><br><span class="line">System.out.println(Math.min(2, 5)); // 输出 2</span><br><span class="line">System.out.println(Math.pow(2, 3)); // 输出 8.0</span><br><span class="line">System.out.println(Math.random()); // 输出介于0.0和1.0之间的随机数</span><br><span class="line">System.out.println(Math.round(3.6f)); // 输出 4</span><br><span class="line">System.out.println(Math.sqrt(9)); // 输出 3.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Random类</li>
</ol>
<p>Random类提供了生成伪随机数的方法，包括nextInt、nextLong、nextDouble等方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">System.out.println(random.nextInt(100)); // 输出小于100的随机整数</span><br><span class="line">System.out.println(random.nextDouble()); // 输出小于1.0的随机浮点数</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在生成随机数时，应该使用真正的随机数生成器，而不是伪随机数生成器，以避免出现安全问题。例如，在密码生成、加密解密等场景下，应该使用更加安全的随机数生成器。</p>
<h4 id="日期类的使用"><a href="#日期类的使用" class="headerlink" title="日期类的使用"></a>日期类的使用</h4><p>在Java中，日期相关的类主要包括Date、Calendar和SimpleDateFormat等。其中，Date类是Java早期提供的日期类，已经过时，建议使用Calendar或者LocalDate代替。</p>
<ol>
<li>LocalDate类</li>
</ol>
<p>LocalDate类是Java 8之后提供的日期类，它提供了许多便捷的方法来操作日期，如：</p>
<ul>
<li>now()：获取当前日期。</li>
<li>of(int year, int month, int dayOfMonth)：创建指定年月日的日期。</li>
<li>plusDays(long daysToAdd)：增加几天。</li>
<li>minusDays(long daysToSubtract)：减少几天。</li>
<li>getYear()：获取年份。</li>
<li>getMonth()：获取月份。</li>
<li>getDayOfMonth()：获取日份。</li>
<li>format(DateTimeFormatter formatter)：将日期格式化为指定的字符串。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">System.out.println(date); // 输出当前日期</span><br><span class="line">date = LocalDate.of(2023, 3, 12);</span><br><span class="line">System.out.println(date); // 输出指定日期</span><br><span class="line">date = date.plusDays(1);</span><br><span class="line">System.out.println(date); // 输出增加一天后的日期</span><br><span class="line">date = date.minusDays(1);</span><br><span class="line">System.out.println(date); // 输出减少一天后的日期</span><br><span class="line">System.out.println(date.getYear()); // 输出年份</span><br><span class="line">System.out.println(date.getMonth()); // 输出月份</span><br><span class="line">System.out.println(date.getDayOfMonth()); // 输出日份</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">String strDate = date.format(formatter);</span><br><span class="line">System.out.println(strDate); // 输出格式化后的日期字符串</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>SimpleDateFormat类</li>
</ol>
<p>SimpleDateFormat类是Java提供的日期格式化工具类，可以根据指定的格式将日期转换为字符串或者将字符串转换为日期。其中，常用的格式符有：</p>
<ul>
<li>y：年份（4位数）。</li>
<li>M：月份（1~12）。</li>
<li>d：日期（1~31）。</li>
<li>H：小时（0~23）。</li>
<li>m：分钟（0~59）。</li>
<li>s：秒钟（0~59）。</li>
<li>S：毫秒（0~999）。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">String strDate = sdf.format(date);</span><br><span class="line">System.out.println(strDate); // 输出格式化后的日期字符串</span><br><span class="line"></span><br><span class="line">strDate = &quot;2023-03-12&quot;;</span><br><span class="line">sdf.applyPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">date = sdf.parse(strDate);</span><br><span class="line">System.out.println(date); // 输出解析后的日期对象</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在处理日期时，应该尽可能使用新的日期类（如LocalDate）代替旧的日期类（如Date），以避免出现线程安全问题和易错问题。同时，在进行日期格式化时，应该使用正确的格式符，以避免出现异常。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><h4 id="List、Map、Set集合的使用"><a href="#List、Map、Set集合的使用" class="headerlink" title="List、Map、Set集合的使用"></a>List、Map、Set集合的使用</h4><ol>
<li>List类</li>
</ol>
<p>List是一种有序的集合，可以存储重复的元素。常用的List实现类有ArrayList和LinkedList。其中，ArrayList是基于动态数组实现的，支持随机访问，而LinkedList是基于双向链表实现的，支持高效的插入和删除操作。</p>
<p>用的List实现类有：</p>
<ul>
<li><p>ArrayList：基于数组实现的动态数组，支持快速随机访问和插入&#x2F;删除元素等操作，但在插入&#x2F;删除元素时需要移动后面的所有元素，因此效率较低。</p>
</li>
<li><p>LinkedList：基于链表实现的双向链表，支持快速在任意位置进行插入&#x2F;删除操作，但只能顺序访问元素，且每个节点需要额外存储指向前驱节点和后继节点的引用，因此比ArrayList更占用内存空间。</p>
</li>
<li><p>Vector：与ArrayList类似，也是基于数组实现的动态数组，但线程安全，具有同步锁，适合在多线程环境下使用，但效率较低。<br><img src="file:///C:/Users/26927/Pictures/Typedown/6dda1686-b38e-4a88-b7b9-cdf767405545.png" alt="6dda1686-b38e-4a88-b7b9-cdf767405545"></p>
</li>
</ul>
<p>除了上述实现类之外，还有一些其他的List实现类，如Stack、CopyOnWriteArrayList等，都继承自List接口，并提供了特定的功能。</p>
<p>List接口提供了很多常用的方法，例如：add()、remove()、get()、set()、indexOf()、size()等，它们都遵循了Java集合框架的规范。在使用List时，建议先根据具体需求选择合适的实现类，再根据需要选择合适的方法进行操作。</p>
<p><img src="file:///C:/Users/26927/Pictures/Typedown/519ae451-a421-4cb6-a575-ff46187487c4.png" alt="519ae451-a421-4cb6-a575-ff46187487c4"></p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line">System.out.println(list); // 输出 [apple, banana, orange]</span><br><span class="line"></span><br><span class="line">list.remove(1);</span><br><span class="line">System.out.println(list); // 输出 [apple, orange]</span><br><span class="line"></span><br><span class="line">System.out.println(list.get(1)); // 输出 orange</span><br></pre></td></tr></table></figure>

<p>2.Set类</p>
<p>Set是一种无序的集合，不允许重复元素。常用的Set实现类有HashSet和TreeSet。其中，HashSet是基于哈希表实现的，支持快速查找，而TreeSet是基于红黑树实现的，支持按元素排序和范围查询。</p>
<p>常用的Set实现类有：</p>
<ul>
<li>HashSet：基于哈希表实现的Set，支持快速的插入和查找操作，但不保证元素的顺序。<img src="file:///C:/Users/26927/Pictures/Typedown/2be7d61a-f513-4e5d-aa4b-ccf3c16e1cfd.png?msec=1681038201688" alt="2be7d61af5134e5daa4bccf3c16e1cfd"></li>
<li>TreeSet：基于红黑树实现的有序Set，支持按照元素进行排序，但插入和查询操作的效率较低。</li>
<li>LinkedHashSet：基于哈希表和双向链表实现的Set，可以按照插入顺序或者访问顺序进行迭代，其性能介于HashSet和TreeSet之间。</li>
</ul>
<p>除了上述实现类之外，还有一些其他的Set实现类，如EnumSet、CopyOnWriteArraySet等，它们都继承自Set接口，并提供了特定的功能。</p>
<p>Set接口提供了很多常用的方法，例如：add()、remove()、contains()、size()、isEmpty()等，它们都遵循了Java集合框架的规范。在使用Set时，建议先根据具体需求选择合适的实现类，再根据需要选择合适的方法进行操作。</p>
<p>示例代码：<br>    Set<String> set &#x3D; new HashSet&lt;&gt;();<br>    set.add(“apple”);<br>    set.add(“banana”);<br>    set.add(“orange”);<br>    System.out.println(set); &#x2F;&#x2F; 输出 [orange, apple, banana]<br>    set.remove(“banana”);<br>    System.out.println(set); &#x2F;&#x2F; 输出 [orange, apple]<br>    System.out.println(set.contains(“apple”)); &#x2F;&#x2F; 输出 true</p>
<p>需要注意的是，在使用集合类时，应该根据具体需求选择合适的实现类。同时，对于需要保证线程安全的场景，应该考虑使用线程安全的集合类（如ConcurrentHashMap和CopyOnWriteArrayList等）。</p>
<p>3.Map类</p>
<p>Map是一种键值对（key-value）映射的集合，每个键只能对应一个值。常用的Map实现类有HashMap和TreeMap。其中，HashMap是基于哈希表实现的，支持快速查找，而TreeMap是基于红黑树实现的，支持按键排序。</p>
<p>常用的Map实现类有：</p>
<ul>
<li>HashMap：基于哈希表实现的Map，支持快速的插入和查找操作，但不保证元素的顺序，且在处理冲突时需要进行重新哈希。</li>
<li>TreeMap：基于红黑树实现的有序Map，支持按照键进行排序，但插入和查询操作的效率较低。</li>
<li>LinkedHashMap：基于哈希表和双向链表实现的Map，可以按照插入顺序或者访问顺序进行迭代，其性能介于HashMap和TreeMap之间。</li>
</ul>
<p>除了上述实现类之外，还有一些其他的Map实现类，如HashTable、ConcurrentHashMap等，它们都继承自Map接口，并提供了特定的功能。</p>
<p>Map接口提供了很多常用的方法，例如：put()、get()、remove()、containsKey()、containsValue()、keySet()、values()等，它们都遵循了Java集合框架的规范。在使用Map时，建议先根据具体需求选择合适的实现类，再根据需要选择合适的方法进行操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;apple&quot;, 2);</span><br><span class="line">map.put(&quot;banana&quot;, 3);</span><br><span class="line">map.put(&quot;orange&quot;, 4);</span><br><span class="line">System.out.println(map); // 输出 &#123;orange=4, apple=2, banana=3&#125;</span><br><span class="line"></span><br><span class="line">map.remove(&quot;banana&quot;);</span><br><span class="line">System.out.println(map); // 输出 &#123;orange=4, apple=2&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(map.get(&quot;apple&quot;)); // 输出 2</span><br></pre></td></tr></table></figure>

<h4 id="集合遍历的方法"><a href="#集合遍历的方法" class="headerlink" title="集合遍历的方法"></a>集合遍历的方法</h4><p>在Java中，集合遍历有多种方法，下面介绍几种常用的方式。</p>
<ol>
<li>for循环</li>
</ol>
<p>通过for循环可以遍历List、数组等有序集合。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>增强型for循环</li>
</ol>
<p>增强型for循环（也称为foreach）是一种简化版的for循环，用于遍历数组或Iterable类型的集合。它可以方便地遍历集合元素，但无法获取当前元素的索引。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">for (String fruit : list) &#123;</span><br><span class="line">    System.out.println(fruit);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>迭代器</li>
</ol>
<p>迭代器可以通过next()方法逐个获取集合中的元素，并且支持删除操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String fruit = iterator.next();</span><br><span class="line">    System.out.println(fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>lambda表达式</li>
</ol>
<p>lambda表达式可以使用Stream API来遍历集合。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;apple&quot;);</span><br><span class="line">list.add(&quot;banana&quot;);</span><br><span class="line">list.add(&quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">list.stream().forEach(fruit -&gt; System.out.println(fruit));</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在遍历集合时，应该根据具体需求选择合适的方式。同时，对于需要保证线程安全的集合类（如ConcurrentHashMap和CopyOnWriteArrayList等），应该采用线程安全的方式进行遍历。</p>
<h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><p>泛型是Java中的一个重要特性，它可以将数据类型作为参数传递给类、接口和方法。使用泛型可以提高代码的可重用性和安全性。</p>
<ol>
<li>泛型类</li>
</ol>
<p>定义一个泛型类时，需要在类名后面加上尖括号&lt;&gt;，并在其中指定泛型的类型。在类的属性、方法和构造方法中，可以使用泛型类型作为变量类型。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public Box(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>泛型接口</li>
</ol>
<p>定义一个泛型接口时，需要在接口名后面加上尖括号&lt;&gt;，并在其中指定泛型的类型。在接口的方法中，可以使用泛型类型作为参数类型或返回值类型。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; &#123;</span><br><span class="line">    boolean add(E element);</span><br><span class="line">    E get(int index);</span><br><span class="line">    int size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>泛型方法</li>
</ol>
<p>定义一个泛型方法时，需要在方法名前面加上尖括号&lt;&gt;，并在其中指定泛型的类型。在方法的参数、返回值和局部变量中，可以使用泛型类型。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void printArray(T[] array) &#123;</span><br><span class="line">    for (T element : array) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用泛型时，应该根据具体情况选择合适的泛型类型。同时，对于需要保证类型安全的场景，应该采用泛型的方式进行编程。</p>
<h4 id="集合工具类的使用"><a href="#集合工具类的使用" class="headerlink" title="集合工具类的使用"></a>集合工具类的使用</h4><p>Java中提供了一些集合工具类，可以方便地对集合进行操作，下面介绍几个常用的工具类。</p>
<ol>
<li>Collections类</li>
</ol>
<p>Collections类是Java提供的集合工具类，其中包含了许多静态方法，用于对集合进行排序、查找、替换、打乱等操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(2);</span><br><span class="line"></span><br><span class="line">Collections.sort(list); // 对集合进行排序</span><br><span class="line">System.out.println(list); // 输出 [1, 2, 3]</span><br><span class="line"></span><br><span class="line">int index = Collections.binarySearch(list, 2); // 在集合中查找元素</span><br><span class="line">System.out.println(index); // 输出 1</span><br><span class="line"></span><br><span class="line">Collections.replaceAll(list, 2, 4); // 将集合中的元素替换为指定值</span><br><span class="line">System.out.println(list); // 输出 [1, 4, 3]</span><br><span class="line"></span><br><span class="line">Collections.shuffle(list); // 随机打乱集合中的元素</span><br><span class="line">System.out.println(list); // 输出 [3, 1, 4]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Arrays类</li>
</ol>
<p>Arrays类是Java提供的数组工具类，其中包含了一些静态方法，用于对数组进行排序、查找、比较等操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] array = &#123;3, 1, 2&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.sort(array); // 对数组进行排序</span><br><span class="line">System.out.println(Arrays.toString(array)); // 输出 [1, 2, 3]</span><br><span class="line"></span><br><span class="line">int index = Arrays.binarySearch(array, 2); // 在数组中查找元素</span><br><span class="line">System.out.println(index); // 输出 1</span><br><span class="line"></span><br><span class="line">boolean isEqual = Arrays.equals(array, new int[]&#123;1, 2, 3&#125;); // 比较两个数组是否相等</span><br><span class="line">System.out.println(isEqual); // 输出 true</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>StringUtils类</li>
</ol>
<p>StringUtils类是Apache Commons Lang库提供的字符串工具类，其中包含了一些静态方法，用于对字符串进行处理，如判断是否为空、去除空格、拼接字符串等操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;  hello world! &quot;;</span><br><span class="line"></span><br><span class="line">boolean isBlank = StringUtils.isBlank(str); // 判断字符串是否为空或者只包含空格</span><br><span class="line">System.out.println(isBlank); // 输出 false</span><br><span class="line"></span><br><span class="line">String trimmedStr = StringUtils.trim(str); // 去除字符串前后的空格</span><br><span class="line">System.out.println(trimmedStr); // 输出 &quot;hello world!&quot;</span><br><span class="line"></span><br><span class="line">String joinedStr = StringUtils.join(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;, &quot;, &quot;); // 将数组中的元素以指定分隔符拼接成字符串</span><br><span class="line">System.out.println(joinedStr); // 输出 &quot;hello, world&quot;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用集合工具类时，应该根据具体需求选择合适的工具类和方法。同时，对于需要保证线程安全的场景，应该考虑使用线程安全的集合工具类（如ConcurrentHashMap和CopyOnWriteArrayList等）。</p>
<h4 id="Stream-API的使用"><a href="#Stream-API的使用" class="headerlink" title="Stream API的使用"></a>Stream API的使用</h4><p>Stream API是Java 8中新增的一个功能，它提供了一种流式处理数据的方式，可以方便地对集合、数组和I&#x2F;O等数据源进行操作。</p>
<p>使用Stream API可以大幅度减少代码量，并且提高程序的可读性和可维护性。</p>
<p>下面介绍Stream API的常用方法。</p>
<ol>
<li>filter()</li>
</ol>
<p>filter()方法用于过滤集合中不符合条件的元素。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; filteredList = list.stream()</span><br><span class="line">        .filter(i -&gt; i % 2 == 0)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filteredList); // 输出 [2, 4]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>map()</li>
</ol>
<p>map()方法用于将集合中的每个元素映射为另外一个值。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; mappedList = list.stream()</span><br><span class="line">        .map(s -&gt; s.length())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(mappedList); // 输出 [5, 6, 6]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>reduce()</li>
</ol>
<p>reduce()方法用于对集合中的元素进行归约操作，生成一个新的值。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">int sum = list.stream()</span><br><span class="line">        .reduce(0, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">System.out.println(sum); // 输出 15</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>sorted()</li>
</ol>
<p>sorted()方法用于对集合中的元素进行排序。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(5, 3, 1, 2, 4);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; sortedList = list.stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(sortedList); // 输出 [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用Stream API时，应该根据具体情况选择合适的方法。同时，Stream API中的方法都是惰性求值的，只有在最后调用终止操作（如collect()、forEach()）时才会执行。</p>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><h4 id="File类及其用法"><a href="#File类及其用法" class="headerlink" title="File类及其用法"></a>File类及其用法</h4><p>File类是Java中用来表示文件或目录的类，它提供了一系列操作文件和目录的方法。</p>
<p>下面介绍File类的常用方法。</p>
<p><img src="https://img-blog.csdnimg.cn/20210616175436943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NDIzNA==,size_16,color_FFFFFF,t_70"></p>
<ol>
<li>构造方法</li>
</ol>
<p>File类提供了多个构造方法，可以根据给定的路径创建一个File对象。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file1 = new File(&quot;D:/demo/file.txt&quot;); // 绝对路径</span><br><span class="line">File file2 = new File(&quot;src/main/java/com/example/demo/FileDemo.java&quot;); // 相对路径</span><br><span class="line">File file3 = new File(&quot;D:/demo&quot;, &quot;file.txt&quot;); // 父目录和子文件名</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建和删除文件与目录</li>
</ol>
<p>File类提供了多个方法，可以创建和删除文件和目录。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">boolean isSuccess = file.createNewFile(); // 创建新文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">isSuccess = file.delete(); // 删除文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">File directory = new File(&quot;D:/demo/newdir&quot;);</span><br><span class="line">isSuccess = directory.mkdir(); // 创建新目录</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">isSuccess = directory.delete(); // 删除目录</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>文件信息查询</li>
</ol>
<p>File类提供了多个方法，可以查询文件的属性和状态。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:/demo/file.txt&quot;);</span><br><span class="line"></span><br><span class="line">String absolutePath = file.getAbsolutePath(); // 获取文件的绝对路径</span><br><span class="line">System.out.println(absolutePath); // 输出 D:\demo\file.txt</span><br><span class="line"></span><br><span class="line">long length = file.length(); // 获取文件的长度（字节数）</span><br><span class="line">System.out.println(length); // 输出 0</span><br><span class="line"></span><br><span class="line">boolean isDirectory = file.isDirectory(); // 判断是否为目录</span><br><span class="line">System.out.println(isDirectory); // 输出 false</span><br><span class="line"></span><br><span class="line">boolean isFile = file.isFile(); // 判断是否为文件</span><br><span class="line">System.out.println(isFile); // 输出 true</span><br><span class="line"></span><br><span class="line">boolean exists = file.exists(); // 判断文件是否存在</span><br><span class="line">System.out.println(exists); // 输出 true</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>文件操作</li>
</ol>
<p>File类提供了多个方法，可以对文件进行复制、移动、重命名等操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">File file1 = new File(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">File file2 = new File(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line"></span><br><span class="line">boolean isSuccess = file1.renameTo(file2); // 重命名文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">isSuccess = file1.createNewFile(); // 创建新文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br><span class="line"></span><br><span class="line">InputStream in = new FileInputStream(file1);</span><br><span class="line">OutputStream out = new FileOutputStream(file2);</span><br><span class="line"></span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = in.read(buffer)) &gt; 0) &#123; // 复制文件</span><br><span class="line">    out.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">isSuccess = file1.delete(); // 删除文件</span><br><span class="line">System.out.println(isSuccess); // 输出 true</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用File类时，应该根据具体情况选择合适的方法。同时，对于需要保证线程安全的场景，应该考虑使用线程安全的文件操作类（如Apache Commons IO库提供的工具类）</p>
<h4 id="操作字节流和字符流读写文件"><a href="#操作字节流和字符流读写文件" class="headerlink" title="操作字节流和字符流读写文件"></a>操作字节流和字符流读写文件</h4><p><img src="file:///C:/Users/26927/Pictures/Typedown/b31caab1-f83b-49a4-a25d-cd74f0631ffe.png" alt="b31caab1-f83b-49a4-a25d-cd74f0631ffe"></p>
<p>Java中提供了字节流和字符流两种方式来读写文件。</p>
<ol>
<li>操作字节流读写文件</li>
</ol>
<p>使用字节流读写文件需要使用InputStream和OutputStream类。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件内容</span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = in.read(buffer)) != -1) &#123;</span><br><span class="line">    System.out.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">// 写入文件内容</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">out.write(&quot;Hello, world!&quot;.getBytes());</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>

<p>上面的示例代码中，InputStream的read()方法会读取文件输入流中的字节到缓冲区中，并返回读取的字节数。当读取到文件末尾时，该方法会返回-1。</p>
<ol start="2">
<li>操作字符流读写文件</li>
</ol>
<p>使用字符流读写文件需要使用Reader和Writer类。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件内容</span><br><span class="line">Reader reader = new FileReader(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">char[] buffer = new char[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = reader.read(buffer)) != -1) &#123;</span><br><span class="line">    System.out.print(new String(buffer, 0, len));</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"></span><br><span class="line">// 写入文件内容</span><br><span class="line">Writer writer = new FileWriter(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">writer.write(&quot;Hello, world!&quot;);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>

<p>上面的示例代码中，Reader的read()方法会读取文件输入流中的字符到缓冲区中，并返回读取的字符数。当读取到文件末尾时，该方法会返回-1。</p>
<p>需要注意的是，在读写文件时，应该根据文件的编码格式选择合适的字节流或字符流。另外，为避免资源泄漏，应该使用try-with-resources语句来自动关闭输入输出流。</p>
<p><img src="file:///C:/Users/26927/Pictures/Typedown/7ae67b77-245e-4b50-8f22-3872be2cf7d9.png" alt="7ae67b77-245e-4b50-8f22-3872be2cf7d9"></p>
<h4 id="其他IO流（了解）"><a href="#其他IO流（了解）" class="headerlink" title="其他IO流（了解）"></a>其他IO流（了解）</h4><p>除了字节流和字符流之外，Java中还提供了其他多种类型的IO流，包括：</p>
<ol>
<li>缓冲流</li>
</ol>
<p>缓冲流是一种性能更好的字节流或字符流，它可以减少访问底层资源的次数，提高读写效率。Java中提供了BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter等缓冲流类。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 使用缓冲字节流复制文件内容</span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(in);</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(out);</span><br><span class="line"></span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int len;</span><br><span class="line">while ((len = bis.read(buffer)) != -1) &#123;</span><br><span class="line">    bos.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br><span class="line"></span><br><span class="line">// 使用缓冲字符流读取文件内容</span><br><span class="line">Reader reader = new FileReader(&quot;D:/demo/file.txt&quot;);</span><br><span class="line">Writer writer = new FileWriter(&quot;D:/demo/newfile.txt&quot;);</span><br><span class="line">BufferedReader br = new BufferedReader(reader);</span><br><span class="line">BufferedWriter bw = new BufferedWriter(writer);</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line">while ((line = br.readLine()) != null) &#123;</span><br><span class="line">    bw.write(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据流</li>
</ol>
<p>数据流可以用来读写Java中的基本数据类型和对象，在读写时会将数据转换为二进制格式。Java中提供了DataInputStream和DataOutputStream两个数据流类。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用数据流写入和读取基本数据类型</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/data.bin&quot;);</span><br><span class="line">DataOutputStream dos = new DataOutputStream(out);</span><br><span class="line"></span><br><span class="line">dos.writeInt(123);</span><br><span class="line">dos.writeDouble(3.14);</span><br><span class="line">dos.writeBoolean(true);</span><br><span class="line"></span><br><span class="line">dos.close();</span><br><span class="line"></span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/data.bin&quot;);</span><br><span class="line">DataInputStream dis = new DataInputStream(in);</span><br><span class="line"></span><br><span class="line">int intValue = dis.readInt();</span><br><span class="line">double doubleValue = dis.readDouble();</span><br><span class="line">boolean booleanValue = dis.readBoolean();</span><br><span class="line"></span><br><span class="line">dis.close();</span><br><span class="line"></span><br><span class="line">System.out.println(intValue); // 输出 123</span><br><span class="line">System.out.println(doubleValue); // 输出 3.14</span><br><span class="line">System.out.println(booleanValue); // 输出 true</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>对象流</li>
</ol>
<p>对象流可以用来读写Java中的对象，在读写时会将对象序列化为二进制格式。Java中提供了ObjectInputStream和ObjectOutputStream两个对象流类。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用对象流写入和读取对象</span><br><span class="line">OutputStream out = new FileOutputStream(&quot;D:/demo/person.obj&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(out);</span><br><span class="line">Person person = new Person(&quot;张三&quot;, 20);</span><br><span class="line">oos.writeObject(person);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">InputStream in = new FileInputStream(&quot;D:/demo/person.obj&quot;);</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(in);</span><br><span class="line">person = (Person) ois.readObject();</span><br><span class="line">ois.close();</span><br><span class="line"></span><br><span class="line">System.out.println(person.getName()); // 输出 张三</span><br><span class="line">System.out.println(person.getAge()); // 输出 20</span><br></pre></td></tr></table></figure>

<p><img src="file:///C:/Users/26927/Pictures/Typedown/d6e042ae-9eba-412c-a522-a2840c05601f.png" alt="d6e042ae-9eba-412c-a522-a2840c05601f"></p>
<p>需要注意的是，在使用IO流时，应该根据具体情况选择合适的流类型，并在读写完毕后及时关闭流以释放资源。</p>
<h4 id="NIO的概念及其用法（了解）"><a href="#NIO的概念及其用法（了解）" class="headerlink" title="NIO的概念及其用法（了解）"></a>NIO的概念及其用法（了解）</h4><p>NIO（New IO）是Java中提供的一种新的IO处理方式，它相对于传统的IO方式具有更高的效率和灵活性。</p>
<ol>
<li>NIO的概念</li>
</ol>
<p>在传统IO中，数据的读写是通过流（InputStream&#x2F;OutputStream）进行的。而在NIO中，数据的读写是通过缓冲区（Buffer）进行的。NIO中的核心类包括ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、DoubleBuffer等缓冲区类，以及Channel、Selector等类。</p>
<ol start="2">
<li>NIO的用法</li>
</ol>
<p>使用NIO进行数据读写需要以下几个步骤：</p>
<p>2.1 打开Channel</p>
<p>首先需要打开一个Channel，可以是FileChannel、DatagramChannel、SocketChannel或ServerSocketChannel等类型的通道。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打开文件通道</span><br><span class="line">FileChannel channel = FileChannel.open(Paths.get(&quot;D:/demo/file.txt&quot;), StandardOpenOption.READ);</span><br></pre></td></tr></table></figure>

<p>2.2 创建Buffer</p>
<p>创建一个Buffer来存储数据。在NIO中，所有数据都是通过Buffer来处理的，因此需要根据实际需要创建合适类型的Buffer。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">// 创建字节缓冲区</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>

<p>2.3 从Channel中读取数据</p>
<p>使用Channel的read()方法从Channel中读取数据到Buffer中。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从文件通道读取数据到缓冲区</span><br><span class="line">int bytesRead = channel.read(buffer);</span><br></pre></td></tr></table></figure>

<p>2.4 写入数据到Channel中</p>
<p>使用Channel的write()方法将数据从Buffer中写入到Channel中。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将缓冲区中的数据写入到文件通道中</span><br><span class="line">buffer.flip(); // 切换读模式到写模式</span><br><span class="line">channel.write(buffer);</span><br></pre></td></tr></table></figure>

<p>2.5 关闭Channel</p>
<p>使用完Channel后应该手动关闭它以释放资源。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 关闭文件通道</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>NIO Selector的用法</li>
</ol>
<p>NIO中的Selector可以用来监听多个Channel的事件，并在有事件发生时进行处理。Selector主要包括以下几个方法：</p>
<ul>
<li><p>Selector.open()：打开一个Selector。</p>
</li>
<li><p>select()：阻塞并等待至少一个Channel有就绪事件产生。</p>
</li>
<li><p>selectedKeys()：获取所有就绪的SelectionKey集合。</p>
</li>
<li><p>Selector.close()：关闭Selecto<br>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 打开Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">// 向通道注册Selector及所关心的事件</span><br><span class="line">SelectableChannel channel = SocketChannel.open();</span><br><span class="line">channel.configureBlocking(false); // 设置为非阻塞IO</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">// 阻塞并等待就绪事件的产生</span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">// 处理就绪事件</span><br><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey selectionKey = iterator.next();</span><br><span class="line">    if (selectionKey.isReadable()) &#123;</span><br><span class="line">        // Channel可读事件处理</span><br><span class="line">    &#125; else if (selectionKey.isWritable()) &#123;</span><br><span class="line">        // Channel可写事件处理</span><br><span class="line">    &#125;</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭Selector</span><br><span class="line">selector.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>需要注意的是，在使用NIO进行数据读写时，应该根据实际需求选择使用哪种类型的Channel和Buffer，并保证线程安全。同时，在使用Selector时也应该避免过度使用，以免造成系统资源浪费。</p>
<h4 id="常见字符编码（了解）"><a href="#常见字符编码（了解）" class="headerlink" title="常见字符编码（了解）"></a>常见字符编码（了解）</h4><p>在计算机中，字符编码是用来表示字符的数值代码的一种系统。常见的字符编码包括以下几种：</p>
<ol>
<li>ASCII</li>
</ol>
<p>ASCII（American Standard Code for Information Interchange）是最早的字符编码标准之一，使用7位二进制数来表示128个不同的字符，包括英文字母、数字、标点符号等。</p>
<ol start="2">
<li>ISO-8859</li>
</ol>
<p>ISO-8859是一系列字符编码标准，其中最常用的是ISO-8859-1，也称为Latin-1。ISO-8859-1使用8位二进制数来表示256个不同的字符，包括ASCII中的所有字符以及欧洲各国语言中出现的字符。</p>
<ol start="3">
<li>Unicode</li>
</ol>
<p>Unicode是一种全球化字符编码标准，它使用32位二进制数来表示超过100,000个字符，包括各种语言的字符、符号、表情等。Unicode的两种主要实现方式是UTF-8和UTF-16。</p>
<ol start="4">
<li>UTF-8</li>
</ol>
<p>UTF-8（Unicode Transformation Format 8-bit）是一种变长编码方式，它使用1~4个字节来表示不同的字符。UTF-8可以表示Unicode中的任意字符，并且向下兼容ASCII编码。</p>
<ol start="5">
<li>UTF-16</li>
</ol>
<p>UTF-16（Unicode Transformation Format 16-bit）是一种定长编码方式，它使用2个字节来表示大部分常用字符，使用4个字节来表示较少使用的字符。UTF-16可以表示Unicode中的任意字符，但是它不向下兼容ASCII编码。</p>
<p>需要注意的是，在进行文本处理时应该根据具体情况选择合适的字符编码，避免因编码不匹配而导致乱码等问题。同时，在进行字符编码转换时也应该谨慎处理，以免产生意外的结果。</p>
<h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><h3 id="AWT组件和Swing组件的联系和区别（了解）"><a href="#AWT组件和Swing组件的联系和区别（了解）" class="headerlink" title="AWT组件和Swing组件的联系和区别（了解）"></a>AWT组件和Swing组件的联系和区别（了解）</h3><p>AWT（Abstract Window Toolkit）和Swing都是Java GUI编程中常用的组件库，它们有很多相似之处，但也存在一些区别。</p>
<ol>
<li>AWT组件和Swing组件的联系</li>
</ol>
<p>AWT和Swing都提供了大量的GUI组件，例如按钮、文本框、标签、列表框、下拉框等。这些组件都可以使用Java代码进行创建、配置和布局，并且可以添加事件监听器来处理交互事件。</p>
<p>同时，AWT和Swing都使用轻量级组件模型，即将所有GUI组件封装在一个统一的容器中，并由容器自行管理和绘制组件。</p>
<ol start="2">
<li>AWT组件和Swing组件的区别</li>
</ol>
<p>虽然AWT和Swing都是GUI组件库，但是它们也存在着一些不同之处：</p>
<ul>
<li>组件外观：AWT使用本地系统窗口来呈现组件，因此它的外观会随操作系统的不同而有所差异；而Swing则采用了一套独立的外观设计，称为“Pluggable Look and Feel”，使得Swing组件在不同平台上具有一致的外观。</li>
<li>组件性能：由于AWT使用了本地系统窗口，因此在跨平台时可能会出现性能问题；而Swing则更加轻量级，可以在不同平台上获得更好的性能表现。</li>
<li>组件数量：AWT提供的组件数量相对较少，而Swing则提供了更丰富的组件库，例如JTable、JTree、JFileChooser等。</li>
<li>组件功能：AWT的组件功能相对简单，适合于开发基础的GUI应用程序；而Swing的组件功能更加强大，可以用于开发复杂的GUI应用程序。</li>
</ul>
<p>总的来说，如果需要开发简单的GUI应用程序，可以选择使用AWT，它更加稳定并且易于学习；而如果需要开发复杂的GUI应用程序，可以选择Swing，它更加灵活、强大并且具有良好的跨平台性能。</p>
<h3 id="常用的Swing组件的使用"><a href="#常用的Swing组件的使用" class="headerlink" title="常用的Swing组件的使用"></a>常用的Swing组件的使用</h3><p>Swing是Java中常用的GUI组件库，提供了大量的组件和布局管理器，可以用于开发丰富的GUI应用程序。以下是一些常用的Swing组件及其使用方法：</p>
<ol>
<li>JFrame</li>
</ol>
<p>JFrame是Swing中最基本的顶层容器，它可以作为窗口来显示Swing中的其他组件。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = new JFrame(&quot;My Frame&quot;);</span><br><span class="line">frame.setSize(400, 300);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置关闭行为</span><br><span class="line">frame.setVisible(true); // 显示窗口</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JPanel</li>
</ol>
<p>JPanel是一个面板容器，可以将其他组件添加进来，并使用布局管理器进行管理。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JPanel panel = new JPanel(new BorderLayout());</span><br><span class="line">panel.add(new JButton(&quot;Button&quot;), BorderLayout.CENTER);</span><br><span class="line">panel.add(new JLabel(&quot;Label&quot;), BorderLayout.NORTH);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>JButton</li>
</ol>
<p>JButton是一个按钮组件，可以响应用户的单击事件。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JButton button = new JButton(&quot;Click me&quot;);</span><br><span class="line">button.addActionListener(e -&gt; &#123;</span><br><span class="line">    // 处理按钮单击事件</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>JTextField</li>
</ol>
<p>JTextField是一个文本框组件，可以让用户输入和编辑文本。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JTextField textField = new JTextField(&quot;default text&quot;, 20);</span><br><span class="line">String text = textField.getText(); // 获取文本框中的文本</span><br><span class="line">textField.setText(&quot;new text&quot;); // 设置文本框中的文本JCheckBox</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>JCheckBox</li>
</ol>
<p>JCheckBox是一个复选框组件，可以让用户进行多选操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JCheckBox checkBox = new JCheckBox(&quot;Check me&quot;);</span><br><span class="line">boolean checked = checkBox.isSelected(); // 判断复选框是否被选中</span><br><span class="line">checkBox.setSelected(true); // 设置复选框为选中状态</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>JRadioButton</li>
</ol>
<p>JRadioButton是一个单选按钮组件，与JCheckBox不同的是，只允许用户进行单选操作。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JRadioButton radioButton1 = new JRadioButton(&quot;Option 1&quot;);</span><br><span class="line">JRadioButton radioButton2 = new JRadioButton(&quot;Option 2&quot;);</span><br><span class="line">ButtonGroup group = new ButtonGroup();</span><br><span class="line">group.add(radioButton1);</span><br><span class="line">group.add(radioButton2);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>JComboBox</li>
</ol>
<p>JComboBox是一个下拉框组件，可以提供多个选项供用户选择。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JComboBox&lt;String&gt; comboBox = new JComboBox&lt;&gt;(new String[]&#123;&quot;Option 1&quot;, &quot;Option 2&quot;, &quot;Option 3&quot;&#125;);</span><br><span class="line">String selected = comboBox.getSelectedItem().toString(); // 获取当前选中的选项</span><br><span class="line">comboBox.setSelectedIndex(1); // 设置选中指定索引位置的选项</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用Swing组件时应该根据实际需求选择合适的组件、布局管理器以及事件处理方式，以便实现所需的功能并提升用户体验。</p>
<h4 id="常用的窗体和布局管理器"><a href="#常用的窗体和布局管理器" class="headerlink" title="常用的窗体和布局管理器"></a>常用的窗体和布局管理器</h4><p>在Java Swing中，窗体和布局管理器是常用的GUI开发工具。以下是一些常用的窗体和布局管理器：</p>
<ol>
<li>JFrame</li>
</ol>
<p>JFrame是Swing中最基本的顶层容器，可以作为窗口来显示Swing中的其他组件。使用setDefaultCloseOperation()方法设置关闭窗口时的行为，使用setSize()、setLocation()等方法设置窗口大小和位置。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = new JFrame(&quot;My Frame&quot;);</span><br><span class="line">frame.setSize(400, 300);</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置关闭行为</span><br><span class="line">frame.setVisible(true); // 显示窗口</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JPanel</li>
</ol>
<p>JPanel是一个面板容器，可以将其他组件添加进来，并使用布局管理器进行管理。使用setLayout()方法设置面板的布局管理器，使用add()方法将其他组件添加到面板中。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JPanel panel = new JPanel(new BorderLayout());</span><br><span class="line">panel.add(new JButton(&quot;Button&quot;), BorderLayout.CENTER);</span><br><span class="line">panel.add(new JLabel(&quot;Label&quot;), BorderLayout.NORTH);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-边框布局管理器-BorderLayout"><a href="#1-1-边框布局管理器-BorderLayout" class="headerlink" title="1.1 边框布局管理器(BorderLayout)"></a>1.1 边框布局管理器(BorderLayout)</h4><blockquote>
<p>BorderLayout（边框布局管理器）是 Window、JFrame 和 JDialog 的默认布局管理器。边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。其中，North 表示北，将占据面板的上方；Soufe 表示南，将占据面板的下方；East表示东，将占据面板的右侧；West 表示西，将占据面板的左侧；中间区域 Center 是在东、南、西、北都填满后剩下的区域，如图 所示：<br><img src="https://img-blog.csdnimg.cn/20190305000445812.png" alt="在这里插入图片描述"><br><code>提示：边框布局管理器并不要求所有区域都必须有组件，如果四周的区域（North、South、East 和 West 区域）没有组件，则由 Center 区域去补充。如果单个区域中添加的不只一个组件，那么后来添加的组件将覆盖原来的组件，所以，区域中只显示最后添加的一个组件。</code></p>
</blockquote>
<h5 id="1-2-BorderLayout-布局管理器的构造方法"><a href="#1-2-BorderLayout-布局管理器的构造方法" class="headerlink" title="1.2 BorderLayout 布局管理器的构造方法"></a>1.2 BorderLayout 布局管理器的构造方法</h5><pre><code>BorderLayout()
创建一个 Border 布局，组件之间没有间隙。
BorderLayout(int hgap,int vgap)
创建一个 Border 布局，其中 hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。
</code></pre>
<h5 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h5><blockquote>
<p>使用 BorderLayout 将窗口分割为 5 个区域，并在每个区域添加一个标签按钮。实现代码如下：</p>
</blockquote>
<pre><code>import javax.swing.*;
import java.awt.*;

public class BorderLayoutDemo &#123;
    public static void main(String[] agrs) &#123;
        JFrame frame=new JFrame(&quot;BorderLayoutDemo&quot;);    //创建Frame窗口
        frame.setSize(400,200);

        frame.setLayout(new BorderLayout());    //为Frame窗口设置布局为BorderLayout

        JButton button1=new JButton (&quot;上&quot;);
        JButton button2=new JButton(&quot;左&quot;);
        JButton button3=new JButton(&quot;中&quot;);
        JButton button4=new JButton(&quot;右&quot;);
        JButton button5=new JButton(&quot;下&quot;);

        frame.add(button1,BorderLayout.NORTH);
        frame.add(button2,BorderLayout.WEST);
        frame.add(button3,BorderLayout.CENTER);
        frame.add(button4,BorderLayout.EAST);
        frame.add(button5,BorderLayout.SOUTH);

        frame.setBounds(300,200,600,300);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
</code></pre>
<blockquote>
<p><code>运行效果如下：</code><br><img src="https://img-blog.csdnimg.cn/20190305001135544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="二、流式布局管理器-FlowLayout"><a href="#二、流式布局管理器-FlowLayout" class="headerlink" title="二、流式布局管理器(FlowLayout)"></a><code>二、流式布局管理器(FlowLayout)</code></h4><h5 id="2-1-FlowLayout"><a href="#2-1-FlowLayout" class="headerlink" title="2.1 FlowLayout"></a>2.1 FlowLayout</h5><blockquote>
<p>FlowLayout（流式布局管理器）是 JPanel 和 JApplet 的默认布局管理器。<code>FlowLayout 会将组件按照从从左到右、上到下的放置规律逐行进行定位。与其他布局管理器不同的是，FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。</code></p>
</blockquote>
<h5 id="2-2-FlowLayout-布局管理器的构造方法"><a href="#2-2-FlowLayout-布局管理器的构造方法" class="headerlink" title="2.2 FlowLayout 布局管理器的构造方法"></a>2.2 FlowLayout 布局管理器的构造方法</h5><pre><code>FlowLayout()：创建一个布局管理器，使用默认的居中对齐方式和默认 5 像素的水平和垂直间隔。
FlowLayout(int align)：创建一个布局管理器，使用默认 5 像素的水平和垂直间隔。其中，align 表示组件的对齐方式，对齐的值必须是 FlowLayout.LEFT、FlowLayout.RIGHT 和 FlowLayout.CENTER，指定组件在这一行的位置是居左对齐、居右对齐或居中对齐。
FlowLayout(int align, int hgap,int vgap)：创建一个布局管理器，其中 align 表示组件的对齐方式；hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。
</code></pre>
<h5 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h5><blockquote>
<p>使用 FlowLayout 类对窗口进行布局，向容器内添加 9 个按钮，并设置横向和纵向的间隔都为 20 像素。具体实现代码如下：</p>
</blockquote>
<pre><code>import javax.swing.*;
import java.awt.*;

public class FlowLayoutDemo &#123;
    public static void main(String[] agrs)  &#123;
        JFrame jFrame=new JFrame(&quot;FlowLayoutDemo&quot;);    //创建Frame窗口

        JPanel jPanel=new JPanel();    //创建面板
        JButton btn1=new JButton(&quot;1&quot;);    //创建按钮
        JButton btn2=new JButton(&quot;2&quot;);
        JButton btn3=new JButton(&quot;3&quot;);
        JButton btn4=new JButton(&quot;4&quot;);
        JButton btn5=new JButton(&quot;5&quot;);
        JButton btn6=new JButton(&quot;6&quot;);
        JButton btn7=new JButton(&quot;7&quot;);
        JButton btn8=new JButton(&quot;8&quot;);
        JButton btn9=new JButton(&quot;9&quot;);

        jPanel.add(btn1);    //面板中添加按钮
        jPanel.add(btn2);
        jPanel.add(btn3);
        jPanel.add(btn4);
        jPanel.add(btn5);
        jPanel.add(btn6);
        jPanel.add(btn7);
        jPanel.add(btn8);
        jPanel.add(btn9);

        //向JPanel添加FlowLayout布局管理器，将组件间的横向和纵向间隙都设置为20像素
        jPanel.setLayout(new FlowLayout(FlowLayout.LEADING,20,20));
        jPanel.setBackground(Color.gray);    //设置背景色
        jFrame.add(jPanel);    //添加面板到容器
        jFrame.setBounds(300,200,300,150);    //设置容器的大小
        jFrame.setVisible(true);
        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>上述程序向 JPanel 面板中添加了 9 个按钮，并使用 FlowLayout 布局管理器使 9 个按钮间的横向和纵向间隙都为 20 像素。此时这些按钮将在容器上按照从上到下、从左到右的顺序排列，如果一行剩余空间不足容纳组件将会换行显示，最终运行结果如图 所示：<br><img src="https://img-blog.csdnimg.cn/20190305002233296.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190305002306124.png" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="三、卡片布局管理器-CardLayout"><a href="#三、卡片布局管理器-CardLayout" class="headerlink" title="三、卡片布局管理器(CardLayout)"></a><code>三、卡片布局管理器(CardLayout)</code></h4><h5 id="3-1-CardLayout"><a href="#3-1-CardLayout" class="headerlink" title="3.1 CardLayout"></a>3.1 CardLayout</h5><blockquote>
<p>CardLayout（卡片布局管理器）能够帮助用户实现多个成员共享同一个显示空间，并且一次只显示一个容器组件的内容。<br><code>CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。</code></p>
</blockquote>
<h5 id="3-2-CardLayout-的构造方法"><a href="#3-2-CardLayout-的构造方法" class="headerlink" title="3.2 CardLayout 的构造方法"></a>3.2 CardLayout 的构造方法</h5><pre><code>CardLayout()：构造一个新布局，默认间隔为 0。
CardLayout(int hgap, int vgap)：创建布局管理器，并指定组件间的水平间隔（hgap）和垂直间隔（vgap）。
</code></pre>
<h5 id="3-3-示例"><a href="#3-3-示例" class="headerlink" title="3.3 示例"></a>3.3 示例</h5><blockquote>
<p>使用 CardLayout 类对容器内的两个面板进行布局。其中第一个面板上包括三个按钮，第二个面板上包括三个文本框。最后调用 CardLayout 类的 show() 方法显示指定面板的内容，代码如下：</p>
</blockquote>
<pre><code>import javax.swing.*;
import java.awt.*;

public class CardLayoutDemo &#123;
    public static void main(String[] agrs) &#123;
        JFrame frame=new JFrame(&quot;CardLayoutDemo&quot;);    //创建Frame窗口

        JPanel p1=new JPanel();    //面板1
        JPanel p2=new JPanel();    //面板2
        JPanel cards=new JPanel(new CardLayout());    //卡片式布局的面板

        p1.add(new JButton(&quot;登录按钮&quot;));
        p1.add(new JButton(&quot;注册按钮&quot;));
        p1.add(new JButton(&quot;找回密码按钮&quot;));

        p2.add(new JTextField(&quot;用户名文本框&quot;,20));
        p2.add(new JTextField(&quot;密码文本框&quot;,20));
        p2.add(new JTextField(&quot;验证码文本框&quot;,20));

        cards.add(p1,&quot;card1&quot;);    //向卡片式布局面板中添加面板1
        cards.add(p2,&quot;card2&quot;);    //向卡片式布局面板中添加面板2

        CardLayout cl=(CardLayout)(cards.getLayout());
        cl.show(cards,&quot;card1&quot;);    //调用show()方法显示面板2

        frame.add(cards);
        frame.setBounds(300,200,400,200);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>上述代码创建了一个卡片式布局的面板 cards，该面板包含两个大小相同的子面板 p1 和 p2。需要注意的是，在将 p1 和 p2 添加到 cards 面板中时使用了含有两个参数的 add() 方法，该方法的第二个参数用来标识子面板。当需要显示某一个面板时，只需要调用卡片式布局管理器的 show() 方法，并在参数中指定子面板所对应的字符串即可，这里显示的是 p1 面板，运行效果如图 所示：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190305003304870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>如果将“cl.show(cards,“card1”)”语句中的 card1 换成 card2，将显示 p2 面板的内容，此时运行结果如图 所示：<br><img src="https://img-blog.csdnimg.cn/20190305003408605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="四、网格布局管理器-GridLayout"><a href="#四、网格布局管理器-GridLayout" class="headerlink" title="四、网格布局管理器(GridLayout)"></a><code>四、网格布局管理器(GridLayout)</code></h4><h5 id="4-1-GridLayout"><a href="#4-1-GridLayout" class="headerlink" title="4.1 GridLayout"></a>4.1 GridLayout</h5><blockquote>
<p>GridLayout（网格布局管理器）为组件的放置位置提供了更大的灵活性。<code>它将区域分割成行数（rows）和列数（columns）的网格状布局，组件按照由左至右、由上而下的次序排列填充到各个单元格中。</code><br><code>提示：GridLayout 布局管理器总是忽略组件的最佳大小，而是根据提供的行和列进行平分。该布局管理的所有单元格的宽度和高度都是一样的。</code></p>
</blockquote>
<h5 id="4-2-GridLayout-的构造方法"><a href="#4-2-GridLayout-的构造方法" class="headerlink" title="4.2 GridLayout 的构造方法"></a>4.2 GridLayout 的构造方法</h5><pre><code>GridLayout(int rows,int cols)：创建一个指定行（rows）和列（cols）的网格布局。布局中所有组件的大小一样，组件之间没有间隔。
GridLayout(int rows,int cols,int hgap,int vgap)：创建一个指定行（rows）和列（cols）的网格布局，并且可以指定组件之间横向（hgap）和纵向（vgap）的间隔，单位是像素。
</code></pre>
<h5 id="4-3-示例"><a href="#4-3-示例" class="headerlink" title="4.3 示例"></a>4.3 示例</h5><blockquote>
<p>使用 GridLayout 类的网格布局设计一个简单计算器。代码的实现如下：</p>
</blockquote>
<pre><code>import javax.swing.*;
import java.awt.*;

public class GridLayoutDemo &#123;
    public static void main(String[] args) &#123;
        JFrame frame=new JFrame(&quot;GridLayou布局计算器&quot;);

        JPanel panel=new JPanel();    //创建面板
        //指定面板的布局为GridLayout，4行4列，间隙为5
        panel.setLayout(new GridLayout(4,4,5,5));
        panel.add(new JButton(&quot;7&quot;));    //添加按钮
        panel.add(new JButton(&quot;8&quot;));
        panel.add(new JButton(&quot;9&quot;));
        panel.add(new JButton(&quot;/&quot;));
        panel.add(new JButton(&quot;4&quot;));
        panel.add(new JButton(&quot;5&quot;));
        panel.add(new JButton(&quot;6&quot;));
        panel.add(new JButton(&quot;*&quot;));
        panel.add(new JButton(&quot;1&quot;));
        panel.add(new JButton(&quot;2&quot;));
        panel.add(new JButton(&quot;3&quot;));
        panel.add(new JButton(&quot;-&quot;));
        panel.add(new JButton(&quot;0&quot;));
        panel.add(new JButton(&quot;.&quot;));
        panel.add(new JButton(&quot;=&quot;));
        panel.add(new JButton(&quot;+&quot;));

        frame.add(panel);    //添加面板到容器
        frame.setBounds(300,200,200,150);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>上述程序设置面板为 4 行 4 列、间隙都为 5 像素的网格布局，在该面板上包含 16 个按钮，其横向和纵向的间隙都为 5。该程序的运行结果如图所示：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190305004128646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="五、网格包布局管理器-GridBagLayout"><a href="#五、网格包布局管理器-GridBagLayout" class="headerlink" title="五、网格包布局管理器(GridBagLayout)"></a><code>五、网格包布局管理器(GridBagLayout)</code></h4><h5 id="5-1-GridBagLayout"><a href="#5-1-GridBagLayout" class="headerlink" title="5.1 GridBagLayout"></a>5.1 GridBagLayout</h5><blockquote>
<p>GridBagLayout（网格包布局管理器）是在网格基础上提供复杂的布局，是最灵活、 最复杂的布局管理器。<code>GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。</code>每个 GridBagLayout 对象都维护了一组动态的矩形网格单元，每个组件占一个或多个单元，所占有的网格单元称为组件的显示区域。<br>GridBagLayout 所管理的每个组件都与一个 GridBagConstraints 约束类的对象相关。这个约束类对象指定了组件的显示区域在网格中的位置，以及在其显示区域中应该如何摆放组件。除了组件的约束对象，GridBagLayout 还要考虑每个组件的最小和首选尺寸，以确定组件的大小。</p>
</blockquote>
<h5 id="5-2-GridBagLayout属性设置"><a href="#5-2-GridBagLayout属性设置" class="headerlink" title="5.2 GridBagLayout属性设置"></a>5.2 GridBagLayout属性设置</h5><blockquote>
<p>为了有效地利用网格包布局管理器，在向容器中添加组件时，必须定制某些组件的相关约束对象。GridBagConstraints 对象的定制是通过下列变量实现的。</p>
</blockquote>
<ul>
<li>1.gridx 和 gridy</li>
</ul>
<blockquote>
<p>用来指定组件左上角在网格中的行和列。<code>容器中最左边列的 gridx 为 0，最上边行的 gridy 为 0。</code>这两个变量的默认值是GridBagConstraints.RELATIVE，表示对应的组件将放在前一个组件的右边或下面。</p>
</blockquote>
<ul>
<li>2.gridwidth 和 gridheight</li>
</ul>
<blockquote>
<p><code>用来指定组件显示区域所占的列数和行数，以网格单元而不是像素为单位，默认值为 1。</code></p>
</blockquote>
<ul>
<li>3.fill</li>
</ul>
<blockquote>
<p><code>指定组件填充网格的方式</code>，可以是如下值：GridBagConstraints.NONE（默认值）、GridBagConstraints.HORIZONTAL（组件横向充满显示区域，但是不改变组件高度）、GridBagConstraints.VERTICAL（组件纵向充满显示区域，但是不改变组件宽度）以及 GridBagConstraints.BOTH（组件横向、纵向充满其显示区域）。</p>
</blockquote>
<ul>
<li>4.ipadx 和 ipady</li>
</ul>
<blockquote>
<p><code>指定组件显示区域的内部填充，</code>即在组件最小尺寸之外需要附加的像素数，<code>默认值为 0。</code></p>
</blockquote>
<ul>
<li>5.insets</li>
</ul>
<blockquote>
<p><code>指定组件显示区域的外部填充，</code>即组件与其显示区域边缘之间的空间， <code>默认组件没有外部填充。</code></p>
</blockquote>
<ul>
<li>6.anchor</li>
</ul>
<blockquote>
<p><code>指定组件在显示区域中的摆放位置。</code>可选值有 GridBagConstraints.CENTER（默认值）、GridBagConstraints.NORTH、GridBagConstraints.NORTHEAST、GridBagConstraints.EAST、GridBagConstraints.SOUTH、GridBagConstraints.SOUTHEAST、GridBagConstraints.WEST、GridBagConstraints.SOUTHWEST 以及 GridBagConstraints.NORTHWEST。</p>
</blockquote>
<ul>
<li>7.weightx 和 weighty</li>
</ul>
<blockquote>
<p><code>用来指定在容器大小改变时，增加或减少的空间如何在组件间分配，默认值为 0，</code>即所有的组件将聚拢在容器的中心，多余的空间将放在容器边缘与网格单元之间。weightx 和 weighty 的取值一般在 0.0 与 1.0 之间，数值大表明组件所在的行或者列将获得更多的空间。</p>
</blockquote>
<h5 id="5-3-示例"><a href="#5-3-示例" class="headerlink" title="5.3 示例"></a>5.3 示例</h5><blockquote>
<p>创建一个窗口，使用 GridBagLayout 进行布局，实现一个简易的手机拨号盘。这里要注意如何控制行内组件的显示方式以及使用 GridBagConstraints.REMAINDER 来控制一行的结束。代码的实现如下：</p>
</blockquote>
<pre><code>import javax.swing.*;
import java.awt.*;

public class GridBagLayoutDemo &#123;

    //向JFrame中添加JButton按钮
    public static void makeButton(String title,JFrame frame,GridBagLayout gridBagLayout,GridBagConstraints constraints) &#123;
        JButton button=new JButton(title);    //创建Button对象
        gridBagLayout.setConstraints(button,constraints);
        frame.add(button);
    &#125;
    public static void main(String[] agrs) &#123;
        JFrame frame=new JFrame(&quot;拨号盘&quot;);
        GridBagLayout gbaglayout=new GridBagLayout();    //创建GridBagLayout布局管理器
        GridBagConstraints constraints=new GridBagConstraints();
        frame.setLayout(gbaglayout);    //使用GridBagLayout布局管理器
        constraints.fill = GridBagConstraints.BOTH;    //组件填充显示区域
        constraints.weightx=0.0;    //恢复默认值
        constraints.gridwidth = GridBagConstraints.REMAINDER;    //结束行
        JTextField tf=new JTextField(&quot;13612345678&quot;);
        gbaglayout.setConstraints(tf, constraints);
        frame.add(tf);
        constraints.weightx=0.5;    // 指定组件的分配区域
        constraints.weighty=0.2;
        constraints.gridwidth=1;
        makeButton(&quot;7&quot;,frame,gbaglayout,constraints);    //调用方法，添加按钮组件
        makeButton(&quot;8&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=GridBagConstraints.REMAINDER;    //结束行
        makeButton(&quot;9&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=1;    //重新设置gridwidth的值

        makeButton(&quot;4&quot;,frame,gbaglayout,constraints);
        makeButton(&quot;5&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=GridBagConstraints.REMAINDER;
        makeButton(&quot;6&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=1;

        makeButton(&quot;1&quot;,frame,gbaglayout,constraints);
        makeButton(&quot;2&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=GridBagConstraints.REMAINDER;
        makeButton(&quot;3&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=1;

        makeButton(&quot;返回&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=GridBagConstraints.REMAINDER;
        makeButton(&quot;拨号&quot;,frame,gbaglayout,constraints);
        constraints.gridwidth=1;
        frame.setBounds(400,400,400,400);    //设置容器大小
        frame.setVisible(true);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>在上述程序中创建了一个 makeButton() 方法，用来将 JButton 组件添加到 JFrame 窗口中。在 main() 方法中分别创建了 GridBagLayout 对象和 GridBagConstraints 对象，然后设置 JFrame 窗口的布局为 GridBagLayout，并设置了 GridBagConstraints 的一些属性。接着将 JTextField 组件添加至窗口中，并通知布局管理器的 GridBagConstraints 信息。<br>在接下来的代码中，调用 makeButton() 方法向 JFrame 窗口填充按钮，并使用 GridBagConstraints. REMAINDER 来控制结束行。当一行结束后，重新设置 GridBagConstraints 对象的 gridwidth 为 1。最后设置 JFrame 窗口为可见状态，程序运行后的拨号盘效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20190305005713575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcwNDIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h4><p>在Java中，事件处理机制是一种常用的编程模式，它允许程序响应用户操作、系统事件等各种不同类型的事件。以下是Java中的事件处理机制：</p>
<ol>
<li>事件源</li>
</ol>
<p>事件源是指能够产生事件的对象，例如按钮、文本框、菜单等。</p>
<ol start="2">
<li>事件监听器</li>
</ol>
<p>事件监听器是一个接口，定义了用于监听特定事件的方法。通常情况下，每个事件都有自己对应的事件监听器。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ActionListener &#123;</span><br><span class="line">    public void actionPerformed(ActionEvent e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册事件监听器</li>
</ol>
<p>将事件监听器注册到事件源上，以便在事件发生时能够被及时捕捉和处理。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JButton button = new JButton(&quot;Click me&quot;);</span><br><span class="line">button.addActionListener(new ActionListener() &#123; // 注册事件监听器</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        // 处理按钮单击事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>事件分发机制</li>
</ol>
<p>当事件发生时，事件源会创建一个相应的事件对象，并将其传递给已注册的所有事件监听器。事件监听器根据具体的事件类型来响应事件。</p>
<ol start="5">
<li>处理事件</li>
</ol>
<p>在事件监听器中实现事件响应的具体逻辑，例如弹出对话框、更新界面等。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JButton button = new JButton(&quot;Click me&quot;);</span><br><span class="line">button.addActionListener(new ActionListener() &#123; // 注册事件监听器</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        JOptionPane.showMessageDialog(null, &quot;Button clicked&quot;); // 弹出对话框</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用事件处理机制时应该选择合适的事件源和事件监听器，并遵循事件驱动的编程模式来开发程序，以便实现良好的交互效果和用户体验。</p>
<h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><h4 id="进程和线程的区别（了解）"><a href="#进程和线程的区别（了解）" class="headerlink" title="进程和线程的区别（了解）"></a>进程和线程的区别（了解）</h4><p>进程和线程都是操作系统中用于实现多任务的概念，但它们有以下区别：</p>
<ol>
<li>调度对象</li>
</ol>
<p>进程是操作系统中资源分配的基本单位，一个进程可以包含多个线程，每个进程拥有独立的内存空间和系统资源。线程是进程的一个执行单元，线程共享进程的内存空间和系统资源。</p>
<ol start="2">
<li>系统开销</li>
</ol>
<p>创建和撤销进程需要较大的系统开销，包括内存空间、系统资源等的分配和回收。而创建和撤销线程的系统开销很小，因为它们共享进程的资源。</p>
<ol start="3">
<li>并发性能</li>
</ol>
<p>由于进程拥有独立的内存空间和系统资源，因此在多核CPU上能够实现真正的并发执行，但进程切换的代价较高。而线程共享进程的资源，因此在线程之间的切换代价较小，但在多核CPU上并不能实现真正的并发执行。</p>
<ol start="4">
<li>通信方式</li>
</ol>
<p>由于进程之间拥有独立的内存空间，因此它们必须通过IPC（进程间通信）机制进行通信。而线程之间共享进程的内存空间，因此它们可以直接访问共享的数据结构来进行通信。</p>
<p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p>
<h4 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h4><ol>
<li>继承Thread类</li>
</ol>
<p>继承Thread类并重写run()方法来定义线程的执行逻辑。使用start()方法启动线程。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread thread = new MyThread();</span><br><span class="line">thread.start(); // 启动线程</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现Runnable接口</li>
</ol>
<p>实现Runnable接口并重写run()方法来定义线程的执行逻辑。将Runnable对象作为参数传递给Thread类的构造方法以创建线程，并使用start()方法启动线程。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyRunnable runnable = new MyRunnable();</span><br><span class="line">Thread thread = new Thread(runnable);</span><br><span class="line">thread.start(); // 启动线程</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p>
<p>3.在Java中，有两种创建多线程的方式：继承 <code>Thread</code> 类和实现 <code>Runnable</code> 接口。但是，这两种方式都只能返回 <code>void</code> 类型的结果，如果要求线程执行完毕后返回一个结果，可以使用 <code>Callable</code> 接口。</p>
<p><code>Callable</code> 是类似于 <code>Runnable</code> 的接口，它们都是为那些其实例可能被另一个线程执行的类设计的。一个关键的区别是 <code>Callable</code> 支持泛型的返回值，而在 <code>Runnable</code> 中的 <code>run()</code> 方法则不能有任何返回值。</p>
<p>下面是使用 <code>Callable</code> 接口创建多线程的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(new MyCallable());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们定义了一个实现了 <code>Callable</code> 接口的类 <code>MyCallable</code>，其中 <code>call()</code> 方法返回一个 <code>Integer</code> 类型的值，表示对 1 到 100 求和的结果。然后，在 <code>main()</code> 方法中，我们通过 <code>ExecutorService</code> 接口创建了一个单一线程池，并通过 <code>submit()</code> 方法提交了一个 <code>MyCallable</code> 类的实例。最后，通过 <code>Future</code> 接口的 <code>get()</code> 方法获取线程执行的结果。</p>
<p>需要注意的是，在使用 <code>Callable</code> 创建多线程时，我们需要使用 <code>ExecutorService</code> 接口来管理线程池。并且，<code>Future</code> 接口的 <code>get()</code> 方法会阻塞当前线程，直到任务完成并返回结果。 </p>
<h4 id="线程的生命周期及其状态转换"><a href="#线程的生命周期及其状态转换" class="headerlink" title="线程的生命周期及其状态转换"></a>线程的生命周期及其状态转换</h4><p>在Java中，线程的生命周期可以描述为以下五个状态：</p>
<ol>
<li>新建状态（New）</li>
</ol>
<p>当线程对象被创建时，它处于新建状态。此时还没有开始执行线程的run()方法。</p>
<ol start="2">
<li>就绪状态（Runnable）</li>
</ol>
<p>当线程调用start()方法后，它进入就绪状态。此时线程已经获得了除CPU以外的所有资源，只等待系统为其分配CPU资源。</p>
<ol start="3">
<li>运行状态（Running）</li>
</ol>
<p>当线程获得CPU资源后，它进入运行状态。此时线程开始执行run()方法中的逻辑代码。</p>
<ol start="4">
<li>阻塞状态（Blocked）</li>
</ol>
<p>当线程因为某些原因无法继续执行时，例如线程调用sleep()方法、等待I&#x2F;O操作完成等，它进入阻塞状态。此时线程不会占用CPU时间，也不会参与竞争CPU资源。</p>
<ol start="5">
<li>终止状态（Terminated）</li>
</ol>
<p>当线程执行完run()方法或者发生异常而导致线程中断时，它进入终止状态。此时线程已经完成了它的使命，不再具有可执行性。</p>
<p>线程之间可以相互转换状态，主要包括以下三种状态转换：</p>
<ol>
<li><p>就绪状态 -&gt; 运行状态：当线程获得CPU资源时，它从就绪状态转换到运行状态。</p>
</li>
<li><p>运行状态 -&gt; 阻塞状态：当线程调用sleep()方法、wait()方法等导致它无法继续执行时，它从运行状态转换到阻塞状态。</p>
</li>
<li><p>阻塞状态 -&gt; 就绪状态：当线程调用sleep()方法、wait()方法等过程结束后，它从阻塞状态转换回就绪状态。</p>
</li>
</ol>
<p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p>
<p><img src="file:///C:/Users/26927/Pictures/Typedown/3385e99f-6fa8-42ec-a24b-a48134c68fa9.png" alt="3385e99f-6fa8-42ec-a24b-a48134c68fa9"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="java-thread"></p>
<h4 id="多线程的同步"><a href="#多线程的同步" class="headerlink" title="多线程的同步"></a>多线程的同步</h4><p>在多线程编程中，由于多个线程可能会同时访问和修改共享的资源，因此需要采取措施来保证线程之间的安全性和正确性。常用的同步方法有以下几种：</p>
<ol>
<li>synchronized关键字</li>
</ol>
<p>synchronized关键字可以修饰方法或代码块，它可以保证同一时间只有一个线程访问被synchronized修饰的代码区域。当线程进入synchronized代码块时，会自动获取相应对象的锁，其他线程必须等待该线程执行完毕后才能继续执行。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increment() &#123;</span><br><span class="line">    // 对共享资源进行操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Lock接口</li>
</ol>
<p>Lock接口提供了比synchronized更加灵活和高级的锁机制，它支持更多的锁类型、多个条件变量等功能。使用Lock接口时需要手动获取和释放锁，以保证同一时间只有一个线程访问关键代码区域。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock(); // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    // 对共享资源进行操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock(); // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>volatile关键字</li>
</ol>
<p>volatile关键字用于修饰共享变量，它可以保证所有线程都能够看到最新的变量值，从而避免出现重排序等问题。但是volatile并不能保证多个线程之间对共享变量进行复合操作的原子性，因此在这种情况下还需要采用其他同步方式。</p>
<p>在Java中，volatile是一种轻量级的同步机制，它可以保证多个线程访问共享变量时能够看到最新的值。具体来说，使用volatile关键字修饰的变量具有以下特性：</p>
<ol>
<li>可见性</li>
</ol>
<p>当一个线程修改了volatile变量的值时，其他线程都能够立即看到最新的值，而不会出现数据脏读等问题。</p>
<ol start="2">
<li>原子性</li>
</ol>
<p>对于单次读&#x2F;写操作的变量，volatile关键字保证了其原子性（即操作不可被拆分），但是对于复合操作（例如i++）依然无法保证其原子性。</p>
<ol start="3">
<li>禁止指令重排</li>
</ol>
<p>编译器和处理器在执行程序时为了提高效率，可能会对指令进行重排序，但这种重排序可能会导致程序出错。使用volatile关键字可以禁止指令重排，从而确保程序的正确性和安全性。</p>
<p>需要注意的是，虽然volatile可以保证可见性和禁止指令重排，但是它并不能替代锁机制，因此在需要保证原子性的操作中仍然需要采用锁或其他同步机制。</p>
<p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p>
<h4 id="多线程之间的通信"><a href="#多线程之间的通信" class="headerlink" title="多线程之间的通信"></a>多线程之间的通信</h4><p>在线程之间进行通信是多线程编程中非常重要的一部分，这可以帮助不同的线程协调工作并共享数据。常用的多线程通信方式有以下几种：</p>
<ol>
<li>wait()和notify()&#x2F;notifyAll()</li>
</ol>
<p>wait()和notify()&#x2F;notifyAll()方法是Object类中定义的方法，它们用于实现线程之间的等待和唤醒。当一个线程调用wait()方法时，它会释放对象的锁并进入等待状态，直到其他线程调用notify()&#x2F;notifyAll()方法来唤醒它；而当一个线程调用notify()&#x2F;notifyAll()方法时，它会唤醒一个或所有正在等待该对象的线程。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.wait(); // 等待被唤醒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            // 执行相应操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyThread() &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            lock.notify(); // 唤醒等待线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>CountDownLatch类</li>
</ol>
<p>CountDownLatch类是Java提供的一种多线程同步工具，它可以让一个或多个线程等待其他线程完成操作后再继续执行。在初始化CountDownLatch时需要指定计数器的初始值，每当一个线程完成相应操作时，计数器的值就会减1；当计数器的值减为0时，等待线程就会被唤醒。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public MyRunnable(CountDownLatch latch) &#123;</span><br><span class="line">        this.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 执行相应操作</span><br><span class="line">        latch.countDown(); // 计数器减1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CountDownLatch latch = new CountDownLatch(10);</span><br><span class="line">for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(new MyRunnable(latch)).start();</span><br><span class="line">&#125;</span><br><span class="line">latch.await(); // 等待所有线程完成操作</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CyclicBarrier类</li>
</ol>
<p>CyclicBarrier类也是Java提供的一种多线程同步工具，它可以让多个线程在某个屏障处等待，并在所有线程都到达屏障时继续执行。在初始化CyclicBarrier时需要指定参与线程的数量，每当一个线程到达屏障时，它就会调用await()方法等待其他线程；当所有线程都到达屏障时，它们就可以继续执行。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    public MyRunnable(CyclicBarrier barrier) &#123;</span><br><span class="line">        this.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 执行相应操作</span><br><span class="line">        barrier.await(); // 等待其他线程到达屏障</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CyclicBarrier barrier = new CyclicBarrier(10);</span><br><span class="line">for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(new MyRunnable(barrier)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用多线程编程时应该遵循线程安全的原则，并合理地控制线程的数量和优先级，以便实现有效的并发性能和良好的用户体验。</p>
<h4 id="线程池的使用（了解）"><a href="#线程池的使用（了解）" class="headerlink" title="线程池的使用（了解）"></a>线程池的使用（了解）</h4><p>线程池可以有效地管理和复用线程，从而提高程序的运行效率和性能。Java中提供了ThreadPoolExecutor类来实现线程池的功能，其使用方法如下：</p>
<ol>
<li>创建线程池</li>
</ol>
<p>可以通过ThreadPoolExecutor类的构造函数来创建一个线程池，其中需要指定核心线程数、最大线程数、线程空闲时间等参数。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="line">    5, // 核心线程数</span><br><span class="line">    10, // 最大线程数</span><br><span class="line">    60, // 线程空闲时间（秒）</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    new ArrayBlockingQueue&lt;Runnable&gt;(100)); // 任务队列</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>提交任务</li>
</ol>
<p>可以通过executor.submit()或executor.execute()方法来向线程池提交任务，其中submit()方法返回一个Future对象，可以用于获取任务执行结果。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 执行相应任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关闭线程池</li>
</ol>
<p>可以通过executor.shutdown()或executor.shutdownNow()方法来关闭线程池，其中shutdown()方法是平滑关闭线程池，会等待所有任务执行完毕后再关闭；而shutdownNow()方法是强制关闭线程池，会立即终止所有正在执行的任务。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.shutdown(); // 平滑关闭线程池</span><br><span class="line">// 或者</span><br><span class="line">executor.shutdownNow(); // 强制关闭线程池</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用线程池时应该合理地设置核心线程数、最大线程数和任务队列大小，以避免因线程过多或任务过多导致系统资源不足或死锁等问题。同时，也应该遵循线程安全的原则来编写并发程序，以保证程序的正确性和稳定性。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h3><h4 id="网络通信协议-了解"><a href="#网络通信协议-了解" class="headerlink" title="网络通信协议(了解)"></a>网络通信协议(了解)</h4><p>网络通信协议是计算机网络中用于规定数据传输格式和传输方式的约定，是保证网络通信正确、高效、安全的基础。常见的网络通信协议有以下几种：</p>
<ol>
<li>TCP&#x2F;IP协议</li>
</ol>
<p>TCP&#x2F;IP协议是Internet网络使用的最基本的协议，它包括两个部分：传输控制协议（TCP）和互联网协议（IP）。TCP负责可靠地传输数据，确保数据的正确性和完整性；而IP负责将数据包从源主机传输到目标主机。</p>
<ol start="2">
<li>HTTP协议</li>
</ol>
<p>HTTP协议是超文本传输协议，它是一种基于请求-响应模式的协议，常用于Web应用中进行客户端和服务器之间的通信。HTTP使用TCP作为其传输层协议，支持三种请求方法：GET、POST和HEAD。</p>
<ol start="3">
<li>FTP协议</li>
</ol>
<p>FTP协议是文件传输协议，用于在客户端和服务器之间传输文件。FTP使用TCP作为其传输层协议，支持文件上传、下载、重命名等操作。</p>
<ol start="4">
<li>SMTP协议</li>
</ol>
<p>SMTP协议是简单邮件传输协议，用于在不同的邮件系统之间传送邮件。SMTP使用TCP作为其传输层协议，支持邮件发送、接收、转发等操作。</p>
<ol start="5">
<li>DNS协议</li>
</ol>
<p>DNS协议是域名系统协议，用于将域名转换成IP地址或反向解析。DNS使用UDP作为其传输层协议，支持域名解析、缓存查询等操作。</p>
<ol start="6">
<li>SSL&#x2F;TLS协议</li>
</ol>
<p>SSL&#x2F;TLS协议是安全套接字层&#x2F;传输层安全协议，用于保护网络通信的安全性。SSL&#x2F;TLS使用TCP作为其传输层协议，在数据传输过程中使用加密技术和数字证书来确保数据的保密性和完整性。</p>
<p>需要注意的是，不同的网络通信协议具有不同的特点和适用范围，应根据具体需求选择合适的协议，并遵守相应的协议规范来编写程序。同时，也应该关注网络安全问题，采取相应措施保障数据的安全性和隐私性。</p>
<h6 id="TCP-x2F-IP参考模型"><a href="#TCP-x2F-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h6><p><img src="file:///C:/Users/26927/Pictures/Typedown/207be562-0a32-4f5c-8b85-8563a8c56db7.png" alt="207be562-0a32-4f5c-8b85-8563a8c56db7"></p>
<p>TCP&#x2F;IP参考模型分为四层，从下往上依次是：网络接口层、网络层、传输层和应用层。每个层次都有其特定功能，并且使用不同的协议来实现这些功能。具体地：</p>
<ol>
<li><p><strong>网络接口层</strong>：该层负责处理与物理媒介（如网线、光纤等）相关的所有问题，包括数据在媒介上传输的方式、流控制、错误检测和物理寻址等。在TCP&#x2F;IP模型中，这一层对应OSI模型中的物理层和数据链路层。常见的协议有Ethernet、Wi-Fi、PPP等。</p>
</li>
<li><p><strong>网络层</strong>：该层主要是解决数据在网络中的传输问题，包括数据包的路由选择和转发、IP地址的管理和分配等。在TCP&#x2F;IP模型中，这一层对应OSI模型中的网络层。常见的协议有IP、ICMP、ARP等。</p>
</li>
<li><p><strong>传输层</strong>：该层负责数据的可靠传输，包括建立连接、流量控制、数据重传等功能。在TCP&#x2F;IP模型中，这一层对应OSI模型中的传输层和会话层。常见的协议有TCP、UDP等。</p>
</li>
<li><p><strong>应用层</strong>：该层提供网络应用程序与用户之间的接口，负责实现具体的应用功能，如电子邮件、文件传输、网页浏览等。在TCP&#x2F;IP模型中，这一层对应OSI模型中的表示层和应用层。常见的协议有HTTP、FTP、SMTP等。</p>
</li>
</ol>
<h4 id="UDP通信-了解"><a href="#UDP通信-了解" class="headerlink" title="UDP通信(了解)"></a>UDP通信(了解)</h4><p>UDP通信是一种基于用户数据报协议（User Datagram Protocol，简称UDP）的无连接网络通信方式，它不需要像TCP一样先建立连接再进行数据传输，因此在网络上的实时性和效率比较高。</p>
<p>UDP通信的特点如下：</p>
<ol>
<li>无连接</li>
</ol>
<p>UDP通信不需要像TCP一样先建立连接，可以直接发送数据包。因此，UDP的开销比TCP要小，适用于一些实时性要求高的场合。</p>
<ol start="2">
<li>不可靠</li>
</ol>
<p>由于UDP没有连接的概念，所以不会保证数据传输的可靠性，可能会出现数据丢失、重复、乱序等问题。</p>
<ol start="3">
<li>简单</li>
</ol>
<p>相对于TCP而言，UDP的实现比较简单，代码量也比较少，因此在实现一些简单的网络应用时，可以考虑使用UDP。</p>
<p>UDP通信的使用步骤如下：</p>
<ol>
<li>创建DatagramSocket对象，并指定客户端的IP地址和端口号。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket = new DatagramSocket();</span><br><span class="line">InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">int port = 8888;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建DatagramPacket对象，用于封装数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = &quot;Hello, UDP!&quot;.getBytes();</span><br><span class="line">DatagramPacket packet = new DatagramPacket(data, data.length, address, port);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(packet);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收数据包。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);</span><br><span class="line">socket.receive(receivePacket);</span><br><span class="line">String message = new String(receivePacket.getData(), 0, receivePacket.getLength());</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>关闭DatagramSocket对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，在使用UDP通信时需要处理好数据传输的可靠性和安全性问题。例如，可以采用分组确认、校验码等技术来提高数据传输的可靠性；同时，也可以采用加密技术和数字签名等手段来保证数据的安全性和完整性</p>
<h4 id="TCP通信（了解）"><a href="#TCP通信（了解）" class="headerlink" title="TCP通信（了解）"></a>TCP通信（了解）</h4><p>TCP通信是一种基于传输控制协议（Transmission Control Protocol，简称TCP）的面向连接的网络通信方式，它可以保证数据传输的可靠性和完整性，被广泛应用于互联网上的各种应用中。</p>
<p>TCP通信的特点如下：</p>
<ol>
<li>面向连接</li>
</ol>
<p>TCP通信需要先建立连接，然后才能进行数据传输。在连接建立过程中会进行一系列的握手过程，以确保连接的可靠性和正确性。</p>
<ol start="2">
<li>可靠性高</li>
</ol>
<p>由于TCP采用了一系列的流量控制、拥塞控制以及确认机制等技术，因此可以保证数据传输的可靠性和完整性，不容易出现数据丢失、重复、乱序等问题。</p>
<ol start="3">
<li>稳定性好</li>
</ol>
<p>TCP通信具有较好的稳定性，即使在网络状况较差的情况下也可以保持较高的传输效率和速度。</p>
<p>TCP通信的使用步骤如下：</p>
<ol>
<li>创建Socket对象，并指定服务器的IP地址和端口号。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取输入输出流，进行数据的读写操作。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">// 读取数据</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int length = inputStream.read(buffer);</span><br><span class="line">String message = new String(buffer, 0, length);</span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">String data = &quot;Hello, TCP!&quot;;</span><br><span class="line">outputStream.write(data.getBytes());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关闭Socket对象。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用TCP通信时需要处理好连接建立和断开的过程，以及数据传输的可靠性和安全性问题。例如，可以采用连接池和连接复用技术来提高连接的利用率；同时，也可以采用加密技术和数字签名等手段来保证数据的安全性和完整性。</p>
<h4 id="网络程序的开发"><a href="#网络程序的开发" class="headerlink" title="网络程序的开发"></a>网络程序的开发</h4><p>网络程序的开发一般需要遵循以下步骤：</p>
<ol>
<li>设计网络协议</li>
</ol>
<p>在进行网络程序开发之前，需要首先设计好通信协议，即规定数据传输格式和传输方式的约定。这是保证网络通信正确、高效、安全的基础。常见的网络通信协议有TCP&#x2F;IP、HTTP、FTP、SMTP等，应根据具体需求选择合适的协议，并遵守相应的协议规范来编写程序。</p>
<ol start="2">
<li>编写服务器端程序</li>
</ol>
<p>服务器端程序一般用于监听客户端的请求，并进行相应的处理。在编写服务器端程序时，需要使用相应的网络库或框架，例如Java中的Socket、ServerSocket、Netty、Spring Boot等，根据设计好的协议进行数据处理和响应。</p>
<ol start="3">
<li>编写客户端程序</li>
</ol>
<p>客户端程序一般用于向服务器端发送请求，并接收服务器端的响应。在编写客户端程序时，也需要使用相应的网络库或框架，例如Java中的Socket、URLConnection、HttpClient、OkHttp等，根据设计好的协议进行数据的读写。</p>
<ol start="4">
<li>测试和调试</li>
</ol>
<p>完成程序的编写后，需要进行测试和调试，以确保程序的正确性和稳定性。可以采用各种工具和技术，例如Junit、Mockito、Postman、Wireshark等，对程序进行单元测试、集成测试、接口测试、网络流量分析等，及时发现并修复问题。</p>
<ol start="5">
<li>部署和运维</li>
</ol>
<p>当程序测试通过后，就可以进行部署和运维了。需要将程序发布到相应的服务器上，配置好环境和参数，并设置相应的监控和日志系统，以便及时发现和解决问题。同时，也需要对程序进行维护和更新，以满足不断变化的业务需求和安全风险。</p>
<p>在Java中，可以使用多种方式来开发网络程序，常用的包括Socket、ServerSocket、URLConnection、HttpClient、Netty等。</p>
<p>使用Socket和ServerSocket：</p>
<p>Socket和ServerSocket是Java中最基本的网络编程类，它们提供了TCP&#x2F;IP协议的支持，可以实现客户端和服务器之间的通信。其中，Socket用于建立连接并进行数据传输，而ServerSocket用于监听客户端的请求和接受连接。以下是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">while (true) &#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    InputStream inputStream = socket.getInputStream();</span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">    // 读取客户端发送的数据</span><br><span class="line">    byte[] buffer = new byte[1024];</span><br><span class="line">    int length = inputStream.read(buffer);</span><br><span class="line">    String message = new String(buffer, 0, length);</span><br><span class="line"></span><br><span class="line">    // 处理数据</span><br><span class="line">    String response = &quot;Hello, &quot; + message;</span><br><span class="line"></span><br><span class="line">    // 发送响应数据</span><br><span class="line">    outputStream.write(response.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);</span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">String data = &quot;World!&quot;;</span><br><span class="line">outputStream.write(data.getBytes());</span><br><span class="line"></span><br><span class="line">// 接收响应数据</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int length = inputStream.read(buffer);</span><br><span class="line">String response = new String(buffer, 0, length);</span><br></pre></td></tr></table></figure>

<p> 使用URLConnection和HttpClient：</p>
<p>除了使用Socket和ServerSocket外，还可以使用Java内置的URLConnection和第三方库HttpClient来进行网络编程。URLConnection支持HTTP协议，可以实现简单的HTTP请求和响应。而HttpClient则是一个功能强大的HTTP客户端库，可以实现各种HTTP请求和响应。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 使用URLConnection发送GET请求</span><br><span class="line">URL url = new URL(&quot;http://example.com&quot;);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">connection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line"></span><br><span class="line">InputStream inputStream = connection.getInputStream();</span><br><span class="line">BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">StringBuilder response = new StringBuilder();</span><br><span class="line">String line;</span><br><span class="line">while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">    response.append(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用HttpClient发送POST请求</span><br><span class="line">CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">HttpPost httpPost = new HttpPost(&quot;http://example.com&quot;);</span><br><span class="line">httpPost.setEntity(new StringEntity(&quot;&#123;\&quot;key\&quot;:\&quot;value\&quot;&#125;&quot;));</span><br><span class="line"></span><br><span class="line">CloseableHttpResponse httpResponse = httpClient.execute(httpPost);</span><br><span class="line">HttpEntity entity = httpResponse.getEntity();</span><br><span class="line">String response = EntityUtils.toString(entity);</span><br></pre></td></tr></table></figure>

<p>使用Netty：</p>
<p>Netty是一个基于NIO的高性能网络编程框架，可以快速开发复杂的网络应用。它提供了丰富、灵活的API和事件模型，支持各种协议和编解码器。以下是一个简单的Netty案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">try &#123;</span><br><span class="line">    ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">    bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                     ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                     pipeline.addLast(new StringDecoder());</span><br><span class="line">                     pipeline.addLast(new StringEncoder());</span><br><span class="line">                     pipeline.addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                         @Override</span><br><span class="line">                         protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;</span><br><span class="line">                             String response = &quot;Hello, &quot; + msg;</span><br><span class="line">                             ctx.channel().writeAndFlush(response);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    ChannelFuture future = bootstrap.bind(8888).sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">try &#123;</span><br><span class="line">    Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">    bootstrap.group(group)</span><br><span class="line">             .channel(NioSocketChannel.class)</span><br><span class="line">             .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                     ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                     pipeline.addLast(new StringDecoder());</span><br><span class="line">                     pipeline.addLast(new StringEncoder());</span><br><span class="line">                     pipeline.addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                         @Override</span><br><span class="line">                         protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;</span><br><span class="line">                             System.out.println(msg);</span><br><span class="line">                             ctx.channel().close();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">    ChannelFuture future = bootstrap.connect(&quot;127.0.0.1&quot;, 8888).sync();</span><br><span class="line">    future.channel().writeAndFlush(&quot;World!&quot;).sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在进行网络程序开发时，需要处理好数据传输的可靠性和安全性问题。例如，可以采用分组确认、校验码、加密技术和数字签名等技术来提高数据传输的可靠性和安全性；同时，也应该关注网络攻击和安全漏洞等问题，采取相应措施保障网络的安全性。 </p>
<h3 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h3><h4 id="JDBC原理（了解）"><a href="#JDBC原理（了解）" class="headerlink" title="JDBC原理（了解）"></a>JDBC原理（了解）</h4><p><img src="file:///C:/Users/26927/Pictures/Typedown/53456b23-3d52-44f5-95db-3e65db0e04dc.png" alt="53456b23-3d52-44f5-95db-3e65db0e04dc"></p>
<p>JDBC是Java数据库连接的标准接口，它定义了一组用于访问和操作数据库的API。在使用JDBC时，可以通过DriverManager类来获取数据库连接，并使用Connection、Statement、PreparedStatement、ResultSet等接口来进行数据库操作。</p>
<p>JDBC的工作原理如下：</p>
<p><img src="file:///C:/Users/26927/Pictures/Typedown/56ad66ce-a912-4aaa-a2c7-577052c7e9f9.png" alt="56ad66ce-a912-4aaa-a2c7-577052c7e9f9"></p>
<ol>
<li>加载并注册数据库驱动</li>
</ol>
<p>要想连接数据库，首先需要加载并注册数据库驱动。可以通过Class.forName()方法或DriverManager.registerDriver()方法来完成这一步骤。</p>
<ol start="2">
<li>建立数据库连接</li>
</ol>
<p>在注册完数据库驱动后，就可以使用DriverManager.getConnection()方法来获取数据库连接。该方法需要传入数据库URL、用户名和密码等参数。如果连接成功，则返回一个Connection对象，否则抛出SQLException异常。</p>
<ol start="3">
<li>创建和执行SQL语句</li>
</ol>
<p>在获取到Connection对象后，就可以使用Statement、PreparedStatement等接口来创建和执行SQL语句。其中，Statement适用于静态SQL语句，而PreparedStatement适用于动态SQL语句。调用executeUpdate()方法可以执行更新操作，调用executeQuery()方法可以执行查询操作，并返回一个ResultSet对象。</p>
<ol start="4">
<li>处理查询结果</li>
</ol>
<p>对于执行查询操作返回的ResultSet对象，可以使用其提供的方法来遍历结果集、获取数据、关闭资源等操作。例如，可以使用next()方法来将游标移动到下一行，并返回一个布尔值表示是否还有更多的行；也可以使用getString()、getInt()等方法来获取指定列的数据。</p>
<ol start="5">
<li>关闭连接和资源</li>
</ol>
<p>当最终完成数据库操作后，应该及时关闭数据库连接和相关资源，以释放资源并避免内存泄漏。可以分别调用Connection、Statement和ResultSet对象的close()方法来实现关闭。</p>
<p>需要注意的是，在使用JDBC进行数据库编程时，应该遵循事务管理、连接池复用、预编译SQL语句等最佳实践，以提高程序的性能和可靠性。同时，也应该注意处理SQL注入等安全问题，采取相应措施保障数据的安全性。</p>
<h4 id="Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；"><a href="#Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；" class="headerlink" title="Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；"></a>Connection接口、Statement接口、ResultSet接口、PreparedStatement接口的使用；</h4><p>在JDBC中，Connection、Statement、ResultSet和PreparedStatement是常用的接口，用于进行数据库操作。</p>
<ol>
<li>Connection接口<br><img src="file:///C:/Users/26927/Pictures/Typedown/e456d783-f2f2-41c8-b426-2b0d1f6988d6.png" alt="e456d783-f2f2-41c8-b426-2b0d1f6988d6"><br><img src="file:///C:/Users/26927/Pictures/Typedown/82810560-a2f7-468d-a0bf-cc0cd2a366f5.png" alt="82810560-a2f7-468d-a0bf-cc0cd2a366f5"></li>
</ol>
<p>Connection接口代表一个与数据库的物理连接。使用该接口可以创建Statement、PreparedStatement等对象，也可以控制事务提交、回滚等操作。以下是使用Connection接口建立与MySQL数据库的连接的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/mydatabase&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Statement接口<br><img src="file:///C:/Users/26927/Pictures/Typedown/49f5e2f0-9b02-4080-93b2-24803483ef17.png" alt="49f5e2f0-9b02-4080-93b2-24803483ef17"></li>
</ol>
<p>Statement接口用于执行静态SQL语句（即在编译期就已经确定的SQL语句）。它提供了executeQuery()、executeUpdate()、execute()等方法来执行SQL语句，并返回ResultSet或int类型的结果。以下是使用Statement执行查询操作的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ResultSet接口</li>
<li><img src="file:///C:/Users/26927/Pictures/Typedown/256c026c-3def-47f9-8410-35f67b6bd683.png" alt="256c026c-3def-47f9-8410-35f67b6bd683"></li>
</ol>
<p>ResultSet接口代表一个结果集，其中包含查询到的数据。它提供了各种获取数据的方法，例如getInt()、getString()、getDouble()等方法。以下是使用ResultSet获取数据的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>PreparedStatement接口<br><img src="file:///C:/Users/26927/Pictures/Typedown/01bd44fd-44ca-4101-a9a6-edd48f5f3bfc.png" alt="01bd44fd-44ca-4101-a9a6-edd48f5f3bfc"></p>
</li>
<li><p><img src="file:///C:/Users/26927/Pictures/Typedown/92a78951-33e1-4e67-b96b-0a9c00075090.png" alt="92a78951-33e1-4e67-b96b-0a9c00075090"></p>
</li>
</ol>
<p>PreparedStatement接口用于执行动态SQL语句（即在运行期通过变量拼接而成的SQL语句）。相比Statement接口，PreparedStatement可以预编译SQL语句，在多次执行同一条SQL语句时可以提高性能，并且可以避免SQL注入攻击。以下是使用PreparedStatement执行插入操作的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pstmt = conn.prepareStatement(&quot;INSERT INTO users(name, age) VALUES (?, ?)&quot;);</span><br><span class="line">pstmt.setString(1, &quot;Tom&quot;);</span><br><span class="line">pstmt.setInt(2, 18);</span><br><span class="line">int rowsAffected = pstmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<p>以上是这四个接口的简单使用示例，实际开发中需要根据具体情况使用不同的接口来完成不同的数据库操作，同时注意处理异常、释放资源等问题</p>
<h4 id="使用JDBC操作数据库"><a href="#使用JDBC操作数据库" class="headerlink" title="使用JDBC操作数据库"></a>使用JDBC操作数据库</h4><p>使用JDBC操作数据库通常需要以下步骤：</p>
<ol>
<li>加载驱动程序</li>
</ol>
<p>在JDBC中，每个数据库驱动都由一个类实现。因此，首先需要通过Class.forName()方法加载相应的驱动程序类。例如，在MySQL中，可以使用以下代码来加载MySQL驱动程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立连接</li>
</ol>
<p>在加载完驱动程序后，就可以使用DriverManager.getConnection()方法建立与数据库的连接。该方法需要传入数据库URL、用户名和密码等参数。例如，在MySQL中，可以使用以下代码来建立数据库连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/mydatabase&quot;;</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">String password = &quot;123456&quot;;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建Statement或PreparedStatement对象</li>
</ol>
<p>在建立连接之后，就可以创建Statement或PreparedStatement对象，用于执行SQL语句。其中，Statement适用于静态SQL语句，而PreparedStatement适用于动态SQL语句。例如，在MySQL中，可以使用以下代码来创建Statement对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>或者创建PreparedStatement对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pstmt = conn.prepareStatement(&quot;INSERT INTO users(name, age) VALUES (?, ?)&quot;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行SQL语句并处理结果</li>
</ol>
<p>在创建好Statement或PreparedStatement对象后，就可以调用其executeQuery()、executeUpdate()等方法执行SQL语句，并获取执行结果。例如，在MySQL中，可以使用以下代码来执行查询操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM users&quot;);</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者执行插入操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pstmt.setString(1, &quot;Tom&quot;);</span><br><span class="line">pstmt.setInt(2, 18);</span><br><span class="line">int rowsAffected = pstmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>关闭连接和相关资源</li>
</ol>
<p>在完成数据库操作后，应该及时关闭数据库连接和相关资源，以释放资源并避免内存泄漏。可以分别调用Connection、Statement和ResultSet对象的close()方法来实现关闭。</p>
<p>以上是使用JDBC操作数据库的基本流程，需要注意的是，实际开发中还需要考虑事务管理、异常处理、数据类型转换等问题，以保障程序的性能和可靠性。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/myblog/2023/08/16/22-11-24-2022%E9%BB%91%E9%A9%ACPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="2022黑马Python学习笔记">
                  <i class="fa fa-angle-left"></i> 2022黑马Python学习笔记
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bennett Gao</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/myblog/js/comments.js"></script><script src="/myblog/js/utils.js"></script><script src="/myblog/js/motion.js"></script><script src="/myblog/js/next-boot.js"></script>

  






  






<!-- 樱花特效 -->
  
	<script async src="js/fairyDustCursor.js" type="text/javascript"><script>
  	

<script src="/myblog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/myblog/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
